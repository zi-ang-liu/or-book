---
title: データ包絡分析
format:
  html:
    code-fold: true
jupyter: python3
---

## 用語集

| English                         | Japanese   |
| ------------------------------- | ---------- |
| Data Envelopment Analysis (DEA) | データ包絡分析 |
| Decision Making Unit (DMU)      |  意思決定主体；意思決定単位  |
| Reference Set                   | 参照集合     |
| Efficient                       |   効率的      |
| Efficient Frontier                |   効率的フロンティア    |

:::{.callout-tip}
## 予備知識
- 線形代数
- 線形計画法
:::

<!-- :::{#exm-thinking-experiment}
### 思考実験

::: -->

**データ包絡分析**（DEA: Data Envelopment Analysis）は，分析対象の効率性を評価するための手法である．DEAでは，分析対象のことを**DMU**（Decision Making Unit）と呼ばれ，複数の**入力**（input）から複数の**出力**（output）への変換を行うものである．

下の表は，いくつかのDMUの例を示している．

|DMU|入力|出力|
|--|--|--|
|店舗|店員数，面積|売上高，顧客数|
|大学|教員数，研究費|卒業生数，論文数，特許数|
|病院|医師数，看護師数，ベッド数|患者数，手術件数，治癒率|

## 1入力1出力

$n$ 個のDMUがあり，$\text{DMU}_j$ ($j=1,2,\ldots,n$) は1つの入力 $x_j$ と1つの出力 $y_j$ を持つとする．そのとき，$\text{DMU}_j$ の効率性は

$$
\frac{y_j}{x_j}
$$

で評価できる．単位入力あたりの出力を表している．この値が大きいほど，効率的であると評価できる．

:::{#exm-one-input-one-output}

### 1入力1出力の問題例

ある会社は，以下の6つの店舗を運営している．効率的である店舗はどれか．

|店舗|A|B|C|D|E|F|
|--|--|--|--|--|--|--|
|店員数（$x$）|2|3|3|4|2|5|
|売上高（$y$）|1|3|2|3|2|2|

$\text{DMU}_j$ の店員数を $x_j$，売上高を $y_j$ とすると，店舗 $j$ の効率性は $y_j/x_j$ で計算できる．

```{python}
import matplotlib.pyplot as plt
import pandas as pd

data = {
    "store": ["A", "B", "C", "D", "E", "F"],
    "employee": [2, 3, 3, 4, 2, 5],
    "sale": [1, 3, 2, 3, 2, 2],
}
df = pd.DataFrame(data)
df["efficiency"] = df["sale"] / df["employee"]
print(df)
```

横軸に店員数，縦軸に売上高をとって，点 $(x_j, y_j)$ をプロットした散布図を下の図に示す．原点から点 $(x_j, y_j)$ を結ぶ直線の傾きは，$y_j/x_j$ に等しい．

```{python}
plt.scatter(df["employee"], df["sale"])
for i in range(len(df)):
    plt.text(df["employee"][i] + 0.1, df["sale"][i], df["store"][i])
plt.plot([0, 4], [0, 4], color="red", linestyle="--", label="efficient frontier")
plt.xlabel("Employee")
plt.ylabel("Sale")
plt.xlim(0, 6)
plt.ylim(0, 4)
plt.legend()
plt.grid()
plt.show()
```

店舗BとEは，**効率的**（efficient）と言える．また，原点から店舗B（または店舗E）を結ぶ直線を**効率的フロンティア**（efficient frontier）と呼ぶ．

:::

## 2入力1出力

:::{#exm-two-input-one-output}
### 2入力1出力の問題例

ある会社は，以下の6つの店舗を運営している．効率的である店舗はどれか．

|店舗|A|B|C|D|E|F|
|--|--|--|--|--|--|--|
|店員数|4|7|8|4|2|5|
|面積|3|3|1|2|4|2|
|売上高|1|1|1|1|1|1|

$\text{DMU}_j$ の店員数を $x_{j}$，面積を $y_{j}$，売上高を $z_{j}$ とする．それぞれの店舗に対して，次の2つの比率を計算する．

$$
\frac{x_{j}}{z_{j}},\quad \frac{y_{j}}{z_{j}}
$$

これらの値が小さいほど，効率的であると評価できる．

$x_{j}/z_{j}$ と $y_{j}/z_{j}$ を横軸と縦軸にとった散布図を下の図に示す．

```{python}
import matplotlib.pyplot as plt
import pandas as pd

data = {
    "store": ["A", "B", "C", "D", "E", "F"],
    "employee": [4, 7, 8, 4, 2, 5],
    "area": [3, 3, 1, 2, 4, 2],
    "sale": [1, 1, 1, 1, 1, 1],
}
df = pd.DataFrame(data)
plt.figure(figsize=(8, 6))
plt.scatter(df["employee"], df["area"])
for i in range(len(df)):
    plt.text(df["employee"][i] + 0.1, df["area"][i], df["store"][i])
plt.plot(
    [2, 2, 4, 8, 9],
    [5, 4, 2, 1, 1],
    color="red",
    linestyle="--",
    label="efficient frontier",
)
plt.xlabel("Employee/Sale")
plt.ylabel("Area/Sale")
plt.xlim(0, 9)
plt.ylim(0, 5)
plt.legend()
plt.grid()
plt.show()
```

$C, D, E$ は効率的で，これらの点を結ぶ折れ線が効率的フロンティアとなる．


:::

## 1入力2出力

:::{#exm-one-input-two-output}
### 1入力2出力の問題例
ある会社は，以下の6つの店舗を運営している．効率的である店舗はどれか．

|店舗|A|B|C|D|E|F|
|--|--|--|--|--|--|--|
|店員数|1 | 1 | 1 | 1 | 1 | 1 |
|売上高|1 | 2 | 3 | 4 | 4 | 6 |
|顧客数|5 | 7 | 4 | 3 | 6 | 2 |

$\text{DMU}_j$ の店員数を $x_{j}$，売上高を $y_{j}$，顧客数を $z_{j}$ とする．それぞれの店舗に対して，次の2つの比率を計算する．

$$
\frac{y_{j}}{x_{j}},\quad \frac{z_{j}}{x_{j}}
$$

これらの値が大きいほど，効率的であると評価できる．

```{python}
import matplotlib.pyplot as plt
import pandas as pd

data = {
    "store": ["A", "B", "C", "D", "E", "F"],
    "employee": [1, 1, 1, 1, 1, 1],
    "sale": [1, 2, 3, 4, 4, 6],
    "customer": [5, 7, 4, 3, 6, 2],
}
df = pd.DataFrame(data)
plt.figure(figsize=(8, 6))
plt.scatter(df["sale"], df["customer"])
for i in range(len(df)):
    plt.text(df["sale"][i] + 0.1, df["customer"][i], df["store"][i])
plt.plot(
    [0, 2, 4, 6, 6],
    [7, 7, 6, 2, 0],
    color="red",
    linestyle="--",
    label="efficient frontier",
)
plt.xlabel("sale/employee")
plt.ylabel("customer/employee")
plt.xlim(0, 7)
plt.ylim(0, 8)
plt.legend()
plt.grid()
plt.show()
```

店舗B，E，Fは効率的で，これらの点を結ぶ折れ線が効率的フロンティアとなる．
:::

## CCRモデル

CCRモデルは，1978年にCharnes, Cooper, and Rhodesによって提案されたもので，DEAの基本的なモデルである．

$n$ 個のDMUを評価する．各DMUは $m$ 個の入力と $s$ 個の出力を持つとする．$\text{DMU}_j$ ($j=1,2,\ldots,n$) の $i$ 番目の入力を $x_{ij}$，$r$ 番目の出力を $y_{rj}$ と表す．このとき，入力データと出力データはそれぞれ次のような行列で表される．

$$
\mathbf{X} =
\begin{pmatrix}
x_{11} & x_{12} & \cdots & x_{1n} \\
x_{21} & x_{22} & \cdots & x_{2n} \\
\vdots & \vdots & \ddots & \vdots \\
x_{m1} & x_{m2} & \cdots & x_{mn}
\end{pmatrix}
$$

$$
\mathbf{Y} =
\begin{pmatrix}
y_{11} & y_{12} & \cdots & y_{1n} \\
y_{21} & y_{22} & \cdots & y_{2n} \\
\vdots & \vdots & \ddots & \vdots \\
y_{s1} & y_{s2} & \cdots & y_{sn}
\end{pmatrix}
$$

入力の重み $\mathbf{v}$ と出力の重み $\mathbf{u}$ を
$$
\mathbf{v} =
\begin{pmatrix}
v_1 \\ v_2 \\ \vdots \\ v_m
\end{pmatrix},\quad
\mathbf{u} =
\begin{pmatrix}
u_1 \\ u_2 \\ \vdots \\ u_s
\end{pmatrix}
$$

とし，$\text{DMU}_o$ の効率性 $h_o$ は

$$
h_o = \frac{\sum_{r=1}^{s} u_r y_{ro}}{\sum_{i=1}^{m} v_i x_{io}} = \frac{u_1 y_{1o} + u_2 y_{2o} + \cdots + u_s y_{so}}{v_1 x_{1o} + v_2 x_{2o} + \cdots + v_m x_{mo}}
$$

として計算できる．

CCRモデルの考え方は，$\text{DMU}_o$ の効率性を最大化するような重み $\mathbf{u}$ と $\mathbf{v}$ を選ぶことである．$\text{DMU}_o$ は最適な重みを用いたとき，他のDMUとの比較を行う．

CCRモデルは次の分数計画問題として定式化できる．

\begin{align*}
\text{maximize} \quad & h_o = \frac{\sum_{r=1}^{s} u_r y_{ro}}{\sum_{i=1}^{m} v_i x_{io}} & \\
\text{subject to} \quad & \frac{\sum_{r=1}^{s} u_r y_{rj}}{\sum_{i=1}^{m} v_i x_{ij}} \leq 1, \quad & \forall j = 1, \ldots, n & \\
& u_r \geq 0, \quad & \forall r = 1, \ldots, s & \\
& v_i \geq 0, \quad & \forall i = 1, \ldots, m 
\end{align*}

この分数計画問題は，$h_o$ を最大化する重み $\mathbf{u}$ と $\mathbf{v}$ を求めるものである．制約条件は，すべてのDMUの効率性が1以下であることを保証している．

:::{.callout-note}
厳密に，制約条件は

$$
\frac{u_r}{\sum_{i=1}^{m} v_i x_{io}} \geq \epsilon > 0, \quad \forall r = 1, \ldots, s
$$

$$
\frac{v_i}{\sum_{i=1}^{m} v_i x_{io}} \geq \epsilon > 0, \quad \forall i = 1, \ldots, m
$$

とする必要がある．
:::

この分数計画問題において，任意の $\alpha > 0$ に対して，$(\mathbf{u}^*, \mathbf{v}^*)$ を最適解とすると，$(\alpha \mathbf{u}^*, \alpha \mathbf{v}^*)$ も最適解となる．
したがって，この分数計画問題は無限に多くの最適解を持つ．この問題を解決するために，分母を1に固定することで，次の線形計画問題に変換できる．

\begin{align*}
\text{maximize} \quad & h_o = \sum_{r=1}^{s} u_r y_{ro} & \\
\text{subject to} \quad & \sum_{i=1}^{m} v_i x_{io} = 1 & \\
& \sum_{r=1}^{s} u_r y_{rj} - \sum_{i=1}^{m} v_i x_{ij} \leq 0, \quad & \forall j = 1, \ldots, n & \\
& u_r \geq 0, \quad & \forall r = 1, \ldots, s & \\
& v_i \geq 0, \quad & \forall i = 1, \ldots, m 
\end{align*}

:::{#def-dea-ccr}
1. $h_o^* = 1$ かつ最適解 $\mathbf{u}^* > 0$，$\mathbf{v}^* > 0$ のとき，$\text{DMU}_o$ は**効率的**（efficient）である．
2. $h_o^* < 1$ のとき，$\text{DMU}_o$ は**非効率的**（inefficient）である．
:::

:::{#exm-dea-ccr-one-input-one-output}
### CCRモデルの例（1入力1出力）


|DMU|A|B|C|D|E|F|
|--|--|--|--|--|--|--|
|Input|2|3|3|4|2|5|
|Output|1|3|2|3|2|2|

入力に対する重みを $v$，出力に対する重みを $u$ とする． $\text{DMU}_A$ の効率性を評価するCCRモデルは次のようになる．

\begin{align*}
\text{maximize} \quad & u & \\
\text{subject to} \quad & 2v = 1 & \\
& u - 2v \leq 0 & \\
& 3u - 3v \leq 0 & \\
& 2u - 3v \leq 0 & \\
& 3u - 4v \leq 0 & \\
& 2u - 2v \leq 0 & \\
& 2u - 5v \leq 0 & \\
& u \geq 0 & \\
& v \geq 0 &
\end{align*}

この線形計画問題を解くと，最適値は $0.5$ であり，$\text{DMU}_A$ は非効率的であることがわかる．同様にして，すべてのDMUについてCCRモデルを解くと，次の結果が得られる．

```python
!pip install gurobipy
from gurobipy import Model, GRB

def ccr(inputs, outputs, dmu_index):
    num_dmu = len(inputs)
    model = Model("DEA_CCR")
    # 変数の定義
    u = model.addVar(name="u", lb=0)
    v = model.addVar(name="v", lb=0)
    # 目的関数の定義
    model.setObjective(u * outputs[dmu_index], GRB.MAXIMIZE)
    # 制約条件の定義
    model.addConstr(v * inputs[dmu_index] == 1, "input_normalization")
    for j in range(num_dmu):
        model.addConstr(
            u * outputs[j] - v * inputs[j] <= 0,
            f"efficiency_constraint_{j}",
        )
    # 最適化の実行
    model.optimize()
    if model.status == GRB.OPTIMAL:
        efficiency = model.objVal
        u_val = u.X
        v_val = v.X
        return efficiency, u_val, v_val
    else:
        return None


if __name__ == "__main__":

    inputs = [2, 3, 3, 4, 2, 5]
    outputs = [1, 3, 2, 3, 2, 2]
    results = []
    u = []
    v = []
    for i in range(len(inputs)):
        efficiency, u_val, v_val = ccr(inputs, outputs, i)
        results.append(efficiency)
        u.append(u_val)
        v.append(v_val)
    for i in range(len(inputs)):
        print(f"DMU_{chr(65+i)}: Efficiency = {results[i]:.4f}, u = {u[i]:.4f}, v = {v[i]:.4f}")
```

```
DMU_A: Efficiency = 0.5000, u = 0.5000, v = 0.5000
DMU_B: Efficiency = 1.0000, u = 0.3333, v = 0.3333
DMU_C: Efficiency = 0.6667, u = 0.3333, v = 0.3333
DMU_D: Efficiency = 0.7500, u = 0.2500, v = 0.2500
DMU_E: Efficiency = 1.0000, u = 0.5000, v = 0.5000
DMU_F: Efficiency = 0.4000, u = 0.2000, v = 0.2000
```
:::