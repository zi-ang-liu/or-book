---
title: PERT/CPM
format:
  html:
    code-fold: true
jupyter: python3
---

<!-- 

- Camm et al. (2022) Chapter 9
- Taha (2016) Chapter 6
- Hillier and Lieberman (2020) Chapter 22
- Eiselt and Sandblom (2019) Chapter 8

-->

プロジェクトは、多くの作業からなる。プロジェクトを完遂できるように、作業のスケジュールを作成する必要がある。その方法として、**PERT**（Program Evaluation and Review Technique）と**CPM**（Critical Path Method）がある。現在では、PERTとCPMが統合され、**PERT/CPM**として知られている[@Camm2022-zv; @Hillier2025-cb]。

:::{.callout-note}
PERT/CPMは「基本情報技術者試験」や「応用情報技術者試験」などで頻出のトピックのようです．他にも，線形計画法，在庫問題，ゲーム理論，データ分析，データベース，データ構造とアルゴリズムなど，様々な経営工学関係のトピックが出題されます．経営工学を学ぶ学生は，受けてみると良いでしょう．
:::

## プロジェクト

ここで、ある作業の開始前に完了しなければならない作業を**先行作業**（Immediate Predecessor）と呼ぶ。また、ある作業の完了後に開始できる作業を**後続作業**（Immediate Successor）と呼ぶ。

まとめると、プロジェクトは、次の要素で構成される。

- 作業：プロジェクトを構成する仕事。活動、アクティビティとも呼ばれる。
- 先行関係：それぞれの作業の先行作業を定義する関係。
- 作業時間：各作業に必要な時間。

:::{#exm-pert-report}
学生の田中さんと佐藤さんが協力し、ある授業のレポートを作成することになった。このレポートを作成するためには、下の表に示すように、いくつかの作業を行う必要がある。

| 作業 | 作業内容     | 先行作業 | 時間（日） |
| ---- | ------------ | -------- | ---------- |
| A    | 課題の理解   | -        | 2          |
| B    | データ収集   | A        | 3          |
| C    | データ分析   | B        | 4          |
| D    | 文献調査     | A        | 2          |
| E    | レポート作成 | C, D     | 5          |
:::

## プロジェクト・ネットワーク

プロジェクトをネットワークで表現したものを**プロジェクト・ネットワーク**（Project Network）と呼ぶ。プロジェクト・ネットワークには、**AOA**（Activity on Arrow）や **AON**（Activity on Node）という 2 種類の表現方法がある。

AOA では、作業を辺で表現し、先行関係を点で表現する。AON では、作業を点で表現し、先行関係を辺で表現する。AON のほうが理解と作成が容易で、実務でも AON がよく使われる[@Camm2022-zv; @Hillier2025-cb; @Eiselt2022-qy]。これは以降、AON に基づいて説明する。

プロジェクト・ネットワークは $G = (V, E)$ という有向グラフで表される。ここで、$V$ は始点 $s$、終点 $t$ と各作業を表す点の集合であり、$E$ は先行関係を表す辺の集合である。辺 $(v, u) \in E$ では、$v$ が $u$ の先行作業であることを意味する。

辺 $(s, v) \in E$ は、作業 $v$ が先行作業を持たないことを意味し、辺 $(v, t) \in E$ は、作業 $v$ が後続作業を持たないことを意味する。作業 $v$ の先行作業の集合を $\mathcal{P}(v)$ と表す。作業 $v$ の後続作業の集合を $\mathcal{S}(v)$ と表す。

作業点 $v \in V$ には、作業時間 $\tau(v)$ が与えられている。始点 $s$ と終点 $t$ の作業時間は $\tau(s) = \tau(t) = 0$ とする。

@exm-pert-report のプロジェクト・ネットワークは次の図のようになる。

```{python}
import matplotlib.pyplot as plt
import networkx as nx
import numpy as np

# グラフの作成（頂点を番号で定義）
G = nx.DiGraph()
edges = [
    ("s", "A"),
    ("A", "B"),
    ("A", "D"),
    ("B", "C"),
    ("C", "E"),
    ("D", "E"),
    ("E", "t"),
]
G.add_edges_from(edges)

for layer, nodes in enumerate(nx.topological_generations(G)):
    for node in nodes:
        G.nodes[node]["layer"] = layer

pos = nx.multipartite_layout(G, subset_key="layer")

label_pos = {}
for k, (x, y) in pos.items():
    r = np.sqrt(x**2 + y**2) if np.sqrt(x**2 + y**2) > 0 else 1
    scale = 1.12
    label_pos[k] = (x * scale, y * scale)

# Plotting
nx.draw_networkx(
    G,
    pos=pos,
    with_labels=True,
    node_color="white",
    node_size=500,
    edgecolors="black",
)
plt.axis("off")
plt.show()
```

:::{#exm-pert-2}

以下の作業リストに基づいて、プロジェクト・ネットワークを作成せよ。

| 作業 | 先行作業 | 時間（日） |
| ---- | -------- | ---------- |
| A    | -        | 2          |
| B    | -        | 3          |
| C    | A        | 4          |
| D    | A        | 2          |
| E    | B        | 5          |
| F    | C, D, E     | 9          |
| G    | E        | 2          |

```{python}
import matplotlib.pyplot as plt
import networkx as nx
import numpy as np

# グラフの作成（頂点を番号で定義）
G = nx.DiGraph()
edges = [
    ("s", "A"),
    ("s", "B"),
    ("A", "C"),
    ("A", "D"),
    ("C", "F"),
    ("D", "F"),
    ("B", "E"),
    ("E", "G"),
    ("E", "F"),
    ("G", "t"),
    ("F", "t"),
]
G.add_edges_from(edges)

for layer, nodes in enumerate(nx.topological_generations(G)):
    for node in nodes:
        G.nodes[node]["layer"] = layer

pos = nx.multipartite_layout(G, subset_key="layer")

label_pos = {}
for k, (x, y) in pos.items():
    r = np.sqrt(x**2 + y**2) if np.sqrt(x**2 + y**2) > 0 else 1
    scale = 1.12
    label_pos[k] = (x * scale, y * scale)

# Plotting
nx.draw_networkx(
    G,
    pos=pos,
    with_labels=True,
    node_color="white",
    node_size=500,
    edgecolors="black",
)
plt.axis("off")
plt.show()
```
:::


## クリティカルパス {#sec-critical-path}

プロジェクト・ネットワークにおいて、始点 $s$ から終点 $t$ までの経路を**パス**と呼ぶ。パスの長さは、そのパス上の作業時間の合計である。パス $P = (s, v_{i_1}, v_{i_2}, \ldots, v_{i_k}, t)$ の長さは、

$$
\sum_{v \in P} \tau(v) = \tau(v_{i_1}) + \tau(v_{i_2}) + \cdots + \tau(v_{i_k})
$$

である。

最も長いパスを**クリティカルパス**（Critical Path）と呼ぶ。クリティカルパスに含まれる作業を**クリティカル作業**（Critical Activity）と呼ぶ。クリティカル作業が遅延すると、プロジェクト全体の完了が遅延する。

クリティカルパスを求める問題は、最長路問題に帰着できるが、ここで述べる方法は、プロジェクトにおける様々な有用な情報も提供する。

### 最早開始時刻と最早終了時刻

作業点 $v \in V$ の最も早く開始できる時間を**最早開始時刻**（Earliest Start Time）と呼び、$ES(v)$ と表す。$v$ の最も早く終了できる時間を**最早終了時刻**（Earliest Finish Time）と呼び、$EF(v)$ と表す。始点 $s$ の最早開始時刻は $ES(s) = 0$ とする。

$v$ の最早終了時刻は、最早開始時刻に作業時間を加えたものである。

$$
EF(v) = ES(v) + \tau(v)
$$

$u$ の最早開始時刻は、$u$ の先行作業 $v \in \mathcal{P}(u)$ の中で最早終了時刻 $EF(v)$ が最大のものである。

$$
ES(u) = \max_{v \in \mathcal{P}(u)} EF(v)
$$

で与えられる。

:::{#exm-ES-EF}

作業点 $D$ の先行作業を $A, B, C$ とする．そのとき，$\mathcal{P}(D) = \{A, B, C\}$ である．$EF(A) = 2$，$EF(B) = 3$，$EF(C) = 6$ とすると，$D$ の最早開始時刻は，

$$
ES(D) = \max\{EF(A), EF(B), EF(C)\} = \max\{2, 3, 6\} = 6
$$

である．

```{python}
import matplotlib.pyplot as plt
import networkx as nx

# グラフの作成（頂点を番号で定義）
G = nx.DiGraph()
edges = [
    ("A", "D"),
    ("B", "D"),
    ("C", "D"),
]
G.add_edges_from(edges)

# A, B, C を縦に並べる

pos = {
    "A": (0, 1),
    "B": (0, 0),
    "C": (0, -1),
    "D": (2, 0),
}
# Plotting
nx.draw_networkx(
    G,
    pos=pos,
    with_labels=True,
    node_color="white",
    node_size=500,
    edgecolors="black",
)
plt.axis("off")
plt.show()
```

:::

最早開始時刻と最早終了時刻を求めるアルゴリズムは下の通りである。ここで、点を**トポロジカルオーダー**(topological order)で処理するとは、$v$ のすべての先行作業 $u \in \mathcal{P}(v)$ が $v$ より前に処理されるように点を順序付けることである。

::: {#alg-forward-pass}
**Forward Pass Algorithm**

1. $ES(s) \leftarrow 0$, $EF(s) \leftarrow 0$.
2. **For each** $v \in V \setminus \{s\}$ in topological order **do**
   1. $ES(v) \leftarrow \max_{u \in \mathcal{P}(v)} EF(u)$.
   2. $EF(v) \leftarrow ES(v) + \tau(v)$.
:::

@exm-pert-2 のプロジェクト・ネットワークに対して、最早開始時刻と最早終了時刻を求めると、次の表のようになる。

| $v$ | $\mathcal{P}(v)$ | $\tau(v)$ | $ES(v)$ | $EF(v)$ | 
|----|----------|--------|------|------|
| s  | -        | 0      | 0    | 0    | 
| A  | s        | 2      | 0    | 2    |
| B  | s        | 3      | 0    | 3    | 
| C  | A        | 4      | 2    | 6    | 
| D  | A        | 2      | 2    | 4    |  
| E  | B        | 5      | 3    | 8    | 
| F  | C, D, E | 9      | 8    | 17   | 
| G  | E        | 2      | 8    | 10   | 
| t  | F, G     | 0      | 17   | 17   | 

作業 F を開始するためには、作業 C、D、E のすべてが完了している必要がある。そのため、作業 F の開始時間は、作業 C、D、E の中で最も遅い完了時間に依存する。作業 C、D、E の完了時間はそれぞれ 6 日、4 日、8 日であるため、作業 F の最も早い開始時間は 8 日となる。

### 最遅開始時刻と最遅終了時刻

作業点 $v$ の遅くとも始めないといけない時間を**最遅開始時刻**（Latest Start Time）と呼び、$LS(v)$ と表す。$v$ の遅くとも終わらせないといけない時間を**最遅終了時刻**（Latest Finish Time）と呼び、$LF(v)$ と表す。

終点 $t$ の最遅終了時刻は $LF(t) = EF(t)$ とする。

$v$ の最遅開始時刻は、最遅終了時刻から作業時間を引いたものである。

$$
LS(v) = LF(v) - \tau(v)
$$

$u$ の最遅終了時刻は、$u$ の後続作業 $v \in \mathcal{S}(u)$ の中で $LS(v)$ が最小のものである。

$$
LF(u) = \min_{v \in \mathcal{S}(u)} LS(v)
$$

:::{#exm-LS-LF}

作業点 $C$ の後続作業を $D, E, F$ とする．そのとき，$\mathcal{S}(C) = \{D, E, F\}$ である．$LS(D) = 6$，$LS(E) = 3$，$LS(F) = 8$ とすると，$C$ の最遅終了時刻は，
$$
LF(C) = \min\{LS(D), LS(E), LS(F)\} = \min\{6, 3, 8\} = 3
$$
である．

```{python}
import matplotlib.pyplot as plt

import networkx as nx

# グラフの作成（頂点を番号で定義）
G = nx.DiGraph()
edges = [
    ("C", "D"),
    ("C", "E"),
    ("C", "F"),
]
G.add_edges_from(edges)

pos = {
    "C": (0, 0),
    "D": (2, 1),
    "E": (2, 0),
    "F": (2, -1),
}
# Plotting
nx.draw_networkx(
    G,
    pos=pos,
    with_labels=True,
    node_color="white",
    node_size=500,
    edgecolors="black",
)
plt.axis("off")
plt.show()
```
:::

@exm-pert-2 のプロジェクト・ネットワークに対して、最遅開始時刻と最遅終了時刻を求めると、次の表のようになる。

| $v$ | $\mathcal{S}(v)$ | $\tau(v)$ | $LS(v)$ | $LF(v)$ | 
|----|----------|--------|------|------|
| s  | A, B     | 0       | 0    | 0    |
| A  | C, D     | 2      | 2    | 4    |
| B  | E        | 3      | 0    | 3    |
| C  | F        | 4      | 4    | 8    |
| D  | F        | 2      | 6    | 8    |
| E  | F, G     | 5      | 3    | 8    | 
| F  | t        | 9      | 8    | 17   | 
| G  | t        | 2      | 15   | 17   | 
| t  | -        | 0      | 17   | 17   |

### スラック

作業点 $v$ の**スラック**（Slack）を $SL(v)$ と表す。スラックは、

$$
SL(v) = LS(v) - ES(v) = LF(v) - EF(v)
$$

で与えられる。スラックは、作業 $v$ の開始または終了を遅らせることができる時間を示す。

@exm-pert-2 のプロジェクト・ネットワークに対して、スラックを求めると、次の表のようになる。

| $v$ | $\tau(v)$ | $ES(v)$ | $EF(v)$ | $LS(v)$ | $LF(v)$ | $SL(v)$ |
|----|--------|------|------|------|------|------|
| s  | 0      | 0    | 0    | 0    | 0    | 0    |
| A  | 2      | 0    | 2    | 2    | 4    | 2    |
| B  | 3      | 0    | 3    | 0    | 3    | 0    |
| C  | 4      | 2    | 6    | 4    | 8    | 2    |
| D  | 2      | 2    | 4    | 6    | 8    | 4    |
| E  | 5      | 3    | 8    | 3    | 8    | 0    |
| F  | 9      | 8    | 17   | 8    | 17   | 0    |
| G  | 2      | 8    | 10   | 15   | 17   | 7    |
| t  | 0      | 17   | 17   | 17   | 17   | 0    |

スラックが 0 の作業はクリティカル作業である。したがって、@exm-pert-2 のプロジェクト・ネットワークにおけるクリティカルパスは、$s \to B \to E \to F \to t$ であり、このパスの長さは 17 日である。

## 3 点見積もり

以上の方法では、作業の所要時間が確定していることを前提としている。しかし、実際には、所要時間の推定は難しい場合が多い。そこで、作業の所要時間を確率変数として扱い、3 点見積もり（Three-Point Estimation）という方法でその作業時間の平均と分散を推定する。

3 点見積もりでは、次の 3 つの所要時間を事前に与えられたとする。

- 楽観値（Optimistic Time, $a$）：予想される最短の所要時間。
- 最頻値（Most Likely Time, $m$）：最も可能性が高い所要時間。
- 悲観値（Pessimistic Time, $b$）：予想される最長の所要時間。

一般に、$a \leq m \leq b$ である。

この $a$、$m$、$b$ に基づいて、所要時間の平均 $\hat{\mu}$ と分散 $\hat{\sigma}^2$ を次のように推定する。

:::{.callout-note} 
作業の所要時間がベータ分布に従うと仮定した場合は、@eq-pert-3point が $\mu$ と $\sigma^2$ の良い推定量となる。これらの式の詳細な導出は省略する。興味のある読者は、@Pleguezuelo2003-uf を参照されたい。
:::

$$
\hat{\mu} = \frac{a + 4m + b}{6}, \quad \hat{\sigma}^2 = \left(\frac{b - a}{6}\right)^2
$$ {#eq-pert-3point}


そこで、$\mu(v)$ と $\sigma^2(v)$ をそれぞれ作業点 $v$ の所要時間の平均と分散とする。$a(v)$、$m(v)$、$b(v)$ をそれぞれ作業点 $v$ の楽観値、最頻値、悲観値とする。このとき、すべての作業点 $v \in V$ に対して、

$$
\mu(v) = \frac{a(v) + 4m(v) + b(v)}{6}, \quad \sigma^2(v) = \left(\frac{b(v) - a(v)}{6}\right)^2
$$

で $\mu(v)$ と $\sigma^2(v)$ を計算する。

@exm-pert-2 のプロジェクト・ネットワークに対して、各作業点の楽観値、最頻値、悲観値が次のように与えられたとするとき、平均と分散を求めると、次の表のようになる。

| $v$ | $a$ | $m$ | $b$ | $\mu$ | $\sigma^2$ |
|----|------|------|------|--------|----------|
| s  | 0    | 0    | 0    | 0      | 0        |
| A  | 0.5  | 2    | 3.5    | 2      | 0.25     |
| B  | 1.5  | 3    | 4.5    | 3      | 0.25     |
| C  |  1.5  | 3    | 4.5    | 3      | 0.25     |
| D  |  0.5  | 2    | 3.5    | 2      | 0.25     |
| E  | 1    | 5.5    | 7    | 5      | 1        |
| F  | 5    | 8    | 17   | 9      | 4        |
| G  | 0.5  | 2    | 3.5    | 2      | 0.25     |
| t  | 0    | 0    | 0    | 0      | 0        |

## 不確実性を考慮したPERT/CPM

3 点見積もりを用いて、各作業点 $v \in V$ の所要時間の平均 $\mu(v)$ と分散 $\sigma^2(v)$ を求めたとする。このとき、与えられた時間までにプロジェクトが完了する確率を求めたい。

プロジェクト・ネットワークにおけるパス $P = (s, v_{i_1}, v_{i_2}, \ldots, v_{i_k}, t)$ の所要時間の平均 $\mu(P)$ と分散 $\sigma^2(P)$ は、それぞれ次のように推定できる。

$$
\mu(P) = \sum_{v \in P} \mu(v), \quad \sigma^2(P) = \sum_{v \in P} \sigma^2(v)
$$

パス $P$ の所要時間の標準偏差 $\sigma(P)$ は、

$$
\sigma(P) = \sqrt{\sigma^2(P)}
$$

で与えられる。求められたパスの中で、所要時間の平均 $\mu(P)$ が最大のパスをクリティカルパス $P^*$ とする。@sec-critical-path で述べた方法でクリティカルパスを求めることができる。

クリティカルパス $P^*$ の所要時間を $X$ とし、与えられた時間 $d$ までにプロジェクトが完了する確率を $\mathbb{P}(X \leq d)$ と表す。

:::{.callout-note}
ここでは、計算を簡単にするために、クリティカルパスが最も時間がかかるパスであると仮定している。実際には、平均値から計算されたクリティカルパスが、最も時間がかかるパスであるとは限らないことに注意されたい。
:::

$$
\mathbb{P}(X \leq d) = \phi\left(\frac{d - \mu(P^*)}{\sigma(P^*)}\right)
$$

ここで、$\phi(z)$ は標準正規分布の確率密度関数である。$z$ は次のように計算し、標準正規分布表を用いて $\phi(z)$ を調べる。

$$
z = \frac{d - \mu(P^*)}{\sigma(P^*)}
$$

@exm-pert-2 では、クリティカルパスは $s \to B \to E \to F \to t$ であり、このパスの所要時間の平均、分散、標準偏差は次のように計算できる。

$$
\mu(P^*) = 3 + 5 + 9 = 17
$$

$$
\sigma^2(P^*) = 0.25 + 1 + 4 = 5.25
$$

$$
\sigma(P^*) = \sqrt{5.25} \approx 2.29
$$

与えられた時間 $d = 20$ 日までにプロジェクトが完了する確率を求めるには、次のように計算する。

$z$ を計算すると、

$$
z = \frac{20 - 17}{2.29} \approx 1.31
$$

標準正規分布表を用いて、$\phi(1.31) \approx 0.9049$ である。したがって、与えられた時間 $d = 20$ 日までにプロジェクトが完了する確率は約 90.49% である。

## 時間とコストのトレードオフ

作業時間を短縮するには、コストがかかる。最小のコストでプロジェクトを短縮する問題を考える。

### 問題の定式化


- $c_i$: 作業 $i$ の単位時間あたりの短縮コスト
- $M_i$: 作業 $i$ の最大短縮時間
- $T$: プロジェクトの完了時間の上限
- $\tau_i$: 作業 $i$ の標準所要時間
- $y_i$: 作業 $i$ の開始時間
- $x_i$: 作業 $i$ の短縮時間

\begin{align*}
\text{minimize} \quad & \sum_{i} c_i x_i &\\
\text{subject to} \quad & y_j \geq y_i + \tau_i - x_i, \quad & \forall (i, j) \in E \\
& 0 \leq x_i \leq M_i, \quad & \forall i \in V \\
& y_t \leq T \\
& y_s = 0
\end{align*}

### 例題

プロジェクト・ネットワークはグラフ $G = (V, E)$ で表す。作業の集合は

$$
V = \{s, t, A, B, C, D, E\}
$$
であり、辺の集合は

$$
E = \{(s, A), (s, C), (A, B), (C, D), (B, E), (D, E), (E, t)\} 
$$
である。ここで、$s$ は始点、$t$ は終点である。プロジェクト全体の所要時間の上限を $T = 10$ とする。

作業時間、コスト、最大短縮時間は次の表のように与えられる。

| 作業 | $\tau_i$ | $c_i$ | $M_i$ |
| ---- | -------- | ----- | ----- |
| A    | 7        | 100   | 3     |
| B    | 3        | 150   | 1     |
| C    | 6        | 200   | 2     |
| D    | 3        | 150   | 2     |
| E    | 2        | 250   | 1     |

この問題を次のように定式化できる。

\begin{align*}
\text{minimize} \quad & 100x_A + 150x_B + 200x_C + 150x_D + 250x_E &\\
\text{subject to} \quad & y_A \geq 0 \\
& y_C \geq 0 \\
& y_B \geq y_A + 7 - x_A \\
& y_D \geq y_C + 6 - x_C \\
& y_E \geq y_B + 3 - x_B \\
& y_E \geq y_D + 3 - x_D \\
& y_t \geq y_E + 2 - x_E \\
& 0 \leq x_A \leq 3 \\
& 0 \leq x_B \leq 1 \\
& 0 \leq x_C \leq 2 \\
& 0 \leq x_D \leq 2 \\
& 0 \leq x_E \leq 1 \\
& y_t \leq 10 \\
& y_s = 0
\end{align*}

この線形計画問題は、最適化ソルバーを用いて解くことができる。以下に Gurobi を用いた実装例を示す。

```python
!pip install gurobipy
from gurobipy import Model, GRB

# データ定義
V = ["s", "t", "A", "B", "C", "D", "E"]
E = [("s", "A"), ("s", "C"), ("A", "B"), ("C", "D"), ("B", "E"), ("D", "E"), ("E", "t")]

tau = {"A": 7, "B": 3, "C": 6, "D": 3, "E": 2}
cost = {"A": 100, "B": 150, "C": 200, "D": 150, "E": 250}
M = {"A": 3, "B": 1, "C": 2, "D": 2, "E": 1}

T = 10

# モデル作成
m = Model("Project_Crashing")
m.setParam("OutputFlag", 0) 

# 変数定義
x = {i: m.addVar(lb=0, ub=M[i], name="x_{}".format(i)) for i in M}
y = {i: m.addVar(lb=0, name="y_{}".format(i)) for i in V}

# 目的関数
m.setObjective(sum(cost[i] * x[i] for i in M), GRB.MINIMIZE)

# 制約
for i, j in E:
    if i == "s":
        m.addConstr(y[j] >= 0)
    elif i in tau:
        m.addConstr(y[j] >= y[i] + tau[i] - x[i])

# プロジェクト終了制約
m.addConstr(y["t"] <= T)

# 開始ノード固定
m.addConstr(y["s"] == 0)

# 最適化
m.optimize()

# 結果表示
print("Objective:", m.objVal)
for i in x:
    print("x_{} =".format(i), x[i].X)
for i in y:
    print("y_{} =".format(i), y[i].X)
```

```plaintext
Objective: 350.0
x_A = 1.0
x_B = 0.0
x_C = 0.0
x_D = 0.0
x_E = 1.0
y_s = 0.0
y_t = 10.0
y_A = 0.0
y_B = 6.0
y_C = 0.0
y_D = 6.0
y_E = 9.0
```

この結果から、作業 A を 1 日、作業 E を 1 日短縮することで、最小コスト 350 でプロジェクトを 10 日以内に完了できることがわかる。