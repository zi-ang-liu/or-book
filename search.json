[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "オペレーションズ・リサーチ",
    "section": "",
    "text": "Preface\nORを学ぶための教科書です．",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#注意点",
    "href": "index.html#注意点",
    "title": "オペレーションズ・リサーチ",
    "section": "注意点",
    "text": "注意点\n随時更新していきますので，読む際は必ずブラウザをリロードしてください．",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#python",
    "href": "index.html#python",
    "title": "オペレーションズ・リサーチ",
    "section": "Python",
    "text": "Python\nすべてのモデル，アルゴリズムについて，Pythonでの実装例を示します．講義では Python プログラミングについては扱いませんが，Pythonの基礎的な知識があると理解が深まります．\n以下の手順で，教材に掲載されているコードを Google Colab 上で簡単に実行できます．ぜひ試してみてください．\n\nGoogle アカウントにログインする\nGoogle Colab にアクセスする\n「+新しいノート」をクリックする\nコードをコピーして，セルに貼り付ける\nセルを実行する",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#フィードバック",
    "href": "index.html#フィードバック",
    "title": "オペレーションズ・リサーチ",
    "section": "フィードバック",
    "text": "フィードバック\n継続的に改善していきますので，誤字脱字，内容の不備，わかりにくい箇所などを見つけたら，ぜひご連絡ください．",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#内容",
    "href": "index.html#内容",
    "title": "オペレーションズ・リサーチ",
    "section": "内容",
    "text": "内容\n\n\n\n回\n内容\n\n\n\n\n1\nガイダンス\n\n\n2\n在庫モデル：EOQモデル\n\n\n3\n在庫モデル：新聞売り子問題\n\n\n4\n在庫モデル：安全在庫\n\n\n5\nグラフ理論\n\n\n6\nPERT 1\n\n\n7\nPERT 2\n\n\n8\nAHP",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "course-info.html",
    "href": "course-info.html",
    "title": "講義",
    "section": "",
    "text": "講義情報\n本授業では、オペレーションズ・リサーチ（OR）の中の代表的な手法であるPERT、在庫理論、待ち行列理論、動的計画法、階層分析法、及び包絡分析法の数理を理解し、具体的な問題への応用を学ぶ。",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#講義情報",
    "href": "course-info.html#講義情報",
    "title": "講義",
    "section": "",
    "text": "講義名：オペレーションズ・リサーチB\n曜日：水曜日\n時限：2時限目（10:50～12:30）\n教室：西館 W202\n担当教員：劉 子昂\nGoogle Classroom: Link",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#出席",
    "href": "course-info.html#出席",
    "title": "講義",
    "section": "出席",
    "text": "出席\n不定期に出席を取ります。\n出席は WebClass 上で取ります。以下の時間に注意してください。\n\n出席扱い : 10:50 - 11:09\n遅刻扱い : 11:10 - 11:29\n欠席扱い : 11:30 -",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#成績評価",
    "href": "course-info.html#成績評価",
    "title": "講義",
    "section": "成績評価",
    "text": "成績評価\n\n期末試験（100%）\n4回以上の欠席は単位取得不可。\n講義中の加点問題に正解した場合、試験の点数に加点します。",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#到達目標",
    "href": "course-info.html#到達目標",
    "title": "講義",
    "section": "到達目標",
    "text": "到達目標\n各分野について、下記の事項を目標して講義を行う。\n\nPERTの計算と解析方法を理解し、プロジェクトの評価を行うことができる。\n在庫モデルを理解し、自分で式を構築及び解析することができる。\n待ち行列理論の重要な式や定理を理論的に導出し、それらを適切に解釈することができる。\n動的計画法の基本的な考え方を理解し、簡単な問題への適用ができる。\n階層分析法による意思決定の手法を理解し、一対比較行列からウェイトと整合性を計算することができる。\n包絡分析法におけるCCRモデルを理解し、得られた結果を解釈することができる。\n\nさらに、これらの手法を用いて比較的簡単な現象をモデル化し、解析することができる。",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#orは重要",
    "href": "course-info.html#orは重要",
    "title": "講義",
    "section": "ORは重要",
    "text": "ORは重要\n経営工学において、最も重要な学問分野の一つ。\n日本経営工学会によると、「解決すべき課題の数理モデルを構築し、最適な手法を求めるオペレーションズ・リサーチ（OR）という分野は、経営工学の主要なテーマとなっています」。\n海外では、管理科学（Management Science）とORは同義語として使われることもよくある。",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#orの全体像",
    "href": "course-info.html#orの全体像",
    "title": "講義",
    "section": "ORの全体像",
    "text": "ORの全体像\n\n線形計画法\n整数計画法\n非線形計画法\n動的計画法\nグラフ理論・ネットワーク\nシミュレーション\n在庫モデル\n待ち行列\n多基準意思決定分析\nプロジェクトマネジメント\n…",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#orは難しい",
    "href": "course-info.html#orは難しい",
    "title": "講義",
    "section": "ORは難しい？",
    "text": "ORは難しい？\n\n基礎知識が必要\n微分積分、線形代数、確率、統計の基礎知識が必要です。これらの基礎が不十分な場合、授業についていけないです。基礎知識が不十分な場合、必ず復習してください。\nこの講義では、以下の工夫をしています。\n\n付録に必要な基礎知識のまとめがあります。随時更新しますので、参考にしてください。\n講義資料には例題、図、演習問題を多く用意しています。\nプログラミングの実装例も示します。\n\n\n\n数式が多い\nORは、問題を数理的にモデル化し、解析する学問です。数式をたくさん使い、証明も多いです。数式を読むのが苦手な人は、慣れるまで大変かもしれません。\nこの講義では、以下の工夫をしています。\n\n証明は省略なく丁寧に行います。\nわかりにくいところをコラムで補足します。",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#何を学ぶ",
    "href": "course-info.html#何を学ぶ",
    "title": "講義",
    "section": "何を学ぶ？",
    "text": "何を学ぶ？\n\n\nモデル：現実の問題を数理的に表現したもの\nモデリング：現実の問題を数理モデルで表現すること\n解：問題の答え\n最適化：最適解を見つけること\nアルゴリズム：問題を解く手順\n\n単に，結論・定理を覚えるだけでなく，モデリング，証明，アルゴリズムの理解が重要です。",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#python-について",
    "href": "course-info.html#python-について",
    "title": "講義",
    "section": "Python について",
    "text": "Python について\n\nすべてのアルゴリズム、モデルをPythonで実装します。\nPython の基礎については、この講義では説明しません。\nPython のコードを理解できなくても、授業内容の理解には支障ありません。\nYoutube などでは、2-3時間で Python 入門の動画がたくさんあります。事前に学習しておくことをお勧めします。",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#授業時間外の学習",
    "href": "course-info.html#授業時間外の学習",
    "title": "講義",
    "section": "授業時間外の学習",
    "text": "授業時間外の学習\n本授業の準備・復習等の授業時間外学習は、4時間を標準とする",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#必要なもの",
    "href": "course-info.html#必要なもの",
    "title": "講義",
    "section": "必要なもの",
    "text": "必要なもの\n\n本講義では，受講者自身のノートPCを用いて演習を行います．毎週必ずノートPCを持参してください．",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#私語",
    "href": "course-info.html#私語",
    "title": "講義",
    "section": "私語",
    "text": "私語\n\n講義中の私語は厳禁です．\n注意してもやめない場合は、減点を行います。",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "notation.html",
    "href": "notation.html",
    "title": "記号",
    "section": "",
    "text": "集合",
    "crumbs": [
      "記号"
    ]
  },
  {
    "objectID": "notation.html#集合",
    "href": "notation.html#集合",
    "title": "記号",
    "section": "",
    "text": "\\(A\\)\n\n集合。大文字で表す。\n\n\\(A \\setminus B\\)\n\n集合 \\(A\\) と集合 \\(B\\) の差集合。",
    "crumbs": [
      "記号"
    ]
  },
  {
    "objectID": "notation.html#線形代数",
    "href": "notation.html#線形代数",
    "title": "記号",
    "section": "線形代数",
    "text": "線形代数\n\n\n\n記号\n意味\n\n\n\n\n\\(\\mathbf{x}\\), \\(\\mathbf{y}\\)\nベクトル。太字の小文字で表す。\n\n\n\\(\\mathbf{A}\\), \\(\\mathbf{B}\\)\n行列。太字の大文字で表す。\n\n\n\\(\\mathbf{I}\\)\n単位行列。",
    "crumbs": [
      "記号"
    ]
  },
  {
    "objectID": "notation.html#確率統計",
    "href": "notation.html#確率統計",
    "title": "記号",
    "section": "確率統計",
    "text": "確率統計\n\\(X\\): 確率変数。大文字で表す。\n\\(\\mathbb{P}(X = x)\\): 確率変数 \\(X\\) が \\(x\\) をとる確率\n\\(\\mathbb{E}[X]\\): 確率変数 \\(X\\) の期待値\n\\(F_X(x)\\): 確率変数 \\(X\\) の累積分布関数\n\\(f_X(x)\\): 確率変数 \\(X\\) の確率密度関数\n\\(p_X(x)\\): 確率変数 \\(X\\) の確率質量関数\n\\(\\phi(z)\\): 標準正規分布の確率密度関数",
    "crumbs": [
      "記号"
    ]
  },
  {
    "objectID": "notation.html#関数",
    "href": "notation.html#関数",
    "title": "記号",
    "section": "関数",
    "text": "関数\n\\(A\\) は要素の間に順序が定義された集合とする。\n\\(\\max A\\): 集合 \\(A\\) の最大値。\n\\(\\min A\\): 集合 \\(A\\) の最小値。\n\\((x)^+\\): \\(x\\) と \\(0\\) のうち大きい方。すなわち、\\((x)^+ = \\max(x, 0)\\)。\n\\((x)^-\\): \\(x\\) と \\(0\\) のうち小さい方の絶対値。すなわち、\\((x)^- = \\max(-x, 0) = -\\min(x, 0)\\)。",
    "crumbs": [
      "記号"
    ]
  },
  {
    "objectID": "notation.html#例題",
    "href": "notation.html#例題",
    "title": "記号",
    "section": "例題",
    "text": "例題\n\n例 1 (差集合) \\(A = \\{1, 2, 3\\}\\)、\\(B = \\{2, 3, 4\\}\\) とする。このとき、\\(A \\setminus B = \\{1\\}\\) である。\n\n\n例 2 (最大値と最小値) \\(A = \\{1, 0, -1\\}\\) とする。このとき、\\(\\max A = 1\\)、\\(\\min A = -1\\) である。\n\n\n例 3 (正の部分) \\((10)^+ = 10\\)、\\((-30)^+ = 0\\) である。\n\n\n例 4 (負の部分) \\((10)^- = 0\\)、\\((-30)^- = 30\\) である。",
    "crumbs": [
      "記号"
    ]
  },
  {
    "objectID": "inventory/intro.html",
    "href": "inventory/intro.html",
    "title": "1  在庫管理とは",
    "section": "",
    "text": "1.1 在庫量\n商店・工場・倉庫などで、原材料・部品・製品などを適切に管理することを在庫管理（Inventory Management）という。一般的に、在庫管理の目的は、顧客の需要を満たしつつ、在庫に関わる費用を最小化することである。\n在庫量が多すぎると、保管費用がかかる。逆に、在庫量が少なすぎると、欠品が発生し、顧客の需要を満たせなくなる。在庫管理は次の二つの問題を決定する。\n科学的在庫管理（Scientific Inventory Management）では、これらの問題に答えるために、次の手順で在庫管理を行う。\n一般、\\(BO\\) と \\(OH\\) は次のように表される。\n\\[\nOH = I^+ = \\max(0, I)\n\\]\n\\[\nBO = I^- = \\max(0, -I)\n\\]",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>在庫管理とは</span>"
    ]
  },
  {
    "objectID": "inventory/intro.html#在庫量",
    "href": "inventory/intro.html#在庫量",
    "title": "1  在庫管理とは",
    "section": "",
    "text": "需要（demand）\n\nある期間に顧客が購入したい商品の量。通常、\\(d\\) で表す。\n\n手持ち在庫（on-hand inventory）\n\nある時点で、実際に手元にある在庫の量。\\(OH\\) で表す。\n\nバックオーダー（backorder）\n\n手持ち在庫がなく、満たせない需要。\\(BO\\) で表す。\n\n在庫量（inventory level）\n\nある時点での在庫の量。\\(I\\) で表す。\n\n\n\n\n\n\n例 1.1 手持ち在庫が \\(OH = 50\\)、需要が \\(d = 30\\) のとき、在庫量は次のように計算される。\n\\[\nI = 50 - 30 = 20\n\\]\n手持ち在庫が \\(OH = 50\\)、需要が \\(d = 70\\) のとき、在庫量は次のように計算される。\n\\[\nI = 50 - 70 = -20\n\\]\nこのとき、手持ち在庫は\n\\[\nOH = I^+ = \\max(0, I) = 0\n\\]\nとなる。バックオーダーは\n\\[\nBO = I^- = \\max(0, -I) = 20\n\\]\nとなる。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>在庫管理とは</span>"
    ]
  },
  {
    "objectID": "inventory/intro.html#在庫モデルの分類",
    "href": "inventory/intro.html#在庫モデルの分類",
    "title": "1  在庫管理とは",
    "section": "1.2 在庫モデルの分類",
    "text": "1.2 在庫モデルの分類\n在庫モデルは、次のような要素で分類される。\n\n需要（demand）\n\n需要が決定論的 (Deterministic) か確率的（Stochastic）か。\n\n観測（review）\n\n在庫量を連続観測 (Continuous Review) するか、周期観測 (Periodic Review) するか。連続観測の場合、在庫量が連続的に観測でき、いつでも発注が可能である。周期観測の場合、一定の期間（例えば1週間）ごとに在庫量を観測する。\n\nリードタイム（lead time）\n\n発注から納品までの期間。調達期間とも呼ばれる。リードタイムが決定論的か確率的か。また、リードタイムが0かどうか。在庫モデルを単純化するために、リードタイムを0とし、発注から納品までの期間を無視することもある。\n\nバックオーダー（backorder）\n\nバックオーダーが許容されるかどうか。需要が手持ち在庫を上回った場合、バックオーダーが許容されると、欠品が発生しても、後で需要を満たすことができる。バックオーダーが許容されない場合、欠品が発生すると、上回った需要は失われ、機会損失が発生する。\n\n計画期間（planning horizon）\n\n単一期間 (Single Period) か、複数期間 (Multi Period) か、無限 (Infinite) か。\n\n\n以下の表に、需要と観測に基づく、古典的な在庫モデルを示す。\n\n\n\n在庫モデル\n需要\n観測\n\n\n\n\nEOQモデル\n決定論的\n連続観測\n\n\nWagner-Whitin\n決定論的\n周期観測\n\n\n安全在庫\n確率的\n連続観測\n\n\n新聞売り子問題\n確率的\n周期観測",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>在庫管理とは</span>"
    ]
  },
  {
    "objectID": "inventory/intro.html#在庫の費用",
    "href": "inventory/intro.html#在庫の費用",
    "title": "1  在庫管理とは",
    "section": "1.3 在庫の費用",
    "text": "1.3 在庫の費用\nここでは、在庫に関わる費用を紹介する。\n\n発注費用（ordering cost）\n\n発注量に関わらず、1回の発注にかかる費用。調達費用、固定費用（fixed cost）などとも呼ばれる。通常、1回の発注にかかる費用を \\(K\\) とする。\n\n購入費用（purchase cost）\n\n商品を購入するためにかかる費用。通常、単位あたりの購入費用を \\(c\\) とする。\n\n欠品費用（stockout cost）\n\n需要が手持ち在庫を上回った場合に発生する費用。通常、単位あたりの欠品費用を \\(p\\) とする。\n\n保管費用（holding cost）\n\n在庫を保管するためにかかる倉庫費用、保険費用、税金、機会費用など。通常、単位時間あたりの1単位あたりの保管費用を \\(h\\) とする。\n\n\n\n例 1.2 (発注費用と購入費用) 毎回の発注量を \\(Q\\)、1回の発注にかかる費用を \\(K\\)、単位あたりの購入費用を \\(c\\) とする。1回の発注にかかる総費用は、次のように計算される。\n\\[\nK + cQ\n\\]\nとなる。\n\n\n例 1.3 (欠品費用) 在庫量を \\(I\\)、需要を \\(d\\)、単位あたりの欠品費用を \\(p\\) とする。欠品費用は次のように計算される。\n\\[\np (d - I)^+\n\\]\n\\(p = 10\\)、\\(I = 50\\)、\\(d = 70\\) のとき、欠品費用は次のように計算される。\n\\[\np (d - I)^+ = 10 (70 - 50)^+ = 200\n\\]\n\\(p = 10\\)、\\(I = 50\\)、\\(d = 20\\) のとき、欠品費用は次のように計算される。\n\\[\np (d - I)^+ = 10 (20 - 50)^+ = 0\n\\]\n\n\n\n例 1.4 (在庫量が一定の保管費用) 1日あたり1単位の在庫を保管するために、\\(h\\) の費用がかかるとする。30日間、50単位の在庫を保管するための総保管費用を計算せよ。\n保管費用は次のように計算される。 \\[\n30 \\times 50 \\times h = 1500h\n\\]\n下の図では、横軸が時間、縦軸が在庫量を表す。\n\n\nコード\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.linspace(0, 30, 1000)\ninventory = np.full_like(t, 50)\n\n# Plotting the inventory level\nplt.fill_between(t, inventory, color=\"lightgray\", alpha=0.5, label=\"Inventory Level\")\nplt.plot(t, inventory, label=\"Inventory Level\", color=\"black\", linewidth=2)\nplt.xlabel(\"Time\")\nplt.ylabel(\"Inventory Level\")\nplt.axhline(0, color=\"gray\", linewidth=1)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n一般的に、保管費用は次の式で計算される。\n\\[\n\\text{保管費用} = \\text{面積} \\times h\n\\]\n\n\n例 1.5 (在庫が時間とともに変化する保管費用) 通常、在庫量が定数ではなく、時間とともに変化する。ここでは、在庫量が時間とともに線形に減少し、0になると在庫が補充される場合を考える。毎回の発注量を \\(500\\) とする。\n下の図に示すように在庫量が時間とともに変化するとする。6 日間の保管費用を計算せよ。\n\n\nコード\n# Parameters\nd = 250  # Demand rate\nQ = 500  # Order quantity\nT = Q / d  # Cycle length\nt = np.linspace(0, 2.999 * T, 1000)\n\n# Inventory level over time\ninventory = np.maximum(0, Q - (d * t) % Q)\n\n# Plotting the inventory level\nplt.fill_between(t, inventory, color=\"lightgray\", alpha=0.5, label=\"Inventory Level\")\nplt.plot(t, inventory, label=\"Inventory Level\", color=\"black\", linewidth=2)\nplt.xlabel(\"Time\")\nplt.ylabel(\"Inventory Level\")\nplt.axhline(0, color=\"gray\", linewidth=1)\nplt.ylim(bottom=0, top=Q + 200)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n保管費用は \\(\\text{面積} \\times h\\) で計算される。それぞれの三角形の面積は \\(\\frac{1}{2} \\times 500 \\times 2\\) であるため、6 日間の保管費用は次のように計算される。\n\\[\n\\frac{2 \\times 500}{2} \\times 3 \\times h\n\\]",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>在庫管理とは</span>"
    ]
  },
  {
    "objectID": "inventory/intro.html#在庫方策",
    "href": "inventory/intro.html#在庫方策",
    "title": "1  在庫管理とは",
    "section": "1.4 在庫方策",
    "text": "1.4 在庫方策\n確率的在庫モデルにおいて、一つ重要な概念は在庫方策（inventory policy）である。在庫方策は、在庫の状況に応じて、在庫管理のルールを定めるものである。代表的な在庫方策を以下に示す。\n\n\\((r, Q)\\) 方策：在庫量を連続的に観測し、在庫量が発注点 \\(r\\) 以下になったときに発注量 \\(Q\\) を発注する方式である。発注点方式とも呼ばれる。\nBSP 方策（Base Stock Policy）：在庫量を定期的に観測し、在庫量が基準在庫 \\(S\\) 以下になったときに、在庫量を \\(S\\) まで補充する方式である。定期発注方式とも呼ばれる。\n\\((s, S)\\) 方策：在庫量を定期的に観測し、在庫量が発注点 \\(s\\) 以下になったときに、在庫量を補充点 \\(S\\) まで補充する方式である。\n\n一部の確率的在庫モデルにに対し、これらの在庫方策は最適であることが知られている。その場合、在庫方策が持つパラメータを最適化することで、在庫の期待コストを最小化することができる。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>在庫管理とは</span>"
    ]
  },
  {
    "objectID": "inventory/intro.html#練習問題",
    "href": "inventory/intro.html#練習問題",
    "title": "1  在庫管理とは",
    "section": "1.5 練習問題",
    "text": "1.5 練習問題\n\n在庫管理の目的は、_を満たしつつ、_を最小化することである。\n在庫管理の決定すべき二つの問題は、_と_である。\n在庫量 \\(I = -30\\)，需要 \\(d = 10\\) のとき、手持ち在庫 \\(OH\\) とバックオーダー \\(BO\\) を計算せよ。\n1回の発注にかかる費用 \\(K = 1000\\)、単位あたりの購入費用 \\(c = 50\\)、発注量 \\(Q = 200\\) のとき、3回の発注にかかる総費用を計算せよ。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>在庫管理とは</span>"
    ]
  },
  {
    "objectID": "inventory/intro.html#挑戦",
    "href": "inventory/intro.html#挑戦",
    "title": "1  在庫管理とは",
    "section": "1.6 挑戦",
    "text": "1.6 挑戦\n\nPython に関する入門書やビデオを参考にして、Python の基礎を学び、簡単なプログラムを書けるようにせよ。\n\nYouTube で “Python 入門” などのキーワードで検索すると、多くの2-3時間入門のビデオが見つかる。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>在庫管理とは</span>"
    ]
  },
  {
    "objectID": "inventory/eoq.html",
    "href": "inventory/eoq.html",
    "title": "2  経済的発注量",
    "section": "",
    "text": "2.1 記号\n経済的発注量（EOQ: Economic Order Quantity）モデルは、最も基本的な在庫管理モデルの一つである。Harris (1990) がこのモデルを最初に提案した。\nEOQモデルは、単位時間あたりの需要量は決定論的で、一定であると仮定する。すなわち、需要量は事前に分かっており、時間とともに変化しない。単位時間あたりの需要量は需要率（demand rate）と呼ばれ、記号 \\(d\\) で表される。リードタイムは0とし、発注から納品までの時間はないと仮定する。一回の発注量を \\(Q\\) とし、一定であるとする。欠品は許せないとする。全ての需要は満されなければならない。また、EOQモデルでは、在庫量は連続的に観測され、いつでも発注が可能であるとする。\n在庫に関わる費用は、1回あたりの発注費用 \\(K\\)、単位時間あたりの1単位の保管費用 \\(h\\) と、購入単価 \\(c\\) がある。\nEOQモデルの最適解は次の二つの性質を持つ(Snyder と Shen 2019)：\n以上の性質から、在庫量の時間的変化は下図のようになる。\n発注の間隔をサイクル(cycle)と呼び、サイクル期間は\n\\[\nT = \\frac{Q}{d}\n\\]\nで与えられる。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>経済的発注量</span>"
    ]
  },
  {
    "objectID": "inventory/eoq.html#記号",
    "href": "inventory/eoq.html#記号",
    "title": "2  経済的発注量",
    "section": "",
    "text": "記号\n意味\n\n\n\n\n\\(d\\)\n単位時間あたりの需要量\n\n\n\\(K\\)\n1回あたりの発注費用\n\n\n\\(h\\)\n単位時間あたりの1単位の保管費用\n\n\n\\(c\\)\n購入単価\n\n\n\\(Q\\)\n発注量\n\n\n\\(T\\)\nサイクル期間\n\n\n\\(g(Q)\\)\n平均コスト",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>経済的発注量</span>"
    ]
  },
  {
    "objectID": "inventory/eoq.html#コスト関数",
    "href": "inventory/eoq.html#コスト関数",
    "title": "2  経済的発注量",
    "section": "2.2 コスト関数",
    "text": "2.2 コスト関数\nここでは、1サイクルあたりのコストを考える。\n発注費用：発注は1回だけ行うため、発注費用は \\(K\\) である。\n購入費用：\\(Q\\) 個の商品を単価 \\(c\\) で購入するため、購入費用は \\(cQ\\) である。\n保管費用：サイクル期間 \\(T\\) は \\(\\frac{Q}{d}\\) であるため、1サイクルあたりの保管費用は\n\\[\n\\frac{TQ}{2} h = \\frac{hQ^2}{2d}\n\\]\nとなる。\n以上より、1サイクルあたりのコストは次のように表される。\n\\[\nK + cQ + \\frac{hQ^2}{2d}\n\\]\n平均コストは、これをサイクル期間 \\(T\\) で割ったものとして定義される。したがって、平均コスト \\(g(Q)\\) は次のように表される。\n\\[\\begin{align*}\ng(Q) &= \\frac{1}{T} \\left( K + cQ + \\frac{hQ^2}{2d} \\right) \\\\\n&= \\frac{d}{Q} \\left( K + cQ + \\frac{hQ^2}{2d} \\right) \\\\\n&= \\frac{Kd}{Q} + c d + \\frac{hQ}{2}\n\\end{align*}\\]\n以上より、平均コストは発注量 \\(Q\\) の関数として次のように表される。\n\\[\ng(Q) = \\frac{Kd}{Q} + cd + \\frac{hQ}{2}\n\\]",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>経済的発注量</span>"
    ]
  },
  {
    "objectID": "inventory/eoq.html#最適発注量",
    "href": "inventory/eoq.html#最適発注量",
    "title": "2  経済的発注量",
    "section": "2.3 最適発注量",
    "text": "2.3 最適発注量\nEOQモデルの目的は、平均コスト \\(g(Q)\\) を最小化する発注量 \\(Q\\) を求めることである。\n\n\n\n\n\n\nノート極値（Extremum）\n\n\n\n1変数関数 \\(f(x)\\) が点 \\(x = a\\) で極値をとるとき、\n\\[\nf'(a) = 0\n\\] が成り立つ。 \\(f''(a) &gt; 0\\) のとき、\\(f(a)\\) は極小値をとる。 \\(f''(a) &lt; 0\\) のとき、\\(f(a)\\) は極大値をとる。\n\n\n\n\n\n\n\n\nノート凸関数（Convex Function）\n\n\n\n1 変数 2 階微分可能な関数 \\(f(x)\\) が凸関数であることの必要十分条件は、すべての \\(x\\) について\n\\[\nf''(x) \\geq 0\n\\]\nが成り立つことである。\n凸関数 \\(f(x)\\) の極小値は、最小値である。\n\n\n平均コストの導関数 \\(g'(Q)\\) が 0 となる点を求めることで、最適発注量 \\(Q^*\\) を求めることができる。\n\\[\ng'(Q) = -\\frac{Kd}{Q^2} + \\frac{h}{2} = 0\n\\]\nこれを解くと、最適発注量\n\\[\nQ^* = \\sqrt{\\frac{2Kd}{h}}\n\\]\nを得る。これをEOQ公式（EOQ formula）と呼ぶ。\\(Q^*\\) を経済的発注量と呼ぶ（経済的は最適という意味である）。\n二階導関数 \\(g''(Q)\\) を求めて、最適発注量が最小値を与えることを確認する。\n\\[\ng''(Q) = \\frac{2Kd}{Q^3} &gt; 0\n\\]\n\\(g''(Q) &gt; 0\\) であるため、\\(Q^*\\) は最小値を与える。\n最適発注量 \\(Q^*\\) を次の定理にまとめる。\n\n定理 2.1 EOQモデルにおいて、最適発注量 \\(Q^*\\) は \\[\nQ^* = \\sqrt{\\frac{2Kd}{h}}\n\\tag{2.1}\\]\nで与えられる。\n\n\\(Q^*\\) を用いて、最適なサイクル期間 \\(T^*\\) を求めることができる。\n\\[\nT^* = \\frac{Q^*}{d} = \\sqrt{\\frac{2K}{hd}}\n\\tag{2.2}\\]\n式 2.1 と 式 2.2 から、以下の性質がわかる。\n\n\\(h\\) の増加に伴い、\\(Q^*\\) は減少する。保管費用が高い場合は、少量で高い頻度で発注することが望ましい。\n\\(K\\) の増加に伴い、\\(Q^*\\) は増加する。発注費用が高い場合は、多量で低い頻度で発注することが望ましい。\n\\(d\\) の増加に伴い、\\(Q^*\\) は増加する。\n\\(c\\) は \\(Q^*\\) に影響しない。購入単価は最適発注量に影響しない。\n\n次の図は、購入単価を \\(c = 0\\) とするとき、平均コスト \\(g(Q)\\)、発注コスト \\(\\frac{Kd}{Q}\\)、保管コスト \\(\\frac{hQ}{2}\\) のグラフを示す。\n\n\nコード\n# Parameters\nK = 40  # Order cost\nh = 10  # Holding cost\nd = 5  # Demand rate\nQ = np.linspace(1, 40, 400)  # Order quantity from 1 to 40\n\n# Cost calculations\norder_cost = K * d / Q\nholding_cost = (h * Q) / 2\naverage_cost = order_cost + holding_cost\noptimal_Q = np.sqrt(2 * K * d / h)\n\n# Plotting the costs\nplt.plot(Q, order_cost, label=r\"$Kd/Q$\", color=\"blue\")\nplt.plot(Q, holding_cost, label=r\"$hQ/2$\", color=\"orange\")\nplt.plot(Q, average_cost, label=r\"$g(Q)$\", color=\"green\", linewidth=2)\nplt.axvline(optimal_Q, color=\"red\", linestyle=\"--\", label=r\"$Q^*$\")\nplt.xlabel(\"Order Quantity Q\")\nplt.ylabel(\"Cost\")\nplt.ylim(bottom=0)\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n平均コストが最小となる発注量 \\(Q^*\\) は、発注コストと保管コストの交差点である。すなわち、発注コストと保管コストを等しくする発注量は最適な発注量 \\(Q^*\\) である。この性質は以下の式からわかる。\n\\[\n\\frac{Kd}{Q^*} = \\frac{hQ^*}{2} \\Longrightarrow Q^* = \\sqrt{\\frac{2Kd}{h}}\n\\]\nまた、この図からもわかるように、\\(Q\\) の増加に伴い、平均発注コストは減少し、平均保管コストは増加する。逆もまた然りである。\n\n例 2.2 ある電気量販店では、毎月250台のPCが販売されている。発注費用は5000円、保管費用は1台あたり月150円、購入単価は10万円とする。このとき、最適発注量 \\(Q^*\\) は次のように求められる。\n\\[\nQ^* = \\sqrt{\\frac{2 \\cdot 5000 \\cdot 250}{150}}\n\\]\nExcel では、下記のように計算できる。\n=SQRT(2 * 5000 * 250 / 150)\nPython では、次のようにeoq(K, d, h) 関数を定義し、最適発注量を計算できる。\n\ndef eoq(K, d, h):\n    \"\"\"\n    Calculate the Economic Order Quantity (EOQ).\n\n    Parameters:\n    K (float): Order cost\n    d (float): Demand rate\n    h (float): Holding cost\n\n    Returns:\n    float: Optimal order quantity Q*\n    \"\"\"\n    return np.sqrt(2 * K * d / h)\n\n\nif __name__ == \"__main__\":\n    K = 5000  # Order cost\n    d = 250  # Demand rate (units per month)\n    h = 150  # Holding cost (per unit per month)\n\n    Q_star = eoq(K, d, h)\n    T_star = Q_star / d\n    print(f\"Optimal Order Quantity (Q*): {Q_star:.2f}\")\n    print(f\"Optimal Cycle Time (T*): {T_star:.2f}\")\n\nOptimal Order Quantity (Q*): 129.10\nOptimal Cycle Time (T*): 0.52\n\n\nPCの場合は、注文量が整数である必要があるため、\\(g(129)\\) と \\(g(130)\\) を比較して最適発注量を決定する。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>経済的発注量</span>"
    ]
  },
  {
    "objectID": "inventory/eoq.html#リードタイム",
    "href": "inventory/eoq.html#リードタイム",
    "title": "2  経済的発注量",
    "section": "2.4 リードタイム",
    "text": "2.4 リードタイム\nEOQ モデルでは、リードタイムは0と仮定している。リードタイムが \\(L &gt; 0\\) の場合も、最適発注量 \\(Q^*\\) も変換せず、\\(L\\) 期間前に \\(Q^*\\) を発注すればよい。\nここでは、\\(r\\) を発注点（reorder point）とする。在庫量が \\(r\\) になったときに発注を行う。リードタイム \\(L\\) の間に需要が \\(dL\\) 個あるため、発注点は次のように表される。\n\\[\nr = dL\n\\]\n\n例 2.3 上の例で、リードタイムが一週間とし、一か月を4週間とすると、リードタイムは \\(L = 1/4\\) となる。したがって、発注点は次のように求められる。\n\\[\nr = dL = 250 \\times \\frac{1}{4} = 62.5\n\\]\nPCの在庫量が63台になったときに発注を行う。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>経済的発注量</span>"
    ]
  },
  {
    "objectID": "inventory/eoq.html#他のeoqモデル",
    "href": "inventory/eoq.html#他のeoqモデル",
    "title": "2  経済的発注量",
    "section": "2.5 他のEOQモデル",
    "text": "2.5 他のEOQモデル\n\nバックオーダーを考慮したEOQモデル\n数量割引（quantity discount）を考慮したEOQモデル\n\n総量割引（all-units discount）\n増分割引（incremental discount）",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>経済的発注量</span>"
    ]
  },
  {
    "objectID": "inventory/eoq.html#文献案内",
    "href": "inventory/eoq.html#文献案内",
    "title": "2  経済的発注量",
    "section": "2.6 文献案内",
    "text": "2.6 文献案内\nオペレーションズ・リサーチに関する教科書の多くは、EOQモデルを取り扱っている。モデルの分類から、「deterministic continuous-review inventory models」などの章で説明されていることが多い。\nリードタイムを考慮したEOQモデルについては、Snyder と Shen (2019) で説明されている。\n数量割引を考慮したEOQモデルについては、Snyder と Shen (2019) 、Camm ほか (2022) で説明されている。\nバックオーダーを考慮したEOQモデルについては、Snyder と Shen (2019) 、Camm ほか (2022) 、Hillier と Lieberman (2025) で説明されている。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>経済的発注量</span>"
    ]
  },
  {
    "objectID": "inventory/eoq.html#練習問題",
    "href": "inventory/eoq.html#練習問題",
    "title": "2  経済的発注量",
    "section": "2.7 練習問題",
    "text": "2.7 練習問題\n\n練習 2.1 ある会社は、毎月300個の需要がある商品を取り扱っている。一回の発注量は600個とし、サイクル期間 \\(T\\) を求めよ。\n\n\n練習 2.2 ある工場は、鋼材を毎日16トン消費し、年間250日稼働している。鋼材の購入単価は1トンあたり1100ドル、1回の発注にかかる固定費は5500ドル、保管費は鋼材1トンあたり年間は275ドルである。EOQモデルにより以下を求めよ。\n\n最適な発注量\nサイクル期間\n年間平均コスト",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>経済的発注量</span>"
    ]
  },
  {
    "objectID": "inventory/eoq.html#解答",
    "href": "inventory/eoq.html#解答",
    "title": "2  経済的発注量",
    "section": "2.8 解答",
    "text": "2.8 解答\n\n解答 2.1. 需要率は \\(d = 300\\)、発注量は \\(Q = 600\\) である。したがって、サイクル期間 \\(T\\) は以下のように求められる。\n\\[\nT = \\frac{Q}{d} = \\frac{600}{300} = 2 \\text{ヶ月}\n\\]\n\n\n解答 2.2. 需要率は \\(d = 4000\\)、発注費用は \\(K = 5500\\)、保管費用は \\(h = 275\\)、購入単価は \\(c = 1100\\) である。\n\n\nコード\nK = 5500  # Order cost\nd = 4000  # Demand rate (units per year)\nh = 275  # Holding cost (per unit per year)\nc = 1100  # Purchase cost (per unit)\n\nQ_star = np.sqrt(2 * K * d / h)\nT_star = Q_star / d\ng_avg = (K * d / Q_star) + (c * d) + (h * Q_star / 2)\nprint(f\"Optimal Order Quantity (Q*): {Q_star:.2f} tons\")\nprint(f\"Optimal Cycle Time (T*): {T_star:.2f} years\")\nprint(f\"Average Annual Cost (g(Q*)): {g_avg:.2f} dollars\")\n\n\nOptimal Order Quantity (Q*): 400.00 tons\nOptimal Cycle Time (T*): 0.10 years\nAverage Annual Cost (g(Q*)): 4510000.00 dollars\n\n\n\n\n\n\n\nCamm, Jeffrey, James Cochran, Michael Fry, Jeffrey Ohlmann, David Anderson, Dennis Sweeney, と Thomas Williams. 2022. An introduction to management science: Quantitative approaches to decision making. 16th 版. Florence, AL: South-Western College Publishing.\n\n\nHarris, Ford W. 1990. 「How many parts to make at once」. Oper. Res. 38 (6): 947–50.\n\n\nHillier, Frederick, と Gerald Lieberman. 2025. ISE introduction to operations research. 11th 版. Columbus, OH: McGraw-Hill Education.\n\n\nSnyder, Lawrence V, と Zuo-Jun Max Shen. 2019. Fundamentals of supply chain theory. 2nd 版. Nashville, TN: John Wiley & Sons.",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>経済的発注量</span>"
    ]
  },
  {
    "objectID": "inventory/wagner-whitin.html",
    "href": "inventory/wagner-whitin.html",
    "title": "3  Wagner-Whitin モデル",
    "section": "",
    "text": "記号\n意味\n\n\n\n\n\\(\\mathcal{T}\\)\n期間の集合、\\(\\mathcal{T} = \\{1, 2, \\ldots, T\\}\\)\n\n\n\\(K\\)\n1回あたりの発注費用\n\n\n\\(h\\)\n単位あたりの保管費用\n\n\n\\(d_t\\)\n第 \\(t\\) 期の需要量\n\n\n\\(q_t\\)\n第 \\(t\\) 期の発注量\n\n\n\\(x_t\\)\n第 \\(t\\) 期の在庫量\n\n\n\\(y_t\\)\n第 \\(t\\) 期に発注する場合は 1、しない場合は 0\n\n\n\\(M\\)\n非負の大きな数\n\n\n\nWagner-Whitin モデルは次のように定式化される。\n\\[\\begin{align}\n\\text{minimize} \\quad & \\sum_{t=1}^{T} (K y_t + h x_t) \\\\\n\\text{subject to} \\quad & x_t = x_{t-1} + q_t - d_t \\quad & \\forall t \\in \\mathcal{T} \\\\\n& q_t \\geq 0 \\quad & \\forall t \\in \\mathcal{T} \\\\\n& q_t \\leq M y_t \\quad & \\forall t \\in \\mathcal{T} \\\\\n& x_t \\geq 0 \\quad & \\forall t \\in \\mathcal{T} \\\\\n& y_t \\in \\{0, 1\\} \\quad & \\forall t \\in \\mathcal{T}\n\\end{align}\\]",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Wagner-Whitin モデル</span>"
    ]
  },
  {
    "objectID": "inventory/newsvendor.html",
    "href": "inventory/newsvendor.html",
    "title": "4  新聞売り子問題",
    "section": "",
    "text": "4.1 記号\nこれまで紹介した EOQ 在庫モデルは、需要が決定論的であると仮定していた。ここからは、需要が確率的であると仮定した在庫モデルを紹介する。\n新聞売り子問題（Newsvendor Problem）は，古典的な確率的在庫モデルの一つである。新聞は次の日には売れなくなるため，新聞売り子問題は最も単純な perishable 在庫モデルとして知られている。新聞に限らず，食品や花などの生鮮品の在庫管理にも応用される。\n新聞売り子が新聞を仕入れ，販売する問題を考える。新聞 1 部の欠品費用を \\(p\\)，保管費用を \\(h\\) とする。新聞売子問題において，\\(p\\) を在庫不足費用（underage cost），\\(h\\) を在庫超過費用（overage cost）とも呼ぶ。\\(p \\gt 0\\)，\\(h \\gt 0\\) とし，初期在庫は 0 とする。\n新聞の需要 \\(D\\) を確率変数とするとき，新聞売り子はどれだけの新聞を発注すればよいかという問題である。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>新聞売り子問題</span>"
    ]
  },
  {
    "objectID": "inventory/newsvendor.html#記号",
    "href": "inventory/newsvendor.html#記号",
    "title": "4  新聞売り子問題",
    "section": "",
    "text": "記号\n意味\n\n\n\n\n\\(h\\)\n1 個当たりの在庫超過費用\n\n\n\\(p\\)\n1 個当たりの在庫不足費用\n\n\n\\(D\\)\n需要（確率変数）\n\n\n\\(d\\)\n需要の観測値\n\n\n\\(f_D(d)\\)\n需要 \\(D\\) の確率密度関数\n\n\n\\(F_D(d)\\)\n需要 \\(D\\) の累積分布関数\n\n\n\\(S\\)\n発注量\n\n\n\\(g(S, d)\\)\n発注量 \\(S\\)，需要の観測値 \\(d\\) に対するコスト\n\n\n\\(g(S)\\)\n\\(g(S, d)\\) の期待値，\\(g(S) = \\mathbb{E}[g(S, D)]\\)",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>新聞売り子問題</span>"
    ]
  },
  {
    "objectID": "inventory/newsvendor.html#定式化",
    "href": "inventory/newsvendor.html#定式化",
    "title": "4  新聞売り子問題",
    "section": "4.2 定式化",
    "text": "4.2 定式化\n新聞売り子が \\(S\\) 部の新聞を仕入れ，需要 \\(D\\) が \\(d\\) であったとする。このとき，新聞売り子のコスト \\(g(S, d)\\) は以下のように表される。\n\\[\ng(S, d) = h (S - d)^+ + p (d - S)^+\n\\tag{4.1}\\]\n\n例 4.2 発注量 \\(S = 100\\)，需要 \\(D\\) の観測値 \\(d = 120\\)，在庫超過費用が \\(h = 10\\)，在庫不足費用が \\(p = 5\\) のとき，コスト \\(g(S, d)\\) は以下のように求められる。\n\\[\ng(100, 120) = 10 (100 - 120)^+ + 5 (120 - 100)^+ = 100\n\\]\n\n観測値 \\(d\\) が分かれば，コスト \\(g(S, d)\\) を計算できる。しかし，需要 \\(D\\) が確率変数であることを思い出そう。ここからは，需要 \\(D\\) が連続型確率変数であると仮定する。\n需要 \\(D\\) の確率密度関数を \\(f_D(d)\\)，累積分布関数を \\(F_D(d)\\) とする。発注量を \\(S\\) としたとき，需要 \\(D \\leq S\\) である確率は，累積分布関数 \\(F_D(S)\\) で与えられる。\n\\[\nP(D \\leq S) = F_D(S) = \\int_{0}^{S} f_D(d) dd\n\\tag{4.2}\\]\n\n例 4.3 需要 \\(D\\) が一様分布 \\(U(100,300)\\) に従うとき，確率密度関数 \\(f_D(250)\\) と累積分布関数 \\(F_D(250)\\) は以下のように表される。\n\nコード\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import uniform\n\n# 一様分布のパラメータ\na = 100\nb = 300\n# 需要の範囲\nd = np.linspace(a - 50, b + 50, 1000)\n# plot pdf with shaded area\nplt.figure(figsize=(4, 4))\nplt.plot(d, uniform.pdf(d, a, b - a))\nplt.fill_between(\n    d,\n    0,\n    uniform.pdf(d, a, b - a),\n    where=(d &lt;= 250),\n    color=\"skyblue\",\n    alpha=0.5,\n    label=\"F(250)\",\n)\nplt.xlabel(r\"$D$\")\nplt.ylabel(r\"$f_D(d)$\")\nplt.xlim(a - 50, b + 50)\nplt.ylim(0, 0.006)\nplt.show()\n\n# plot cdf\nplt.figure(figsize=(4, 4))\nplt.plot(d, uniform.cdf(d, a, b - a))\nplt.axvline(250, color=\"r\", linestyle=\"--\", label=\"d=250\")\nplt.xlabel(r\"$D$\")\nplt.ylabel(r\"$F_D(d)$\")\nplt.xlim(a - 50, b + 50)\nplt.ylim(0, 1.1)\nplt.show()\n\n\n\n\n\n\n\n確率密度関数 \\(f_D(d)\\)\n\n\n\n\n\n\n\n累積分布関数 \\(F_D(d)\\)\n\n\n\n\n\n需要 \\(D \\leq 250\\) である確率は，累積分布関数 \\(F_D(250)\\) で与えられる。\n\\[\nP(D \\leq 250) = F_D(250) = \\int_{100}^{250} f_D(d) dd = 0.75\n\\]\n需要 \\(D &gt; 250\\) である確率は \\(1 - F_D(250)\\) で与えられる。\n\\[\nP(D &gt; 250) = 1 - F_D(250) = 1 - \\int_{100}^{250} f_D(d) dd = 0.25\n\\]\n\n\\(D\\) が確率変数であるため，コストも確率変数となる。新聞売り子問題の目的は，コストの期待値を最小化することである。\nここで，コストの期待値を \\(g(S) = \\mathbb{E}[g(S, D)]\\) とする。\\(g(S, D)\\) は 式 4.1 で与えられるため，コストの期待値 \\(g(S)\\) は以下のように表される。\n\\[\\begin{align}\ng(S) &= \\mathbb{E}[g(S, D)] \\\\\n&= \\mathbb{E}[h (S - D)^+ + p (D - S)^+] \\\\\n&= \\mathbb{E}[h (S - D)^+] + \\mathbb{E}[p (D - S)^+] \\\\\n&= h \\mathbb{E}[(S - D)^+] + p \\mathbb{E}[(D - S)^+] \\\\\n\\end{align}\\]\nこの式により，コストの期待値 \\(g(S)\\) は，\\((S - D)^+\\) の期待値かける在庫超過費用 \\(h\\) と，\\((D - S)^+\\) の期待値かける在庫不足費用 \\(p\\) の和であることが分かる。\n\n\n\n\n\n\nノート期待値の線形性（Linearity of Expectation）\n\n\n\n\\(X\\) と \\(Y\\) を確率変数，\\(a\\) と \\(b\\) を定数とする。このとき，\n\\[\n\\mathbb{E}[X + Y] = \\mathbb{E}[X] + \\mathbb{E}[Y]\n\\]\n\\[\n\\mathbb{E}[aX + b] = a\\mathbb{E}[X] + b\n\\]\nが成り立つ。\n\n\n需要 \\(D\\) が連続型確率変数であるため，\\(\\mathbb{E}[(S - D)^+]\\) と \\(\\mathbb{E}[(D - S)^+]\\) は以下のように表される。 \\[\\begin{align}\n\\mathbb{E}[(S - D)^+]\n&= \\int_{0}^{\\infty} (S - d)^+ f_D(d) dd = \\int_{0}^{S} (S - d) f_D(d) dd \\\\\n\\mathbb{E}[(D - S)^+]\n&= \\int_{0}^{\\infty} (d - S)^+ f_D(d) dd = \\int_{S}^{\\infty} (d - S) f_D(d) dd\n\\end{align}\\]\n\n\n\n\n\n\nノート連続型確率変数の期待値\n\n\n\n\\(X\\) を連続型確率変数，\\(f_X(x)\\) を \\(X\\) の確率密度関数とする。このとき，\\(X\\) の期待値 \\(\\mathbb{E}[X]\\) は以下のように表される。\n\\[\n\\mathbb{E}[X] = \\int_{-\\infty}^{\\infty} x f_X(x) dx\n\\]\n\\(\\mathbb{E}[g(X)]\\) は以下のように表される。\n\\[\n\\mathbb{E}[g(X)] = \\int_{-\\infty}^{\\infty} g(x) f_X(x) dx\n\\]\n\n\nしたがって，コストの期待値 \\(g(S)\\) は以下のように表される。\n\\[\\begin{align}\ng(S) &= \\mathbb{E}[g(S, D)] \\\\\n&= h \\mathbb{E}[(S - D)^+] + p \\mathbb{E}[(D - S)^+] \\\\\n&= h \\int_{0}^{S} (S - d) f_D(d) dd + p \\int_{S}^{\\infty} (d - S) f_D(d) dd\n\\end{align}\\]\n\n例 4.4 在庫超過費用が \\(h = 10\\)，在庫不足費用が \\(p = 5\\) のとき，発注量 \\(S = 150\\) に対するコストの期待値 \\(g(150)\\) は以下のように求められる。\n\\[\ng(150) = 10 \\int_{0}^{150} (150 - d) f_D(d) dd + 5 \\int_{150}^{\\infty} (d - 150) f_D(d) dd\n\\]",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>新聞売り子問題</span>"
    ]
  },
  {
    "objectID": "inventory/newsvendor.html#最適化",
    "href": "inventory/newsvendor.html#最適化",
    "title": "4  新聞売り子問題",
    "section": "4.3 最適化",
    "text": "4.3 最適化\n以上の議論から，新聞売り子問題は，コストの期待値 \\(g(S)\\) を最小化する発注量 \\(S\\) を求める問題に帰着される。手順は以下の通りである。\n\n\\(g(S)\\) の1階微分を求める。\n\\(dg(S)/dS = 0\\) を解く。\n2階微分を求め，\\(g(S)\\) が凸関数であることを確認する。\n\n式 4.2 を用い，\\(g(S)\\) の1階微分は以下のように求める。\n\\[\\begin{align}\n\\frac{dg(S)}{dS} &= h \\int_{0}^{S} f_D(d) dd - p \\int_{S}^{\\infty} f_D(d) dd \\\\\n&= h F_D(S) - p (1 - F_D(S)) \\\\\n\\end{align}\\]\nよって，\\(dg(S)/dS = 0\\) から，\n\\[\\begin{align}\nh F_D(S) - p (1 - F_D(S)) &= 0 \\\\\nF_D(S) &= \\frac{p}{h + p}\n\\end{align}\\]\nになる。2 階微分は\n\\[\\begin{align}\n\\frac{d^2g(S)}{dS^2} &= h f_D(S) + p f_D(S) \\\\\n&= (h + p) f_D(S) &gt; 0\n\\end{align}\\]\nである。したがって，コスト関数 \\(g(S)\\) は凸関数であり，1 階微分が 0 になる点は最小値を与える。\n\n\n\n\n\n\nヒント\n\n\n\n\\(p &gt; 0\\)，\\(h &gt; 0\\)，\\(f_D(S) &gt; 0\\) より，\\((h + p) f_D(S) &gt; 0\\) が成り立つ。\n\n\nコスト関数 \\(g(S)\\) を最小化するための最適発注量 \\(S^*\\) は\n\\[\nS^* = F_D^{-1}\\left(\\frac{p}{h + p}\\right)\n\\]\nとなる。ここで，\\(F_D^{-1}\\) は需要 \\(D\\) の累積分布関数の逆関数である。\n\n\n\n\n\n\nノート逆関数（Inverse Function）\n\n\n\nある関数 \\(y = f(x)\\) に対し，次の条件を満たす関数 \\(x = f^{-1}(y)\\) を \\(f(x)\\) の逆関数と呼ぶ。\n\\[\nf(f^{-1}(y)) = y, \\quad f^{-1}(f(x)) = x\n\\]\n\n\n\n定理 4.1 新聞売り子問題における最適発注量 \\(S^*\\) は，\n\\[\nS^* = F_D^{-1}\\left(\\frac{p}{h + p}\\right)\n\\]\nで与えられる。\n\n\n4.3.1 正規分布の場合\n需要 \\(D\\) が正規分布 \\(N(\\mu, \\sigma^2)\\) に従うとき，新聞売り子問題の最適発注量 \\(S^*\\) は以下の式を満たす。\n\\[\nF_D(S^*) = \\Phi\\left(\\frac{S^* - \\mu}{\\sigma}\\right) = \\frac{p}{h + p}\n\\]\nここで，\n\\[\nz = \\Phi^{-1}\\left(\\frac{p}{h + p}\\right)\n\\]\nとおくと，\n\\[\nS^* = \\sigma z + \\mu\n\\]\nで与えられる。標準正規分布表を用いて \\(z\\) を調べることができる。\n\n\n\n\n\n\nノート標準正規分布（Standard Normal Distribution）\n\n\n\n平均 0，分散 1 の正規分布を標準正規分布（standard normal distribution）と呼ぶ。標準正規分布に従う確率変数を \\(Y\\) とすると，\\(Y \\sim N(0, 1)\\) と表される。標準正規分布の確率密度関数を \\(\\phi(z)\\)，累積分布関数を \\(\\Phi(z)\\) と表す。\n与えられた \\(X \\sim N(\\mu, \\sigma^2)\\) の累積分布関数 \\(F_X(x)\\) の値を求めるには，以下のように変換する。\n\\[\\begin{align}\nF_X(x) &= P(X \\leq x) \\\\\n&= P \\left( \\frac{X - \\mu}{\\sigma} \\leq \\frac{x - \\mu}{\\sigma} \\right) \\\\\\\\\n&= P\\left( Y \\leq \\frac{x - \\mu}{\\sigma} \\right) \\\\\\\\\n&= \\Phi \\left( \\frac{x - \\mu}{\\sigma} \\right)\n\\end{align}\\]\n与えられた \\(z\\) に対し，\\(\\Phi(z)\\) の値は標準正規分布表（standard normal table）を用いて調べることができる。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>新聞売り子問題</span>"
    ]
  },
  {
    "objectID": "inventory/newsvendor.html#臨界率",
    "href": "inventory/newsvendor.html#臨界率",
    "title": "4  新聞売り子問題",
    "section": "4.4 臨界率",
    "text": "4.4 臨界率\n以上の議論から，最適発注量 \\(S^*\\) は以下の式を満たす。\n\\[\nF_D(S) = P(D \\leq S) = \\frac{p}{h + p}\n\\]\nここで，\\(F_D(S) = P(D \\leq S)\\) は需要 \\(D\\) が発注量 \\(S\\) 以下である確率を表す。言い換えると，欠品が発生しない確率を表す。この確率のことはサービスレベル（service level）と呼ぶ。定理 4.1 は，サービスレベルを \\(p/(h+p)\\) に等しくする発注量 \\(S\\) が最適であることを示している。\nこの \\(p/(h+p)\\) は臨界率（critical ratio）と呼ばれる。\n\n注釈 4.1. \n\n在庫不足費用 \\(p\\) の増加に伴い，サービスレベル \\(p/(h+p)\\) は増加し，最適発注量 \\(S^* = F_D^{-1}(p/(h+p))\\) も増加する。\n在庫超過費用 \\(h\\) の増加に伴い，サービスレベル \\(p/(h+p)\\) は減少し，最適発注量 \\(S^* = F_D^{-1}(p/(h+p))\\) も減少する。\n直感的に，在庫不足費用が増加すると，欠品を避けるために発注量が増加し，サービスレベルも上昇する。一方，在庫超過費用が増加すると，過剰在庫を避けるために発注量が減少し，サービスレベルも低下する。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>新聞売り子問題</span>"
    ]
  },
  {
    "objectID": "inventory/newsvendor.html#例題",
    "href": "inventory/newsvendor.html#例題",
    "title": "4  新聞売り子問題",
    "section": "4.5 例題",
    "text": "4.5 例題\n\n例 4.5 需要 \\(D\\) が正規分布 \\(N(100, 25)\\) に従う新聞売り子問題を考える。在庫超過費用が \\(h = 10\\)，在庫不足費用が \\(p = 40\\) のとき，最適発注量 \\(S^*\\) を求める。\n定理 4.1 より，\\(S^*\\) は以下の式で与えられる。\n\\[\nS^* = F_D^{-1}\\left(\\frac{p}{h + p}\\right) = F_D^{-1}\\left(\\frac{40}{10 + 40}\\right) = F_D^{-1}\\left(0.8\\right)\n\\]\n言い換えると，\\(F_D(S^*) = 0.8\\) を満たす \\(S^*\\) を求めればよい。これを図で表すと，面積が 0.8 になるような \\(S^*\\) を求めることに相当する。\n\n\nコード\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import norm\n\n# 正規分布のパラメータ\nmu = 100\nsigma = 5\n\n# 需要の範囲\nd = np.linspace(mu - 4 * sigma, mu + 4 * sigma, 1000)\nS_star = norm.ppf(0.8, loc=mu, scale=sigma)\n\n# plot the normal distribution\nplt.plot(d, norm.pdf(d, mu, sigma))\nplt.fill_between(\n    d,\n    0,\n    norm.pdf(d, mu, sigma),\n    where=(d &lt;= S_star),\n    color=\"skyblue\",\n    alpha=0.5,\n    label=\"F(S*)\",\n)\nplt.xlabel(\"Demand\")\nplt.ylabel(\"Probability Density\")\nplt.axvline(mu, color=\"r\", linestyle=\"--\", label=\"mu\")\nplt.axvline(S_star, color=\"g\", linestyle=\"--\", label=\"S*\")\nplt.ylim(0, 0.09)\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n下では，Excel，Python，標準正規分布表を用いて \\(S^*\\) を求める方法を示す。\n\n4.5.1 標準正規分布表\n標準正規分布表 を調べると，\\(\\Phi(z) = 0.8\\) のとき，\\(z\\) は約 0.84 である。したがって，\\(S^*\\) は\n\\[\nS^* = z \\sigma + \\mu \\approx 0.84 \\times 5 + 100 = 104.2\n\\]\nとなる。\n\n\n4.5.2 Excel\nExcel では，NORM.INV(確率,平均,標準偏差) 関数を用いて \\(F_D^{-1}(0.8)\\) を求めることができる。\n=NORM.INV(0.8, 100, 5)\n\n\n4.5.3 Python\nPython では，SciPy ライブラリの ppf() 関数を用いて，逆関数を求めることができる。\n\nfrom scipy.stats import norm\n\n# 正規分布のパラメータ\nmu = 100\nsigma = 5\n\n# 在庫超過費用と在庫不足費用\nh = 10\np = 40\n\n# 臨界率\ncritical_ratio = p / (h + p)\n\n# 最適発注量\nS_star = norm.ppf(critical_ratio, loc=mu, scale=sigma)\nprint(f\"Optimal order quantity S*: {S_star:.2f}\")\n\nOptimal order quantity S*: 104.21",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>新聞売り子問題</span>"
    ]
  },
  {
    "objectID": "inventory/newsvendor.html#再定式化",
    "href": "inventory/newsvendor.html#再定式化",
    "title": "4  新聞売り子問題",
    "section": "4.6 再定式化",
    "text": "4.6 再定式化\n新聞 1 部の仕入れ価格を \\(c\\)，販売価格を \\(r\\)，残存価額を \\(v\\)，欠品費用を \\(p\\)，保管費用を \\(h\\) とする。ここで，以下の条件を満たすとする。\n\n\\(r &gt; c\\). 販売価格は仕入れ価格より高い。\n\\(r &gt; v\\). 販売価格は残存価値より高い。\n\n新聞売り子が \\(S\\) 部の新聞を仕入れ，需要 \\(D\\) が \\(d\\) であったとする。このとき，新聞売り子の利益 \\(\\pi(S, d)\\) は以下のように表される。\n\n4.6.1 コスト関数\n\\[\\begin{align}\n\\pi(S, d) & = r \\min\\{d, S\\} - cS + v \\max\\{0, S - d\\} \\\\\n& \\quad - h \\max\\{0, S - d\\} - p \\max\\{0, d - S\\}\n\\end{align}\\]\n第一項は販売利益，第二項は仕入れコスト，第三項は残存価値，第四項は保管コスト，第五項は欠品コストである。\n以下は，\\(\\max\\{0, x\\} = x^+\\) を用いて書き換えた形である。整理すると，利益は以下のように表される。\n\\[\n\\pi(S, d) = r \\min\\{d, S\\} - cS + (v - h) (S - d)^+ - p (d - S)^+\n\\]\n第一項を以下のように書き換えることができる。\n\\[\nr \\min\\{d, S\\} = r d - r (d - S)^+\n\\]\n\n\n\n\n\n\nノート\n\n\n\n\n\\(d &lt; S\\) の場合，\\(r \\min\\{d, S\\} = r d\\) となる。\n\\(d &gt;= S\\) の場合，\\(r \\min\\{d, S\\} = r d - r(d - S) = r S\\) となる。\n\n\n\nしたがって，利益は以下のように書き換えられる。\n\\[\n\\pi(S, d) = r d - cS + (v- h) (S - d)^+ - (p + r) (d - S)^+\n\\]\n利益の最大化は，コストの最小化に帰着される。したがって，コスト関数 \\(g(S, d) = -\\pi(S, d)\\) は以下のように表される。\n\\[\ng(S, d) = cS - rd + (h - v) (S - d)^+ + (p + r) (d - S)^+\n\\]\n\\(D\\) が確率変数であるため，コストの期待値 \\(g(S)\\) は以下のように表される。\n\\[\\begin{align}\ng(S) &= \\mathbb{E}[g(S, D)] \\\\\n&= \\int_{0}^{\\infty} g(S, d) f_D(d) dd \\\\\n&= cS - r\\mathbb{E}[D] + (h - v) \\mathbb{E}[(S - D)^+] + (p + r) \\mathbb{E}[(D - S)^+] \\\\\n&= c S - r \\mu + (h - v)  \\int_{0}^{\\infty}(S - d)^+ f_D(d) dd + (p + r) \\int_{0}^{\\infty} (d - S)^+ f_D(d) dd \\\\\n&= c S - r \\mu + (h - v) \\int_{0}^{S} (S - d) f_D(d) dd + (p + r) \\int_{S}^{\\infty} (d - S) f_D(d) dd\n\\end{align}\\]\n\n\n4.6.2 最適化\n\\(g(S)\\) の1階微分は以下のように求める。\n\\[\\begin{align}\n\\frac{dg(S)}{dS} &= c + (h - v) F_D(S) - (p + r) (1 - F_D(S)) \\\\\n\\end{align}\\]\nよって，\\(dg(S)/dS = 0\\) から，\n\\[\\begin{align}\nc + (h - v) F_D(S) - (p + r) (1 - F_D(S)) &= 0 \\\\\nF_D(S) &= \\frac{p + r - c}{h + p + r - v}\n\\end{align}\\]\nになる。2 階微分は\n\\[\\begin{align}\n\\frac{d^2g(S)}{dS^2} &= (h - v) f_D(S) + (p + r) f_D(S) \\\\\n&= (h - v + p + r) f_D(S)\n\\end{align}\\]\nである。したがって，コスト関数 \\(g(S)\\) は凸関数であり，1 階微分が 0 になる点は最小値を与える。\nコスト関数 \\(g(S)\\) を最小化するための最適発注量 \\(S^*\\) は\n\\[\nS^* = F_D^{-1}\\left(\\frac{p + r - c}{h + p + r - v}\\right)\n\\] となる。ここで，\\(F_D^{-1}\\) は需要 \\(D\\) の累積分布関数の逆関数である。\n新聞売り子問題において，より一般的に，在庫超過費用（overage cost）と 在庫不足費用（underage cost）を考慮する。\n\\[\nC_o = h + c - v, \\quad C_u = p + r - c\n\\]\n\n\n4.6.3 臨界率\n在庫超過費用 \\(C_o\\) は，在庫が余ったときのコストである。1 部の在庫超過に対し，保管コストと仕入れコストが発生するが，残存価額が得られないため，\\(C_o = h + c - v\\) となる。\n在庫不足費用 \\(C_u\\) は，在庫が不足したときのコストである。1 部の在庫不足に対し，欠品コスト \\(p\\) と失われた販売機会の利益 \\(r - c\\) が発生するため，\\(C_u = p + r - c\\) となる。\n従って，\n\\[\\begin{align*}\nS^* &= F_D^{-1}\\left(\\frac{p + r - c}{h + p + r - v}\\right)\\\\\n&= F_D^{-1}\\left(\\frac{C_u}{C_o + C_u}\\right)\n\\end{align*}\\]\nが得られる。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>新聞売り子問題</span>"
    ]
  },
  {
    "objectID": "inventory/newsvendor.html#初期在庫を考慮した新聞売り子問題",
    "href": "inventory/newsvendor.html#初期在庫を考慮した新聞売り子問題",
    "title": "4  新聞売り子問題",
    "section": "4.7 初期在庫を考慮した新聞売り子問題",
    "text": "4.7 初期在庫を考慮した新聞売り子問題\n新聞売り子の初期在庫を \\(I\\) とする。\\(I \\leq S^*\\)の場合，最適発注量は \\(S^* - I\\) となる。すなわち，在庫量を \\(S^*\\) にすればよい。\nまた，\\(g(S)\\) は凸関数であるため，\\(I &gt; S^*\\) の場合，何も発注しないことが最適である。\nしたがって，最適発注量は\n\\[\nQ =\n\\begin{cases}\nS^* - I, & \\text{if } I \\le S^*, \\\\[6pt]\n0, & \\text{if } I &gt; S^* .\n\\end{cases}\n\\]\nとなる。\nこのような発注方式を Base Stock Policy (BSP) と呼ぶ。BSP は，各期間の在庫量を観測し，在庫量が \\(S^*\\) に引き上げられるように発注する方式である。新聞売り子問題において，BSP は最適な方策であると知られている。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>新聞売り子問題</span>"
    ]
  },
  {
    "objectID": "inventory/newsvendor.html#文献案内",
    "href": "inventory/newsvendor.html#文献案内",
    "title": "4  新聞売り子問題",
    "section": "4.8 文献案内",
    "text": "4.8 文献案内\nArrow, Harris, と Marschak (1951) は，新聞売り子問題を初めて定式化した。\nScarf (1959) の論文では，\\((s, S)\\) 方策が発注費用を考慮した複数期間の新聞売り子問題において最適であることを示している。\n実際には，需要の分布が不明であることが多い。Huber ほか (2019) は，データ駆動新聞売り子問題（Data-Driven Newsvendor Problem）に関する研究が行われている。\nQin ほか (2011) は，新聞売り子問題に関する研究をレビューした。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>新聞売り子問題</span>"
    ]
  },
  {
    "objectID": "inventory/newsvendor.html#練習問題",
    "href": "inventory/newsvendor.html#練習問題",
    "title": "4  新聞売り子問題",
    "section": "4.9 練習問題",
    "text": "4.9 練習問題\n\n練習 4.1 ある弁当屋では，1 個 500 円で弁当を仕入れ，1 個 800 円で販売している。売れ残った弁当を廃棄する場合，1 個当たり 10 円の廃棄費用がかかる。 弁当の需要 \\(D\\) は，正規分布 \\(N(50, 8^2)\\) に従うとする。このとき，最適な弁当の発注量を求めよ。\n\n\n解答 4.1. 弁当 1 個当たりの在庫超過費用 \\(h\\)，在庫不足費用 \\(p\\) は以下のように求められる。 \\[\nh = 10 + 500 = 510, \\quad p = 800 - 500 = 300\n\\]\nしたがって，\\(S^*\\) は以下のように求められる。\n\\[\nS^* = F_D^{-1}\\left(\\frac{p}{h + p}\\right) = F_D^{-1}\\left(\\frac{300}{510 + 300}\\right) \\approx F_D^{-1}\\left(0.37\\right)\n\\]\n標準正規分布表を調べると，\\(\\Phi(z) = 0.37\\) のとき，\\(z\\) は約 -0.33 である。したがって，\\(S^*\\) は\n\\[\nS^* = -0.33 \\times \\sigma + \\mu = -0.33 \\times 8 + 50 \\approx 47.36\n\\]\nとなる。\nPython を用いて計算すると，以下のようになる。\n\n\nコード\nfrom scipy.stats import norm\n\n# 正規分布のパラメータ\nmu = 50\nsigma = 8\n# 在庫超過費用と在庫不足費用\nh = 510\np = 300\n# 臨界率\ncritical_ratio = p / (h + p)\n# 最適発注量\nS_star = norm.ppf(critical_ratio, loc=mu, scale=sigma)\nprint(f\"Optimal order quantity S*: {S_star:.4f}\")\n\n\nOptimal order quantity S*: 47.3530\n\n\n\n\n\n\n\nArrow, Kenneth J, Theodore Harris, と Jacob Marschak. 1951. 「Optimal Inventory Policy」. Econometrica 19 (3): 250.\n\n\nHuber, Jakob, Sebastian Müller, Moritz Fleischmann, と Heiner Stuckenschmidt. 2019. 「A data-driven newsvendor problem: From data to decision」. Eur. J. Oper. Res. 278 (3): 904–15.\n\n\nQin, Yan, Ruoxuan Wang, Asoo J Vakharia, Yuwen Chen, と Michelle M H Seref. 2011. 「The newsvendor problem: Review and directions for future research」. Eur. J. Oper. Res. 213 (2): 361–74.\n\n\nScarf, Herbert. 1959. 「The optimality of (S, s) policies in the dynamic inventory problem」.",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>新聞売り子問題</span>"
    ]
  },
  {
    "objectID": "inventory/safety.html",
    "href": "inventory/safety.html",
    "title": "5  安全在庫",
    "section": "",
    "text": "5.1 近似解法\n需要 \\(D\\) がある確率分布に従うと仮定する。リードタイムを \\(L\\) とし、既知の定数とする。発注費用を \\(K\\)、単位あたりの保管費用を \\(h\\) とする。在庫量が連続的に観測され、いつでも発注が可能であるとする連続観測の場合を考える。\n在庫管理には，\\((r, Q)\\) 方策が用いられるとする。在庫量が発注点 \\(r\\) 以下になったときに、発注量 \\(Q\\) を発注する。この場合、与えられたサービスレベルを満たすように、発注点 \\(r\\) と発注量 \\(Q\\) を決定することが目的である。\n単位期間あたりの需要を \\(D\\) とし、\\(D\\) は正規分布 \\(N(\\mu, \\sigma^2)\\) に従うと仮定する。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>安全在庫</span>"
    ]
  },
  {
    "objectID": "inventory/safety.html#近似解法",
    "href": "inventory/safety.html#近似解法",
    "title": "5  安全在庫",
    "section": "",
    "text": "ノート\n\n\n\nこの問題の定式化および厳密解法は、ここでは説明しない。Snyder と Shen (2019) の「Fundamentals of Supply Chain Theory」などの文献を参照されたい。 以下は \\((r, Q)\\) の近似解法を紹介する。\n\n\n\n\n5.1.1 発注量 \\(Q\\)\n\\(D\\) の平均需要 \\(\\mu\\) をEOQモデルの需要率とみなすと、発注量 \\(Q\\) は次のように求めることができる(Camm ほか 2022)。\n\\[\nQ = \\sqrt{\\frac{2K \\mu}{h}}\n\\]\n得られた発注量 \\(Q\\) は、最適解ではなく、近似解であることに注意されたい。\n\n例 5.2 単位期間あたりの需要 \\(D\\) が正規分布 \\(N(100, 20^2)\\) に従うと仮定する。発注費用 \\(K = 200\\)、単位あたりの保管費用 \\(h = 5\\) のとき、発注量 \\(Q\\) を求めよ。\n\\[\nQ = \\sqrt{\\frac{2K \\mu}{h}} = \\sqrt{\\frac{2 \\cdot 200 \\cdot 100}{5}} \\approx 89.44\n\\]\nPython では、以下のように計算できる。\n\n\nコード\nimport math\n\nK = 200\nh = 5\nmu = 100\nQ = math.sqrt((2 * K * mu) / h)\nprint(f\"order quantity: {Q:.2f}\")\n\n\norder quantity: 89.44\n\n\n\n\n\n5.1.2 発注点 \\(r\\)\nリードタイム期間中に発生する需要は \\(D_L \\sim N(\\mu_L, \\sigma_L^2)\\) とし、正規分布の再生性により、\n\\[\n\\mu_L = \\mu L, \\quad \\sigma_L^2 = \\sigma^2 L\n\\]\nになる。すなわち、リードタイム期間中の平均需要は \\(\\mu_L = \\mu L\\)、標準偏差は \\(\\sigma_L = \\sigma \\sqrt{L}\\) である。\n\n\n\n\n\n\nノート正規分布の再生性\n\n\n\n\\(X_1, X_2, \\ldots, X_n\\) が独立に同一の正規分布 \\(N(\\mu, \\sigma^2)\\) に従うならば、\\(Y = X_1 + X_2 + \\cdots + X_n\\) は正規分布 \\(N(n\\mu, n\\sigma^2)\\) に従う。\n\n\n\n例 5.3 単位期間あたりの需要 \\(D\\) が正規分布 \\(N(100, 20^2)\\) に従うと仮定する。リードタイム \\(L = 4\\) のとき、リードタイム期間中の平均需要 \\(\\mu_L\\) と標準偏差 \\(\\sigma_L\\) を求めよ。\n\\[\n\\mu_L = \\mu L = 100 \\cdot 4 = 400\n\\]\n\\[\n\\sigma_L = \\sigma \\sqrt{L} = 20 \\sqrt{4} = 40\n\\]\nこれにより，リードタイム期間中の需要 \\(D_L\\) は正規分布 \\(N(400, 40^2)\\) に従うことがわかる。\n\n発注点 \\(r\\) を決めるためには、サービスレベル（service level）を考える。ここでは、サービスレベルを、リードタイム期間中に需要を満たす確率と定義する。サービスレベルを \\(\\alpha\\) とし、\\(0 &lt; \\alpha &lt; 1\\) とする。\n与えられたサービスレベル \\(\\alpha\\) に対して、\\(D_L\\) が発注点 \\(r\\) 以下になる確率（欠品が発生しない確率、つまり、サービスレベル）が \\(\\alpha\\) になるように発注点 \\(r\\) を決定する。\n\\[\nP(D_L \\leq r) = \\alpha\n\\]\nもし、発注点 \\(r = \\mu_L\\) とすると、\\(P(D_L \\leq \\mu_L) = 0.5\\) となる。すなわち、50% の確率で欠品が発生することになる。\n\n\n\n\n\n\nノート\n\n\n\n\\[\nP(D_L \\leq \\mu_L) = P\\left(\\frac{D_L - \\mu_L}{\\sigma_L} \\leq 0\\right) = \\Phi(0) = 0.5\n\\]\n\n\nしたがって、サービスレベル \\(\\alpha &gt; 0.5\\) の場合、発注点 \\(r\\) は平均需要 \\(\\mu_L\\) より大きくなる必要がある。\\(r - \\mu_L\\) を安全在庫（safety stock）と呼び、\\(s\\) と表す。\n\\[\ns = r - \\mu_L\n\\]\nこの式を変形すると、発注点 \\(r\\) は次のように表される。\n\\[\nr = \\mu_L + s\n\\]\n従って、サービスレベル \\(P(D_L \\leq r) = \\alpha\\) は次のように表される。\n\\[\nP(D_L \\leq \\mu_L + s) = \\alpha\n\\]\n与えられたサービスレベル \\(\\alpha\\) に対して、安全在庫 \\(s\\) を求めることを考える。ここで、\\(s \\geq 0\\) とする。\n\\[\\begin{align}\nP(D_L - \\mu_L \\leq s) &= \\alpha \\\\\nP\\left(\\frac{D_L - \\mu_L}{\\sigma_L} \\leq \\frac{s}{\\sigma_L}\\right) &= \\alpha \\\\\n\\Phi\\left(\\frac{s}{\\sigma_L}\\right) &= \\alpha \\\\\n\\frac{s}{\\sigma_L} &= \\Phi^{-1}(\\alpha) \\\\\ns &= \\sigma_L \\Phi^{-1}(\\alpha) \\\\\ns &= \\sigma \\sqrt{L} \\Phi^{-1}(\\alpha)\n\\end{align}\\]\nここで、\\(\\Phi(\\cdot)\\) は標準正規分布の累積分布関数であり、\\(\\Phi^{-1}(\\alpha)\\) はその逆関数である。したがって、発注点 \\(r\\) は次のように表される。\n\\[\nr = \\mu_L + s = \\mu L + \\sigma \\sqrt{L} \\Phi^{-1}(\\alpha)\n\\]\n\\(\\Phi^{-1}(\\alpha)\\) は標準正規分布表、Excel、Python などを用いて求めることができる。\n\n例 5.4 単位期間あたりの需要 \\(D\\) が正規分布 \\(N(100, 20^2)\\) に従うと仮定する。リードタイム \\(L = 4\\)、発注点 \\(r = 500\\) のとき、安全在庫 \\(s\\) とサービスレベル \\(\\alpha\\) を求めよ。\nリードタイム期間中の平均需要は \\(\\mu_L = 400\\) である。したがって、安全在庫 \\(s\\) は次のように求められる。 \\[\ns = r - \\mu_L = 500 - 400 = 100\n\\]\nサービスレベル \\(\\alpha\\) は次のように求められる。\n\\[\n\\alpha = P(D_L \\leq r) = \\Phi\\left(\\frac{r - \\mu_L}{\\sigma_L}\\right) = \\Phi\\left(\\frac{100}{40}\\right) = \\Phi(2.5) \\approx 0.99379\n\\]\n発注点 \\(r = 500\\) のとき、安全在庫 \\(s\\) は100、サービスレベル \\(\\alpha\\) は約 99.379% である。\n\n\n例 5.5 リードタイム \\(L = 4\\)、平均需要 \\(\\mu = 100\\)、需要の標準偏差 \\(\\sigma = 20\\)、サービスレベル \\(\\alpha = 0.95\\) のとき、発注点 \\(r\\) と安全在庫 \\(s\\) を求める。\nリードタイム期間中の平均需要と標準偏差は次のように計算される。\n\\[\\begin{align}\n\\mu_L &= \\mu L = 100 \\cdot 4 = 400 \\\\\n\\sigma_L &= \\sigma \\sqrt{L} = 20 \\sqrt{4} = 40 \\\\\n\\end{align}\\]\n標準正規分布表から \\(\\Phi^{-1}(0.95) \\approx 1.64485\\) を得る。これを用いて安全在庫 \\(s\\) と発注点 \\(r\\) を求める。\n\\[\\begin{align}\ns &= \\sigma_L \\Phi^{-1}(0.95) \\approx 40 \\cdot 1.64485 \\approx 65.79 \\\\\nr &= \\mu_L + s \\approx 400 + 65.79 \\approx 465.79\n\\end{align}\\]\nしたがって、発注点 \\(r\\) は約465.79、必要な安全在庫 \\(s\\) は約65.79となる。\nPython では、以下のように計算できる。\n\n\nコード\nfrom scipy.stats import norm\n\nL = 4\nmu = 100\nsigma = 20\nalpha = 0.95\n\nmu_L = mu * L\nsigma_L = sigma * (L ** 0.5)\n\ns = sigma_L * norm.ppf(alpha)\nr = mu_L + s\n\nprint(f\"reorder point: {r:.2f},  safety stock: {s:.2f}\")\n\n\nreorder point: 465.79,  safety stock: 65.79",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>安全在庫</span>"
    ]
  },
  {
    "objectID": "inventory/safety.html#欠品費用を考慮する場合",
    "href": "inventory/safety.html#欠品費用を考慮する場合",
    "title": "5  安全在庫",
    "section": "5.2 欠品費用を考慮する場合*",
    "text": "5.2 欠品費用を考慮する場合*\nまた、欠品費用も考慮する場合、バックオーダーを考慮した EOQ モデルを用いて、発注量 \\(Q\\) は次のように求めることができる(Hillier と Lieberman 2025)。\n\\[\nQ = \\sqrt{\\frac{2K \\mu}{h}} \\sqrt{\\frac{p+h}{p}}\n\\]\n\\(p\\) は単位あたりの欠品費用である。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>安全在庫</span>"
    ]
  },
  {
    "objectID": "inventory/safety.html#文献案内",
    "href": "inventory/safety.html#文献案内",
    "title": "5  安全在庫",
    "section": "5.3 文献案内",
    "text": "5.3 文献案内",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>安全在庫</span>"
    ]
  },
  {
    "objectID": "inventory/safety.html#練習問題",
    "href": "inventory/safety.html#練習問題",
    "title": "5  安全在庫",
    "section": "5.4 練習問題",
    "text": "5.4 練習問題\n\n練習 5.1 ある会社は、A商品を販売している。\\((r, Q)\\) 方策に基づいて在庫管理を行っている。毎日の需要 \\(D\\) は正規分布 \\(N(150, 30^2)\\) に従う。商品を発注するための固定費用は \\(K = 300\\)、単位あたりの保管費用は \\(h = 4\\)，購入単価は \\(c = 20\\) である。リードタイムは \\(L = 4\\) 日である。この会社は，90% のサービスレベルを目標としている。このとき、発注量 \\(Q\\)、発注点 \\(r\\)、必要な安全在庫 \\(s\\) を求めよ。\n\n\n解答 5.1. 発注量 \\(Q\\) は次のように求められる。\n\\[\nQ = \\sqrt{\\frac{2K \\mu}{h}} = \\sqrt{\\frac{2 \\cdot 300 \\cdot 150}{4}} = 150\n\\]\nリードタイム期間中の平均需要と標準偏差は次のように計算される。\n\\[\n\\mu_L = \\mu L = 150 \\cdot 4 = 600\n\\]\n\\[\n\\sigma_L = \\sigma \\sqrt{L} = 30 \\sqrt{4} = 60\n\\]\n標準正規分布表から \\(\\Phi^{-1}(0.9) \\approx 1.28155\\) を得る。これを用いて安全在庫 \\(s\\) と発注点 \\(r\\) を求める。\n\\[\ns = \\sigma_L \\Phi^{-1}(0.9) \\approx 60 \\cdot 1.28155 \\approx 76.89\n\\]\n\\[\nr = \\mu_L + s \\approx 600 + 76.89 \\approx 676.89\n\\]\nしたがって、発注量 \\(Q\\) は150、発注点 \\(r\\) は約676.89、必要な安全在庫 \\(s\\) は約76.89となる。\n\n\nコード\nimport math\nfrom scipy.stats import norm\nK = 300\nh = 4\nmu = 150\nsigma = 30\nL = 4\nalpha = 0.9\nQ = math.sqrt((2 * K * mu) / h)\nmu_L = mu * L\nsigma_L = sigma * (L ** 0.5)\ns = sigma_L * norm.ppf(alpha)\nr = mu_L + s\nprint(f\"order quantity: {Q:.2f}, reorder point: {r:.2f},  safety stock: {s:.2f}\")\n\n\norder quantity: 150.00, reorder point: 676.89,  safety stock: 76.89\n\n\n\n\n\n\n\nCamm, Jeffrey, James Cochran, Michael Fry, Jeffrey Ohlmann, David Anderson, Dennis Sweeney, と Thomas Williams. 2022. An introduction to management science: Quantitative approaches to decision making. 16th 版. Florence, AL: South-Western College Publishing.\n\n\nHillier, Frederick, と Gerald Lieberman. 2025. ISE introduction to operations research. 11th 版. Columbus, OH: McGraw-Hill Education.\n\n\nSnyder, Lawrence V, と Zuo-Jun Max Shen. 2019. Fundamentals of supply chain theory. 2nd 版. Nashville, TN: John Wiley & Sons.",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>安全在庫</span>"
    ]
  },
  {
    "objectID": "mcda/ahp.html",
    "href": "mcda/ahp.html",
    "title": "6  階層分析法",
    "section": "",
    "text": "6.1 代替案\nAHPは，複数の代替案の中から一つの代替案を選択するための手法である．\n代替案の集合 \\(X = \\{x_1, x_2, \\ldots, x_n\\}\\) とする．代替案の重要度を\n\\[\n\\mathbf{w} = (w_1, w_2, \\ldots, w_n)^T\n\\]\nで表す．ここで，\\(w_i\\) は代替案 \\(x_i\\) の重要度を表し，\\(\\sum_{i=1}^n w_i = 1\\) を満たす．AHPでは，\\(\\mathbf{w}\\) を計算できるものとする．計算する方法は後述する．\n\\(w_i\\) が大きいほど，代替案 \\(x_i\\) が望ましいとする．\\(w_i &gt; w_j\\) ならば，代替案 \\(x_i\\) は代替案 \\(x_j\\) より望ましい．このとき，\\(x_i \\succ x_j\\) と表す．\nこのように，それぞれの代替案の重要度が与えられるならば，望ましい代替案の選択は容易である．しかし，実際には，代替案の重要度を直接決定することは難しい．",
    "crumbs": [
      "多基準意思決定分析",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>階層分析法</span>"
    ]
  },
  {
    "objectID": "mcda/ahp.html#代替案",
    "href": "mcda/ahp.html#代替案",
    "title": "6  階層分析法",
    "section": "",
    "text": "例 6.1 旅行先の代替案 \\[\nX = \\{\\text{北海道}, \\text{沖縄}, \\text{九州}\\}\n\\]\nとし，各代替案の重要度を \\(\\mathbf{w} = (0.3, 0.5, 0.2)^T\\) とするとき， \\[\n\\text{沖縄} \\succ \\text{北海道} \\succ \\text{九州}\n\\] である．",
    "crumbs": [
      "多基準意思決定分析",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>階層分析法</span>"
    ]
  },
  {
    "objectID": "mcda/ahp.html#記号",
    "href": "mcda/ahp.html#記号",
    "title": "6  階層分析法",
    "section": "6.2 記号",
    "text": "6.2 記号\n\n\n\n記号\n意味\n\n\n\n\n\\(\\mathbf{A}\\)\n一対比較行列\n\n\n\\(X\\)\n代替案の集合\n\n\n\\(x_i\\)\n代替案 \\(i\\)\n\n\n\\(a_{ij}\\)\n一対比較値\n\n\n\\(\\mathbf{w}\\)\n重要度ベクトル",
    "crumbs": [
      "多基準意思決定分析",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>階層分析法</span>"
    ]
  },
  {
    "objectID": "mcda/ahp.html#一対比較",
    "href": "mcda/ahp.html#一対比較",
    "title": "6  階層分析法",
    "section": "6.3 一対比較",
    "text": "6.3 一対比較\nすべての代替案を並べて比較することは難しい．そこで，AHPでは，2つの代替案を比較する一対比較 (pairwise comparison)を用いる．その理由として，\\(\\{x_1, x_2, \\ldots, x_n\\}\\) の中から最も望ましい代替案を選ぶことは難しいが，2つの代替案 \\(x_i\\) と \\(x_j\\) のどちらが望ましいかを決定することは比較的容易であることが挙げられる．\nAHPでは，\\(x_i\\) は \\(x_j\\) よりどれくらい望ましいかを一対比較値で表す．正式には，一対比較値 \\(a_{ij}\\) は \\(x_i\\) が \\(x_j\\) より \\(a_{ij}\\) 倍望ましいことを表す．\n例えば，\\(a_{ij} = 3\\) ならば，\\(x_i\\) は \\(x_j\\) より3倍望ましいことを表す．例 6.1 で，\\(a_{12} = 3\\) ならば，\\(x_1\\) （北海道）は \\(x_2\\) （沖縄）より3倍望ましいことを表す．\nSaatyは，一対比較値を以下の尺度で表すことを提案した．\nTable: The fundamental scale of absolute numbers (Saaty, 2008)\n\n\n\n\n\n\n\n\nImportance\nDefinition\nExplanation\n\n\n\n\n1\nEqual\nTwo activities contribute equally to the objective\n\n\n2\nWeak or slight\n-\n\n\n3\nModerate\nExperience and judgment slightly favor one activity over another\n\n\n4\nModerate plus\n-\n\n\n5\nStrong\nExperience and judgment strongly favor one activity over another\n\n\n6\nStrong plus\n-\n\n\n7\nVery strong\nAn activity is favored very strongly over another activity\n\n\n8\nVery, very strong\n-\n\n\n9\nExtreme\nThe evidence favoring one activity over another is of the highest possible order\n\n\n\nすべての代替案の組み合わせについて一対比較を行い，その結果を一対比較行列 (pairwise comparison matrix)にまとめる．一対比較行列は \\(\\mathbf{A} = [a_{ij}]_{n \\times n}\\) と定義され，以下のように表される。\n\\[\n\\mathbf{A} = \\begin{bmatrix}\na_{11} & a_{12} & \\cdots & a_{1n} \\\\\na_{21} & a_{22} & \\cdots & a_{2n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{n1} & a_{n2} & \\cdots & a_{nn} \\\\\n\\end{bmatrix}\n\\]\n理論的には，\n\\[\na_{ij} \\approx \\frac{w_i}{w_j} \\quad \\forall i, j\n\\]\nが想定されている．\n\n\n\n\n\n\nヒント\n\n\n\n意思決定者が一対比較を行うとき，\\(\\mathbf{w} = (w_1, w_2, \\ldots, w_n)^T\\) が知らないが，合理的な意思決定者ならば，\\(a_{ij} \\approx w_i/w_j\\) を満たすと考えられる．\n\n\n意思決定者が完全に合理的であるならば，\\(a_{ij} = w_i/w_j\\) を満たす． このとき，一対比較行列 \\(\\mathbf{A}\\) は以下のようになる．\n\\[\n\\mathbf{A} = \\begin{bmatrix}\nw_1/w_1 & w_1/w_2 & \\cdots & w_1/w_n \\\\\nw_2/w_1 & w_2/w_2 & \\cdots & w_2/w_n \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nw_n/w_1 & w_n/w_2 & \\cdots & w_n/w_n \\\\\n\\end{bmatrix}\n\\]\nこのとき，\\(\\mathbf{A}\\) は完全に整合性 (consistency) を持つと言う．\\(\\mathbf{A}\\) は，以下の性質が成り立つ．\n\n\\(a_{ii} = 1, \\forall i\\)\n\\(a_{ij} = 1/a_{ji}, \\forall i, j\\)\n\n例えば，\\(a_{12} = 3\\) ならば，\\(x_1\\) は \\(x_2\\) より3倍望ましい，かつ，\\(x_2\\) は \\(x_1\\) より \\(1/3\\) 倍望ましいことが分かる．\n\n\n\n\n\n\nヒント\n\n\n\n\\(a_{ij} = w_i/w_j\\) とするとき，この2つの性質は，以下のように導かれる．\n\\[\na_{ii} = \\frac{w_i}{w_i} = 1\n\\]\n\\[\na_{ij} = \\frac{w_i}{w_j} = \\frac{1}{\\frac{w_j}{w_i}} = \\frac{1}{a_{ji}}\n\\]\n\n\n\n例 6.2 旅行先の代替案 \\(X = \\{\\text{北海道}, \\text{沖縄}, \\text{九州}\\}\\) とし，以下の一対比較を行ったとする．\n\n\\(x_1\\) （北海道）は \\(x_2\\) （沖縄）より3倍望ましい\n\\(x_1\\) （北海道）は \\(x_3\\) （九州）より6倍望ましい\n\\(x_2\\) （沖縄）は \\(x_3\\) （九州）より2倍望ましい\n\nこのとき，一対比較行列 \\(\\mathbf{A}\\) は以下のようになる．\n\\[\n\\mathbf{A} = \\begin{bmatrix}\n1 & 3 & 6 \\\\\n1/3 & 1 & 2 \\\\\n1/6 & 1/2 & 1 \\\\\n\\end{bmatrix}\n\\]",
    "crumbs": [
      "多基準意思決定分析",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>階層分析法</span>"
    ]
  },
  {
    "objectID": "mcda/ahp.html#重要度ベクトル",
    "href": "mcda/ahp.html#重要度ベクトル",
    "title": "6  階層分析法",
    "section": "6.4 重要度ベクトル",
    "text": "6.4 重要度ベクトル\n一対比較行列 \\(\\mathbf{A}\\) が与えられたとき，重要度ベクトル \\(\\mathbf{w}\\) を計算する方法を説明する．\nまず，意思決定者が完全に合理的であるならば，\\(a_{ij} = w_i/w_j\\) を満たすため，\\(\\mathbf{A}\\) は\n\\[\n\\mathbf{A} = \\begin{bmatrix}\nw_1/w_1 & w_1/w_2 & \\cdots & w_1/w_n \\\\\nw_2/w_1 & w_2/w_2 & \\cdots & w_2/w_n \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nw_n/w_1 & w_n/w_2 & \\cdots & w_n/w_n \\\\\n\\end{bmatrix}\n\\]\nであるから，\\(\\mathbf{A}\\) の各列は比例している．このとき，重要度ベクトル \\(\\mathbf{w}\\) は，\\(\\mathbf{A}\\) の任意の列を正規化することで求められる．\n例 6.2 の一対比較行列 \\(\\mathbf{A}\\) を考える．\n\\[\n\\mathbf{A} = \\begin{bmatrix}\n1 & 3 & 6 \\\\\n1/3 & 1 & 2 \\\\\n1/6 & 1/2 & 1 \\\\\n\\end{bmatrix}\n\\]\nこのとき，\\(\\mathbf{A}\\) の第3列を正規化すると，重要度ベクトル \\(\\mathbf{w}\\) は以下のようになる． \\[\nw_1 = \\frac{6}{6 + 2 + 1} = \\frac{6}{9} \\approx 0.67\n\\] \\[\nw_2 = \\frac{2}{6 + 2 + 1} = \\frac{2}{9} \\approx 0.22\n\\] \\[\nw_3 = \\frac{1}{6 + 2 + 1} = \\frac{1}{9} \\approx 0.11\n\\]",
    "crumbs": [
      "多基準意思決定分析",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>階層分析法</span>"
    ]
  },
  {
    "objectID": "mcda/ahp.html#階層",
    "href": "mcda/ahp.html#階層",
    "title": "6  階層分析法",
    "section": "6.5 階層",
    "text": "6.5 階層\nAHPでは，複数の評価基準（criterion）を用いて代替案を評価することができる．例えば，旅行先の代替案を評価するとき，費用，距離，環境などの評価基準を用いることができる．\n\n\n\n\n\n\nヒント\n\n\n\n意思決定者が直接代替案を一対比較することは難しいが，評価基準を用いて代替案を評価することは比較的容易であると考えられる．\n\n\nAHPでは，評価基準を用いて代替案を評価するために，階層 (hierarchy) を用いる．階層は，以下の要素から構成される．\n\n目的 (goal)\n評価基準 (criteria)\n代替案 (alternatives)\n\n正式に，評価基準の集合を \\(C = \\{c_1, c_2, \\ldots, c_m\\}\\) とする．\n\n例 6.3 旅行先の代替案を \\(X = \\{\\text{北海道}, \\text{沖縄}, \\text{九州}\\}\\) とし，評価基準 \\(C = \\{\\text{費用}, \\text{食事}, \\text{環境}\\}\\) とする．このとき，以下のような階層を考える．\n\n\n\n\n\n\n\n\n\n\nGoal\n\n旅行先の選択\n\n\n\nC1\n\n費用\n\n\n\nGoal--C1\n\n\n\n\nC2\n\n食事\n\n\n\nGoal--C2\n\n\n\n\nC3\n\n環境\n\n\n\nGoal--C3\n\n\n\n\nA1\n\n北海道\n\n\n\nC1--A1\n\n\n\n\nA2\n\n沖縄\n\n\n\nC1--A2\n\n\n\n\nA3\n\n九州\n\n\n\nC1--A3\n\n\n\n\nC2--A1\n\n\n\n\nC2--A2\n\n\n\n\nC2--A3\n\n\n\n\nC3--A1\n\n\n\n\nC3--A2\n\n\n\n\nC3--A3\n\n\n\n\n\n\n\n\n\n\nこのような階層構造を用いることで，評価基準に基づいて代替案を評価することができる．各評価基準 \\(c_k\\) を用いて，代替案の一対比較行列 \\(\\mathbf{A}^{(k)}\\) を構築する．",
    "crumbs": [
      "多基準意思決定分析",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>階層分析法</span>"
    ]
  },
  {
    "objectID": "mcda/ahp.html#重要度ベクトルと整合性",
    "href": "mcda/ahp.html#重要度ベクトルと整合性",
    "title": "6  階層分析法",
    "section": "6.6 重要度ベクトルと整合性",
    "text": "6.6 重要度ベクトルと整合性\nしかし，人間の評価は必ずしも合理的でないため，一般には \\(a_{ij} = w_i/w_j\\) を満たさない．このとき，他の方法で一対比較行列 \\(\\mathbf{A}\\) から重要度ベクトル \\(\\mathbf{w}\\) を計算する必要がある．計算する方法として，主に幾何平均法 (geometric mean method) と固有ベクトル法 (eigenvector method) の2つがある．\n\n\n\n\n\n\nヒント\n\n\n\n幾何平均法と固有ベクトル法のどちらが優れているかについては議論がある．AHPの創始者であるSaatyは固有ベクトル法が優れていると主張しているが，幾何平均法が優れているとする出張する研究もある．\n他にもnormalized columns methodという方法もあるが，理論的根拠がないと言われている．\n\n\n\n6.6.1 幾何平均法\nCrawford と Williams (1985) は，幾何平均法を提案した．幾何平均法では，重要度ベクトル \\(\\mathbf{w}\\) の各要素 \\(w_k\\) を以下のように計算する．\n\\[\nw_k = \\frac{\\left(\\prod_{j=1}^n a_{kj}\\right)^{1/n}}{\\sum_{i=1}^n \\left(\\prod_{j=1}^n a_{ij}\\right)^{1/n}} \\quad \\forall k\n\\]\n\n\n\n\n\n\nヒント\n\n\n\n\\(\\mathbf{A}\\) の各行の幾何平均を計算し，正規化することで，重要度ベクトル \\(\\mathbf{w}\\) を求めている．\n\n\n例 6.2 の一対比較行列 \\(\\mathbf{A}\\) を考える．\n\\[\n\\mathbf{A} = \\begin{bmatrix}\n1 & 3 & 6 \\\\\n1/3 & 1 & 2 \\\\\n1/6 & 1/2 & 1 \\\\\n\\end{bmatrix}\n\\]\nこのとき，重要度ベクトル \\(\\mathbf{w}\\) は以下のようになる．これは，理論から計算した重要度ベクトルと一致する．\n\\[\nw_1 = \\frac{(1 \\times 3 \\times 6)^{1/3}}{(1 \\times 3 \\times 6)^{1/3} + (1/3 \\times 1 \\times 2)^{1/3} + (1/6 \\times 1/2 \\times 1)^{1/3}}  \\approx 0.67\n\\]\n\\[\nw_2 = \\frac{(1/3 \\times 1 \\times 2)^{1/3}}{(1 \\times 3 \\times 6)^{1/3} + (1/3 \\times 1 \\times 2)^{1/3} + (1/6 \\times 1/2 \\times 1)^{1/3}}  \\approx 0.22\n\\]\n\\[\nw_3 = \\frac{(1/6 \\times 1/2 \\times 1)^{1/3}}{(1 \\times 3 \\times 6)^{1/3} + (1/3 \\times 1 \\times 2)^{1/3} + (1/6 \\times 1/2 \\times 1)^{1/3}}  \\approx 0.11\n\\]\n一般に，一対比較行列 \\(\\mathbf{A}\\) が整合性を持つならば，幾何平均法で計算した重要度ベクトル \\(\\mathbf{w}\\) は理論から計算した重要度ベクトルと一致する．興味があれば，証明してみよう．\n\n\n6.6.2 固有ベクトル法*\n\n\n\n\n\n\nヒント\n\n\n\n固有ベクトル法は直感的に理解することが難しいため，講義では扱わない．\n\n\n一対比較行列 \\(\\mathbf{A}\\) が整合性を持つとき，\n\\[\n\\mathbf{A} \\mathbf{w} = \\begin{bmatrix}\nw_1/w_1 & w_1/w_2 & \\cdots & w_1/w_n \\\\\nw_2/w_1 & w_2/w_2 & \\cdots & w_2/w_n \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nw_n/w_1 & w_n/w_2 & \\cdots & w_n/w_n \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nw_1 \\\\\nw_2 \\\\\n\\vdots \\\\\nw_n \\\\\n\\end{bmatrix}\n= \\begin{bmatrix}\nn w_1 \\\\\nn w_2 \\\\\n\\vdots \\\\\nn w_n \\\\\n\\end{bmatrix}\n= n \\mathbf{w}\n\\]\nが成り立つ．式 \\(\\mathbf{A} \\mathbf{w} = n \\mathbf{w}\\) より，\\(\\mathbf{w}\\) は \\(\\mathbf{A}\\) の固有ベクトル，\\(n\\) は \\(\\mathbf{A}\\) の固有値である．\nSaatyは，最大固有値 \\(\\lambda_{max}\\) に対応する固有ベクトルを重要度ベクトルとして用いることを提案した．すなわち，重要度ベクトル \\(\\mathbf{w}\\) を求めるには，以下の式を解く．\n\\[\n\\mathbf{A} \\mathbf{w} = \\lambda_{max} \\mathbf{w}\n\\]\n例 6.2 の一対比較行列が与えられたとする．\n\\[\n\\mathbf{A} = \\begin{bmatrix}\n1 & 3 & 6 \\\\\n1/3 & 1 & 2 \\\\\n1/6 & 1/2 & 1 \\\\\n\\end{bmatrix}\n\\]\nこのとき，\\(\\mathbf{A}\\) の固有値は，\\(\\det(\\mathbf{A} - \\lambda \\mathbf{I}) = 0\\) を解くことで求められる．\n\\[\\begin{align*}\n\\det(\\mathbf{A} - \\lambda \\mathbf{I}) &= \\det\\begin{bmatrix}\n1 - \\lambda & 3 & 6 \\\\\n1/3 & 1 - \\lambda & 2 \\\\\n1/6 & 1/2 & 1 - \\lambda \\\\\n\\end{bmatrix} \\\\\n&= -\\lambda^3 + 3\\lambda^2 \\\\\n&= -\\lambda^2(\\lambda - 3)\n\\end{align*}\\]\n\\(\\lambda^2(\\lambda - 3) = 0\\) より，\\(\\lambda = 0, 3\\) が得られる．この例において，\\(\\mathbf{A}\\) の最大固有値は \\(\\lambda_{max} = 3\\) であり，それ以外の固有値は \\(\\lambda = 0\\) である．また，\\(\\mathbf{A}\\) は \\(3 \\times 3\\) 行列であるため，\\(\\lambda_{max} = n\\) が成り立つ．これは特別な例ではなく，一般に 命題 6.1 が成り立つ．\n\n命題 6.1 整合性のある \\(n \\times n\\) 行列 \\(\\mathbf{A}\\) の最大固有値は \\(\\lambda_{max} = n\\) であり，それ以外の固有値は \\(\\lambda = 0\\) である．\n\n行列 \\(\\mathbf{A}\\) は整合性を持たないとき，\\(\\lambda_{max} &gt; n\\) が成り立つ．命題 6.2 は \\(\\lambda_{max}\\) の性質を述べている．\n\n命題 6.2 (Saaty) \\(\\mathbf{A}\\) を一対行列とする．\\(\\mathbf{A}\\) が整合性を持つならば，\\(\\lambda_{max} = n\\) である．\\(\\mathbf{A}\\) が整合性を持たないならば，\\(\\lambda_{max} &gt; n\\) である．\n\n\n\n\n\n\n\nノート固有値と固有ベクトル（Eigenvalues and Eigenvectors）\n\n\n\n\\(n \\times n\\) 行列 \\(\\mathbf{A}\\) に対し，ベクトル \\(\\mathbf{x} \\neq \\mathbf{0}\\) とスカラー \\(\\lambda\\) が存在して， \\[\n\\mathbf{A} \\mathbf{x} = \\lambda \\mathbf{x}\n\\] が成り立つとき，\\(\\mathbf{x}\\) を \\(\\mathbf{A}\\) の固有ベクトル (eigenvector)，\\(\\lambda\\) を \\(\\mathbf{A}\\) の固有値 (eigenvalue) と呼ぶ．\n例えば，次のような \\(\\mathbf{A}, \\mathbf{x}, \\lambda\\) を考える． \\[\n\\mathbf{A} = \\begin{bmatrix}\n1 & 2 \\\\\n1/2 & 1 \\\\\n\\end{bmatrix}, \\quad\n\\mathbf{x} = \\begin{bmatrix}\n2 \\\\\n1 \\\\\n\\end{bmatrix}, \\quad\n\\lambda = 2\n\\]\nこのとき，\n\\[\n\\begin{bmatrix}\n1 & 2 \\\\\n1/2 & 1 \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n2 \\\\\n1 \\\\\n\\end{bmatrix}\n= \\begin{bmatrix}\n4 \\\\\n2 \\\\\n\\end{bmatrix}\n= 2 \\begin{bmatrix}\n2 \\\\\n1 \\\\\n\\end{bmatrix}\n\\]\nが成り立つため，\\(\\mathbf{x}\\) は \\(\\mathbf{A}\\) の固有ベクトル，\\(\\lambda\\) は \\(\\mathbf{A}\\) の固有値である．\n\\(\\mathbf{A} \\mathbf{x} = \\lambda \\mathbf{x}\\) は単位行列 \\(\\mathbf{I}\\) を用いて \\((\\mathbf{A} - \\lambda \\mathbf{I}) \\mathbf{x} = \\mathbf{0}\\) と書ける．このとき，\\(\\mathbf{x} \\neq \\mathbf{0}\\) であるため，\\(\\det(\\mathbf{A} - \\lambda \\mathbf{I}) = 0\\) が成り立つ．\n例えば，次のような行列 \\(\\mathbf{A}\\) を考える． \\[\n\\mathbf{A} = \\begin{bmatrix}\n1 & 2 \\\\\n1/2 & 1 \\\\\n\\end{bmatrix}\n\\]\nこのとき，\\(\\det(\\mathbf{A} - \\lambda \\mathbf{I})\\) は以下のようになる．\n\\[\\begin{align*}\n\\det(\\mathbf{A} - \\lambda \\mathbf{I}) &= \\det\\begin{bmatrix}\n1 - \\lambda & 2 \\\\\n1/2 & 1 - \\lambda \\\\\n\\end{bmatrix} \\\\\n&= (1 - \\lambda)^2 - 1 \\\\\n&= \\lambda^2 - 2\\lambda \\\\\n&= \\lambda(\\lambda - 2)\n\\end{align*}\\]\n\\(\\lambda(\\lambda - 2) = 0\\) より，\\(\\lambda = 0, 2\\) が得られる．\n\n\n\n\n6.6.3 GCI\n計算された重要度ベクトル \\(\\mathbf{w}\\) が一対比較行列 \\(\\mathbf{A}\\) とどれくらい整合しているかを評価する指標として，Aguarón が提案した平均幾何整合度 (geometric consistency index, GCI) がある．\n一対比較値 \\(a_{ij}\\) と重要度ベクトル \\(\\mathbf{w}\\) から，以下のように \\(e_{ij}\\) を定義する．\n\\[\ne_{ij} = a_{ij} \\frac{w_j}{w_i}\n\\]\n\\(a_{ij} = w_i/w_j\\) を満たすならば，\\(e_{ij} = 1\\) である．\nGCIは以下のように定義される．\n\\[\nGCI = \\frac{2}{(n-1)(n-2)} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\left(\\ln e_{ij}\\right)^2\n\\]",
    "crumbs": [
      "多基準意思決定分析",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>階層分析法</span>"
    ]
  },
  {
    "objectID": "mcda/ahp.html#文献案内",
    "href": "mcda/ahp.html#文献案内",
    "title": "6  階層分析法",
    "section": "6.7 文献案内",
    "text": "6.7 文献案内\nBrunelli (2015) はAHPを丁寧に解説した書籍である．",
    "crumbs": [
      "多基準意思決定分析",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>階層分析法</span>"
    ]
  },
  {
    "objectID": "mcda/ahp.html#用語",
    "href": "mcda/ahp.html#用語",
    "title": "6  階層分析法",
    "section": "6.8 用語",
    "text": "6.8 用語\n\n\n\nEnglish\nJapanese\n\n\n\n\nmulti-criteria decision making (MCDM)\n多基準意思決定\n\n\nAnalytic Hierarchy Process (AHP)\n階層分析法\n\n\nConsistency index\n整合度\n\n\npairwise comparison matrix\n一対比較行列\n\n\nalternative\n代替案\n\n\ncriterion\n評価基準\n\n\npriority vector\n重要度ベクトル\n\n\n\n\n\n\n\nBrunelli, Matteo. 2015. Introduction to the Analytic Hierarchy Process. 2015th 版. SpringerBriefs in Operations Research. Cham: Springer International Publishing.\n\n\nCrawford, Gordon, と Cindy Williams. 1985. 「A note on the analysis of subjective judgment matrices」. Journal of Mathematical Psychology, Some thoughts about the mathematics of the analytic hierarchy process, 29 (4): 387–405.",
    "crumbs": [
      "多基準意思決定分析",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>階層分析法</span>"
    ]
  },
  {
    "objectID": "network/graph.html",
    "href": "network/graph.html",
    "title": "7  グラフ理論",
    "section": "",
    "text": "7.1 無向グラフ\nグラフ（graph）は、点（vertex）の集合\\(V\\)と辺（edge）の集合\\(E\\)から構成され、\\(G=(V,E)\\)で表される。\nグラフは、有向グラフ（directed graph）と無向グラフ（undirected graph）に分けられる。\n無向グラフは、辺の方向を持たないグラフである。辺は、2つの点の集合として表される。\nグラフ \\(G = (V, E)\\) において、\\(e = \\{v, u\\} \\in E\\) を満たすとき、点 \\(v\\) と \\(u\\) は隣接（adjacent）しているといい、\\(e\\) は \\(v\\) と \\(u\\) を接続（incident）しているという。\n点 \\(v\\) に接続している辺の数を、\\(v\\) の次数（degree）という。例 7.1 の場合、\\(v_1\\) の次数は 3、\\(v_2\\) の次数は 2 である。",
    "crumbs": [
      "ネットワーク最適化",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>グラフ理論</span>"
    ]
  },
  {
    "objectID": "network/graph.html#無向グラフ",
    "href": "network/graph.html#無向グラフ",
    "title": "7  グラフ理論",
    "section": "",
    "text": "例 7.1 (無向グラフの例) グラフ\n\\[\nG = ({v_1, v_2, v_3, v_4}, \\{\\{v_1,v_2\\},\\{v_2,v_3\\},\\{v_3,v_4\\},\\{v_4,v_1\\},\\{v_1,v_3\\}\\})\n\\]\nは、点の集合\\(V=\\{v_1,v_2,v_3,v_4\\}\\)と辺の集合\\(E=\\{\\{v_1,v_2\\},\\{v_2,v_3\\},\\{v_3,v_4\\},\\{v_4,v_1\\},\\{v_1,v_3\\}\\}\\)からなる。\n\n\nコード\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# グラフの作成（頂点を番号で定義）\nG = nx.Graph()\nG.add_edges_from([(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)])\n\n# 頂点ラベルを LaTeX 形式に変換\nlabels = {i: rf\"$v_{i}$\" for i in G.nodes()}\n\n# レイアウト（円形）\npos = nx.circular_layout(G)\n\n# ラベルの位置を少し外側へ移動\nlabel_pos = {}\nfor k, (x, y) in pos.items():\n    r = np.sqrt(x**2 + y**2)  # 原点からの距離\n    scale = 1.15  # 外側に押し出す係数（調整可）\n    label_pos[k] = (x / r * scale, y / r * scale)\n\nplt.figure(figsize=(4, 4))\n# ノード描画\nnx.draw_networkx_nodes(G, pos, node_color=\"black\", node_size=120, edgecolors=\"black\")\n# エッジ描画\nnx.draw_networkx_edges(G, pos, edge_color=\"black\", width=1.2)\n# 外側にラベル描画\nnx.draw_networkx_labels(G, label_pos, labels, font_size=12, font_weight=\"regular\")\nplt.axis(\"off\")\nplt.show()",
    "crumbs": [
      "ネットワーク最適化",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>グラフ理論</span>"
    ]
  },
  {
    "objectID": "network/graph.html#有向グラフ",
    "href": "network/graph.html#有向グラフ",
    "title": "7  グラフ理論",
    "section": "7.2 有向グラフ",
    "text": "7.2 有向グラフ\n有向グラフは、辺に方向があるグラフである。辺は、2つの点の順序対として表される。\n\n例 7.2 (有向グラフの例) グラフ\n\\[\nG = ({v_1, v_2, v_3, v_4}, \\{(v_1,v_2),(v_2,v_3),(v_3,v_4),(v_4,v_1),(v_1,v_3)\\})\n\\]\nは、点の集合\\(V=\\{v_1,v_2,v_3,v_4\\}\\)と辺の集合\\(E=\\{(v_1,v_2),(v_2,v_3),(v_3,v_4),(v_4,v_1),(v_1,v_3)\\}\\)からなる。\n\n\nコード\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# グラフの作成（頂点を番号で定義）\nG = nx.DiGraph()\nG.add_edges_from([(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)])\n\n# 頂点ラベルを LaTeX 形式に変換\nlabels = {i: rf\"$v_{i}$\" for i in G.nodes()}\n\n# レイアウト（円形）\npos = nx.circular_layout(G)\n\n# ラベルの位置を少し外側へ移動\nlabel_pos = {}\nfor k, (x, y) in pos.items():\n    r = np.sqrt(x**2 + y**2)  # 原点からの距離\n    scale = 1.15  # 外側に押し出す係数（調整可）\n    label_pos[k] = (x / r * scale, y / r * scale)\n\nplt.figure(figsize=(4, 4))\n\n# ノード描画\nnx.draw_networkx_nodes(G, pos, node_color=\"black\", node_size=120, edgecolors=\"black\")\n\n# エッジ描画\nnx.draw_networkx_edges(G, pos, edge_color=\"black\", width=1.2, arrowsize=15)\n\n# 外側にラベル描画\nnx.draw_networkx_labels(G, label_pos, labels, font_size=12, font_weight=\"regular\")\n\nplt.axis(\"off\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\nグラフ \\(G = (V, E)\\) において、点 \\(v\\) から出る辺の数を出次数（outdegree）といい、点 \\(v\\) に入る辺の数を入次数（indegree）という。例 7.2 の場合、\\(v_1\\) の出次数は 2、入次数は 1 である。",
    "crumbs": [
      "ネットワーク最適化",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>グラフ理論</span>"
    ]
  },
  {
    "objectID": "network/graph.html#パス",
    "href": "network/graph.html#パス",
    "title": "7  グラフ理論",
    "section": "7.3 パス",
    "text": "7.3 パス\n\\(G = (V, E)\\) において、パス（path）\\(P\\) とは、点の組\n\\[\nP = (v_{i_1}, v_{i_2}, \\ldots, v_{i_k})\n\\]\nであって、各 \\(j = 1, 2, \\ldots, k-1\\) に対して \\((v_{i_j}, v_{i_{j+1}}) \\in E\\) を満たすものをいう。パスの長さ（length）は、パスに含まれる辺の数である。",
    "crumbs": [
      "ネットワーク最適化",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>グラフ理論</span>"
    ]
  },
  {
    "objectID": "network/shortest-path.html",
    "href": "network/shortest-path.html",
    "title": "8  最短路問題",
    "section": "",
    "text": "有向グラフ \\(G = (V, E)\\) を考える。各辺 \\((v, u) \\in E\\) に非負の重み \\(w(v, u)\\) が与えられているとする。このとき、点 \\(s \\in V\\) から点 \\(t \\in V\\) への最短路（shortest path）とは、\\(s\\) から \\(t\\) へのパスのうち、重みの和が最小となるパスである。 最短路問題とは、\\(s\\) から \\(t\\) への最短路を求める問題である。\n\n例 8.1 次の図は、最短路問題の例を示している。\n\n\nコード\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport numpy as np\n\n# グラフの作成（頂点を番号で定義）\nG = nx.DiGraph()\nedges = [\n    (\"s\", \"v1\", 5),\n    (\"s\", \"v2\", 3),\n    (\"v1\", \"v3\", 17),\n    (\"v2\", \"v3\", 1),\n    (\"v2\", \"v4\", 3),\n    (\"v3\", \"t\", 4),\n    (\"v4\", \"t\", 2),\n]\nG.add_weighted_edges_from(edges)\n\nlabels = {\n    node: (rf\"$v_{node[1:]}$\" if node.startswith(\"v\") else rf\"${node}$\")\n    for node in G.nodes()\n}\n\nfor layer, nodes in enumerate(nx.topological_generations(G)):\n    for node in nodes:\n        G.nodes[node][\"layer\"] = layer\n\npos = nx.multipartite_layout(G, subset_key=\"layer\")\n\nlabel_pos = {}\nfor k, (x, y) in pos.items():\n    r = np.sqrt(x**2 + y**2) if np.sqrt(x**2 + y**2) &gt; 0 else 1\n    scale = 1.1\n    label_pos[k] = (x * scale, y * scale)\n\n# Plotting\nnx.draw_networkx(\n    G,\n    pos=pos,\n    with_labels=False,\n    node_color=\"white\",\n    node_size=50,\n    edgecolors=\"black\",\n)\nnx.draw_networkx_labels(G, label_pos, labels, font_size=12)\nnx.draw_networkx_edge_labels(\n    G,\n    pos,\n    edge_labels={(u, v): d[\"weight\"] for u, v, d in G.edges(data=True)},\n    font_color=\"black\",\n    font_size=12,\n)\nplt.axis(\"off\")\nplt.show()",
    "crumbs": [
      "ネットワーク最適化",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>最短路問題</span>"
    ]
  },
  {
    "objectID": "network/pert.html",
    "href": "network/pert.html",
    "title": "9  PERT/CPM",
    "section": "",
    "text": "9.1 プロジェクト\nプロジェクトは、多くの作業からなる。プロジェクトを完遂できるように、作業のスケジュールを作成する必要がある。その方法として、PERT（Program Evaluation and Review Technique）とCPM（Critical Path Method）がある。現在では、PERTとCPMが統合され、PERT/CPMとして知られている(Camm ほか 2022; Hillier と Lieberman 2025)。\nここで、ある作業の開始前に完了しなければならない作業を先行作業（Immediate Predecessor）と呼ぶ。また、ある作業の完了後に開始できる作業を後続作業（Immediate Successor）と呼ぶ。\nまとめると、プロジェクトは、次の要素で構成される。",
    "crumbs": [
      "ネットワーク最適化",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>PERT/CPM</span>"
    ]
  },
  {
    "objectID": "network/pert.html#プロジェクト",
    "href": "network/pert.html#プロジェクト",
    "title": "9  PERT/CPM",
    "section": "",
    "text": "作業：プロジェクトを構成する仕事。活動、アクティビティとも呼ばれる。\n先行関係：それぞれの作業の先行作業を定義する関係。\n作業時間：各作業に必要な時間。\n\n\n例 9.1 学生の田中さんと佐藤さんが協力し、ある授業のレポートを作成することになった。このレポートを作成するためには、下の表に示すように、いくつかの作業を行う必要がある。\n\n\n\n作業\n作業内容\n先行作業\n時間（日）\n\n\n\n\nA\n課題の理解\n-\n2\n\n\nB\nデータ収集\nA\n3\n\n\nC\nデータ分析\nB\n4\n\n\nD\n文献調査\nA\n2\n\n\nE\nレポート作成\nC, D\n5",
    "crumbs": [
      "ネットワーク最適化",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>PERT/CPM</span>"
    ]
  },
  {
    "objectID": "network/pert.html#プロジェクトネットワーク",
    "href": "network/pert.html#プロジェクトネットワーク",
    "title": "9  PERT/CPM",
    "section": "9.2 プロジェクト・ネットワーク",
    "text": "9.2 プロジェクト・ネットワーク\nプロジェクトをネットワークで表現したものをプロジェクト・ネットワーク（Project Network）と呼ぶ。プロジェクト・ネットワークには、AOA（Activity on Arrow）や AON（Activity on Node）という 2 種類の表現方法がある。\nAOA では、作業を辺で表現し、先行関係を点で表現する。AON では、作業を点で表現し、先行関係を辺で表現する。AON のほうが理解と作成が容易で、実務でも AON がよく使われる(Camm ほか 2022; Hillier と Lieberman 2025; Eiselt と Sandblom 2022)。これは以降、AON に基づいて説明する。\nプロジェクト・ネットワークは \\(G = (V, E)\\) という有向グラフで表される。ここで、\\(V\\) は始点 \\(s\\)、終点 \\(t\\) と各作業を表す点の集合であり、\\(E\\) は先行関係を表す辺の集合である。辺 \\((v, u) \\in E\\) では、\\(v\\) が \\(u\\) の先行作業であることを意味する。\n辺 \\((s, v) \\in E\\) は、作業 \\(v\\) が先行作業を持たないことを意味し、辺 \\((v, t) \\in E\\) は、作業 \\(v\\) が後続作業を持たないことを意味する。作業 \\(v\\) の先行作業の集合を \\(\\mathcal{P}(v)\\) と表す。作業 \\(v\\) の後続作業の集合を \\(\\mathcal{S}(v)\\) と表す。\n作業点 \\(v \\in V\\) には、作業時間 \\(\\tau(v)\\) が与えられている。始点 \\(s\\) と終点 \\(t\\) の作業時間は \\(\\tau(s) = \\tau(t) = 0\\) とする。\n例 9.1 のプロジェクト・ネットワークは次の図のようになる。\n\n\nコード\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport numpy as np\n\n# グラフの作成（頂点を番号で定義）\nG = nx.DiGraph()\nedges = [\n    (\"s\", \"A\"),\n    (\"A\", \"B\"),\n    (\"A\", \"D\"),\n    (\"B\", \"C\"),\n    (\"C\", \"E\"),\n    (\"D\", \"E\"),\n    (\"E\", \"t\"),\n]\nG.add_edges_from(edges)\n\nfor layer, nodes in enumerate(nx.topological_generations(G)):\n    for node in nodes:\n        G.nodes[node][\"layer\"] = layer\n\npos = nx.multipartite_layout(G, subset_key=\"layer\")\n\nlabel_pos = {}\nfor k, (x, y) in pos.items():\n    r = np.sqrt(x**2 + y**2) if np.sqrt(x**2 + y**2) &gt; 0 else 1\n    scale = 1.12\n    label_pos[k] = (x * scale, y * scale)\n\n# Plotting\nnx.draw_networkx(\n    G,\n    pos=pos,\n    with_labels=True,\n    node_color=\"white\",\n    node_size=500,\n    edgecolors=\"black\",\n)\nplt.axis(\"off\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n例 9.2 以下の作業リストに基づいて、プロジェクト・ネットワークを作成せよ。\n\n\n\n作業\n先行作業\n時間（日）\n\n\n\n\nA\n-\n2\n\n\nB\n-\n3\n\n\nC\nA\n4\n\n\nD\nA\n2\n\n\nE\nB\n5\n\n\nF\nC, D, E\n9\n\n\nG\nE\n2\n\n\n\n\n\nコード\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport numpy as np\n\n# グラフの作成（頂点を番号で定義）\nG = nx.DiGraph()\nedges = [\n    (\"s\", \"A\"),\n    (\"s\", \"B\"),\n    (\"A\", \"C\"),\n    (\"A\", \"D\"),\n    (\"C\", \"F\"),\n    (\"D\", \"F\"),\n    (\"B\", \"E\"),\n    (\"E\", \"G\"),\n    (\"E\", \"F\"),\n    (\"G\", \"t\"),\n    (\"F\", \"t\"),\n]\nG.add_edges_from(edges)\n\nfor layer, nodes in enumerate(nx.topological_generations(G)):\n    for node in nodes:\n        G.nodes[node][\"layer\"] = layer\n\npos = nx.multipartite_layout(G, subset_key=\"layer\")\n\nlabel_pos = {}\nfor k, (x, y) in pos.items():\n    r = np.sqrt(x**2 + y**2) if np.sqrt(x**2 + y**2) &gt; 0 else 1\n    scale = 1.12\n    label_pos[k] = (x * scale, y * scale)\n\n# Plotting\nnx.draw_networkx(\n    G,\n    pos=pos,\n    with_labels=True,\n    node_color=\"white\",\n    node_size=500,\n    edgecolors=\"black\",\n)\nplt.axis(\"off\")\nplt.show()",
    "crumbs": [
      "ネットワーク最適化",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>PERT/CPM</span>"
    ]
  },
  {
    "objectID": "network/pert.html#sec-critical-path",
    "href": "network/pert.html#sec-critical-path",
    "title": "9  PERT/CPM",
    "section": "9.3 クリティカルパス",
    "text": "9.3 クリティカルパス\nプロジェクト・ネットワークにおいて、始点 \\(s\\) から終点 \\(t\\) までの経路をパスと呼ぶ。パスの長さは、そのパス上の作業時間の合計である。パス \\(P = (s, v_{i_1}, v_{i_2}, \\ldots, v_{i_k}, t)\\) の長さは、\n\\[\n\\sum_{v \\in P} \\tau(v) = \\tau(v_{i_1}) + \\tau(v_{i_2}) + \\cdots + \\tau(v_{i_k})\n\\]\nである。\n最も長いパスをクリティカルパス（Critical Path）と呼ぶ。クリティカルパスに含まれる作業をクリティカル作業（Critical Activity）と呼ぶ。クリティカル作業が遅延すると、プロジェクト全体の完了が遅延する。\nクリティカルパスを求める問題は、最長路問題に帰着できるが、ここで述べる方法は、プロジェクトにおける様々な有用な情報も提供する。\n\n9.3.1 最早開始時刻と最早終了時刻\n作業点 \\(v \\in V\\) の最も早く開始できる時間を最早開始時刻（Earliest Start Time）と呼び、\\(ES(v)\\) と表す。\\(v\\) の最も早く終了できる時間を最早終了時刻（Earliest Finish Time）と呼び、\\(EF(v)\\) と表す。始点 \\(s\\) の最早開始時刻は \\(ES(s) = 0\\) とする。\n\\(v\\) の最早終了時刻は、最早開始時刻に作業時間を加えたものである。\n\\[\nEF(v) = ES(v) + \\tau(v)\n\\]\n\\(u\\) の最早開始時刻は、\\(u\\) の先行作業 \\(v \\in \\mathcal{P}(u)\\) の中で最早終了時刻 \\(EF(v)\\) が最大のものである。\n\\[\nES(u) = \\max_{v \\in \\mathcal{P}(u)} EF(v)\n\\]\nで与えられる。\n最早開始時刻と最早終了時刻を求めるアルゴリズムは下の通りである。ここで、点をトポロジカルオーダー(topological order)で処理するとは、\\(v\\) のすべての先行作業 \\(u \\in \\mathcal{P}(v)\\) が \\(v\\) より前に処理されるように点を順序付けることである。\n\nAlgorithm 9.1 Forward Pass Algorithm\n\n\\(ES(s) \\leftarrow 0\\), \\(EF(s) \\leftarrow 0\\).\nFor each \\(v \\in V \\setminus \\{s\\}\\) in topological order do\n\n\\(ES(v) \\leftarrow \\max_{u \\in \\mathcal{P}(v)} EF(u)\\).\n\\(EF(v) \\leftarrow ES(v) + \\tau(v)\\).\n\n\n\n例 9.2 のプロジェクト・ネットワークに対して、最早開始時刻と最早終了時刻を求めると、次の表のようになる。\n\n\n\n\\(v\\)\n\\(\\mathcal{P}(v)\\)\n\\(\\tau(v)\\)\n\\(ES(v)\\)\n\\(EF(v)\\)\n\n\n\n\ns\n-\n0\n0\n0\n\n\nA\ns\n2\n0\n2\n\n\nB\ns\n3\n0\n3\n\n\nC\nA\n4\n2\n6\n\n\nD\nA\n2\n2\n4\n\n\nE\nB\n5\n3\n8\n\n\nF\nC, D, E\n9\n8\n17\n\n\nG\nE\n2\n8\n10\n\n\nt\nF, G\n0\n17\n17\n\n\n\n作業 F を開始するためには、作業 C、D、E のすべてが完了している必要がある。そのため、作業 F の開始時間は、作業 C、D、E の中で最も遅い完了時間に依存する。作業 C、D、E の完了時間はそれぞれ 6 日、4 日、8 日であるため、作業 F の最も早い開始時間は 8 日となる。\n\n\n9.3.2 最遅開始時刻と最遅終了時刻\n作業点 \\(v\\) の遅くとも始めないといけない時間を最遅開始時刻（Latest Start Time）と呼び、\\(LS(v)\\) と表す。\\(v\\) の遅くとも終わらせないといけない時間を最遅終了時刻（Latest Finish Time）と呼び、\\(LF(v)\\) と表す。\n終点 \\(t\\) の最遅終了時刻は \\(LF(t) = EF(t)\\) とする。\n\\(v\\) の最遅開始時刻は、最遅終了時刻から作業時間を引いたものである。\n\\[\nLS(v) = LF(v) - \\tau(v)\n\\]\n\\(u\\) の最遅終了時刻は、\\(u\\) の後続作業 \\(v \\in \\mathcal{S}(u)\\) の中で \\(LS(v)\\) が最小のものである。\n\\[\nLF(u) = \\min_{v \\in \\mathcal{S}(u)} LS(v)\n\\]\n例 9.2 のプロジェクト・ネットワークに対して、最遅開始時刻と最遅終了時刻を求めると、次の表のようになる。\n\n\n\n\\(v\\)\n\\(\\mathcal{S}(v)\\)\n\\(\\tau(v)\\)\n\\(LS(v)\\)\n\\(LF(v)\\)\n\n\n\n\ns\nA, B\n0\n0\n0\n\n\nA\nC, D\n2\n2\n4\n\n\nB\nE\n3\n0\n3\n\n\nC\nF\n4\n4\n8\n\n\nD\nF\n2\n6\n8\n\n\nE\nF, G\n5\n3\n8\n\n\nF\nt\n9\n8\n17\n\n\nG\nt\n2\n15\n17\n\n\nt\n-\n0\n17\n17\n\n\n\n\n\n9.3.3 スラック\n作業点 \\(v\\) のスラック（Slack）を \\(SL(v)\\) と表す。スラックは、\n\\[\nSL(v) = LS(v) - ES(v) = LF(v) - EF(v)\n\\]\nで与えられる。スラックは、作業 \\(v\\) の開始または終了を遅らせることができる時間を示す。スラックが 0 の作業はクリティカル作業である。\n例 9.2 のプロジェクト・ネットワークに対して、スラックを求めると、次の表のようになる。\n\n\n\n\\(v\\)\n\\(\\tau(v)\\)\n\\(ES(v)\\)\n\\(EF(v)\\)\n\\(LS(v)\\)\n\\(LF(v)\\)\n\\(SL(v)\\)\n\n\n\n\ns\n0\n0\n0\n0\n0\n0\n\n\nA\n2\n0\n2\n2\n4\n2\n\n\nB\n3\n0\n3\n0\n3\n0\n\n\nC\n4\n2\n6\n4\n8\n2\n\n\nD\n2\n2\n4\n6\n8\n4\n\n\nE\n5\n3\n8\n3\n8\n0\n\n\nF\n9\n8\n17\n8\n17\n0\n\n\nG\n2\n8\n10\n15\n17\n7\n\n\nt\n0\n17\n17\n17\n17\n0\n\n\n\nクリティカルパスは、\\(s \\to B \\to E \\to F \\to t\\) であり、このパスの長さは 17 日である。",
    "crumbs": [
      "ネットワーク最適化",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>PERT/CPM</span>"
    ]
  },
  {
    "objectID": "network/pert.html#点見積もり",
    "href": "network/pert.html#点見積もり",
    "title": "9  PERT/CPM",
    "section": "9.4 3 点見積もり",
    "text": "9.4 3 点見積もり\n以上の方法では、作業の所要時間が確定していることを前提としている。しかし、実際には、所要時間の推定は難しい場合が多い。そこで、作業の所要時間を確率変数として扱い、3 点見積もり（Three-Point Estimation）という方法でその作業時間の平均と分散を推定する。\n3 点見積もりでは、次の 3 つの所要時間を事前に与えられたとする。\n\n楽観値（Optimistic Time, \\(a\\)）：予想される最短の所要時間。\n最頻値（Most Likely Time, \\(m\\)）：最も可能性が高い所要時間。\n悲観値（Pessimistic Time, \\(b\\)）：予想される最長の所要時間。\n\n一般に、\\(a \\leq m \\leq b\\) である。\nこの \\(a\\)、\\(m\\)、\\(b\\) に基づいて、所要時間の平均 \\(\\hat{\\mu}\\) と分散 \\(\\hat{\\sigma}^2\\) を次のように推定する。\n\n\n\n\n\n\nノート\n\n\n\n作業の所要時間がベータ分布に従うと仮定した場合は、式 9.1 が \\(\\mu\\) と \\(\\sigma^2\\) の良い推定量となる。これらの式の詳細な導出は省略する。興味のある読者は、Pleguezuelo, Pérez, と Rambaud (2003) を参照されたい。\n\n\n\\[\n\\hat{\\mu} = \\frac{a + 4m + b}{6}, \\quad \\hat{\\sigma}^2 = \\left(\\frac{b - a}{6}\\right)^2\n\\tag{9.1}\\]\nそこで、\\(\\mu(v)\\) と \\(\\sigma^2(v)\\) をそれぞれ作業点 \\(v\\) の所要時間の平均と分散とする。\\(a(v)\\)、\\(m(v)\\)、\\(b(v)\\) をそれぞれ作業点 \\(v\\) の楽観値、最頻値、悲観値とする。このとき、すべての作業点 \\(v \\in V\\) に対して、\n\\[\n\\mu(v) = \\frac{a(v) + 4m(v) + b(v)}{6}, \\quad \\sigma^2(v) = \\left(\\frac{b(v) - a(v)}{6}\\right)^2\n\\]\nで \\(\\mu(v)\\) と \\(\\sigma^2(v)\\) を計算する。\n例 9.2 のプロジェクト・ネットワークに対して、各作業点の楽観値、最頻値、悲観値が次のように与えられたとするとき、平均と分散を求めると、次の表のようになる。\n\n\n\n\\(v\\)\n\\(a\\)\n\\(m\\)\n\\(b\\)\n\\(\\mu\\)\n\\(\\sigma^2\\)\n\n\n\n\ns\n0\n0\n0\n0\n0\n\n\nA\n0.5\n2\n3.5\n2\n0.25\n\n\nB\n1.5\n3\n4.5\n3\n0.25\n\n\nC\n1.5\n3\n4.5\n3\n0.25\n\n\nD\n0.5\n2\n3.5\n2\n0.25\n\n\nE\n1\n5.5\n7\n5\n1\n\n\nF\n5\n8\n17\n9\n4\n\n\nG\n0.5\n2\n3.5\n2\n0.25\n\n\nt\n0\n0\n0\n0\n0",
    "crumbs": [
      "ネットワーク最適化",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>PERT/CPM</span>"
    ]
  },
  {
    "objectID": "network/pert.html#不確実性を考慮したpertcpm",
    "href": "network/pert.html#不確実性を考慮したpertcpm",
    "title": "9  PERT/CPM",
    "section": "9.5 不確実性を考慮したPERT/CPM",
    "text": "9.5 不確実性を考慮したPERT/CPM\n3 点見積もりを用いて、各作業点 \\(v \\in V\\) の所要時間の平均 \\(\\mu(v)\\) と分散 \\(\\sigma^2(v)\\) を求めたとする。このとき、与えられた時間までにプロジェクトが完了する確率を求めたい。\nプロジェクト・ネットワークにおけるパス \\(P = (s, v_{i_1}, v_{i_2}, \\ldots, v_{i_k}, t)\\) の所要時間の平均 \\(\\mu(P)\\) と分散 \\(\\sigma^2(P)\\) は、それぞれ次のように推定できる。\n\\[\n\\mu(P) = \\sum_{v \\in P} \\mu(v), \\quad \\sigma^2(P) = \\sum_{v \\in P} \\sigma^2(v)\n\\]\nパス \\(P\\) の所要時間の標準偏差 \\(\\sigma(P)\\) は、\n\\[\n\\sigma(P) = \\sqrt{\\sigma^2(P)}\n\\]\nで与えられる。求められたパスの中で、所要時間の平均 \\(\\mu(P)\\) が最大のパスをクリティカルパス \\(P^*\\) とする。セクション 9.3 で述べた方法でクリティカルパスを求めることができる。\nクリティカルパス \\(P^*\\) の所要時間を \\(X\\) とし、与えられた時間 \\(d\\) までにプロジェクトが完了する確率を \\(\\mathbb{P}(X \\leq d)\\) と表す。\n\n\n\n\n\n\nノート\n\n\n\nここでは、計算を簡単にするために、クリティカルパスが最も時間がかかるパスであると仮定している。実際には、平均値から計算されたクリティカルパスが、最も時間がかかるパスであるとは限らないことに注意されたい。\n\n\n\\[\n\\mathbb{P}(X \\leq d) = \\phi\\left(\\frac{d - \\mu(P^*)}{\\sigma(P^*)}\\right)\n\\]\nここで、\\(\\phi(z)\\) は標準正規分布の確率密度関数である。\\(z\\) は次のように計算し、標準正規分布表を用いて \\(\\phi(z)\\) を調べる。\n\\[\nz = \\frac{d - \\mu(P^*)}{\\sigma(P^*)}\n\\]\n例 9.2 では、クリティカルパスは \\(s \\to B \\to E \\to F \\to t\\) であり、このパスの所要時間の平均、分散、標準偏差は次のように計算できる。\n\\[\n\\mu(P^*) = 3 + 5 + 9 = 17\n\\]\n\\[\n\\sigma^2(P^*) = 0.25 + 1 + 4 = 5.25\n\\]\n\\[\n\\sigma(P^*) = \\sqrt{5.25} \\approx 2.29\n\\]\n与えられた時間 \\(d = 20\\) 日までにプロジェクトが完了する確率を求めるには、次のように計算する。\n\\(z\\) を計算すると、\n\\[\nz = \\frac{20 - 17}{2.29} \\approx 1.31\n\\]\n標準正規分布表を用いて、\\(\\phi(1.31) \\approx 0.9049\\) である。したがって、与えられた時間 \\(d = 20\\) 日までにプロジェクトが完了する確率は約 90.49% である。",
    "crumbs": [
      "ネットワーク最適化",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>PERT/CPM</span>"
    ]
  },
  {
    "objectID": "network/pert.html#時間とコストのトレードオフ",
    "href": "network/pert.html#時間とコストのトレードオフ",
    "title": "9  PERT/CPM",
    "section": "9.6 時間とコストのトレードオフ",
    "text": "9.6 時間とコストのトレードオフ\n作業時間を短縮するには、コストがかかる。最小のコストでプロジェクトを短縮する問題を考える。\n\n9.6.1 問題の定式化\n\n\\(c_i\\): 作業 \\(i\\) の単位時間あたりの短縮コスト\n\\(M_i\\): 作業 \\(i\\) の最大短縮時間\n\\(T\\): プロジェクトの完了時間の上限\n\\(\\tau_i\\): 作業 \\(i\\) の標準所要時間\n\\(y_i\\): 作業 \\(i\\) の開始時間\n\\(x_i\\): 作業 \\(i\\) の短縮時間\n\n\\[\\begin{align*}\n\\text{minimize} \\quad & \\sum_{i} c_i x_i &\\\\\n\\text{subject to} \\quad & y_j \\geq y_i + \\tau_i - x_i, \\quad & \\forall (i, j) \\in E \\\\\n& 0 \\leq x_i \\leq M_i, \\quad & \\forall i \\in V \\\\\n& y_t \\leq T \\\\\n& y_s = 0\n\\end{align*}\\]\n\n\n9.6.2 例題\nプロジェクト・ネットワークはグラフ \\(G = (V, E)\\) で表す。作業の集合は\n\\[\nV = \\{s, t, A, B, C, D, E\\}\n\\] であり、辺の集合は\n\\[\nE = \\{(s, A), (s, C), (A, B), (C, D), (B, E), (D, E), (E, t)\\}\n\\] である。ここで、\\(s\\) は始点、\\(t\\) は終点である。プロジェクト全体の所要時間の上限を \\(T = 10\\) とする。\n作業時間、コスト、最大短縮時間は次の表のように与えられる。\n\n\n\n作業\n\\(\\tau_i\\)\n\\(c_i\\)\n\\(M_i\\)\n\n\n\n\nA\n7\n100\n3\n\n\nB\n3\n150\n1\n\n\nC\n6\n200\n2\n\n\nD\n3\n150\n2\n\n\nE\n2\n250\n1\n\n\n\nこの問題を次のように定式化できる。\n\\[\\begin{align*}\n\\text{minimize} \\quad & 100x_A + 150x_B + 200x_C + 150x_D + 250x_E &\\\\\n\\text{subject to} \\quad & y_A \\geq 0 \\\\\n& y_C \\geq 0 \\\\\n& y_B \\geq y_A + 7 - x_A \\\\\n& y_D \\geq y_C + 6 - x_C \\\\\n& y_E \\geq y_B + 3 - x_B \\\\\n& y_E \\geq y_D + 3 - x_D \\\\\n& y_t \\geq y_E + 2 - x_E \\\\\n& 0 \\leq x_A \\leq 3 \\\\\n& 0 \\leq x_B \\leq 1 \\\\\n& 0 \\leq x_C \\leq 2 \\\\\n& 0 \\leq x_D \\leq 2 \\\\\n& 0 \\leq x_E \\leq 1 \\\\\n& y_t \\leq 10 \\\\\n& y_s = 0\n\\end{align*}\\]\nこの線形計画問題は、最適化ソルバーを用いて解くことができる。以下に Gurobi を用いた実装例を示す。\n!pip install gurobipy\nfrom gurobipy import Model, GRB\n\n# データ定義\nV = [\"s\", \"t\", \"A\", \"B\", \"C\", \"D\", \"E\"]\nE = [(\"s\", \"A\"), (\"s\", \"C\"), (\"A\", \"B\"), (\"C\", \"D\"), (\"B\", \"E\"), (\"D\", \"E\"), (\"E\", \"t\")]\n\ntau = {\"A\": 7, \"B\": 3, \"C\": 6, \"D\": 3, \"E\": 2}\ncost = {\"A\": 100, \"B\": 150, \"C\": 200, \"D\": 150, \"E\": 250}\nM = {\"A\": 3, \"B\": 1, \"C\": 2, \"D\": 2, \"E\": 1}\n\nT = 10\n\n# モデル作成\nm = Model(\"Project_Crashing\")\nm.setParam(\"OutputFlag\", 0) \n\n# 変数定義\nx = {i: m.addVar(lb=0, ub=M[i], name=\"x_{}\".format(i)) for i in M}\ny = {i: m.addVar(lb=0, name=\"y_{}\".format(i)) for i in V}\n\n# 目的関数\nm.setObjective(sum(cost[i] * x[i] for i in M), GRB.MINIMIZE)\n\n# 制約\nfor i, j in E:\n    if i == \"s\":\n        m.addConstr(y[j] &gt;= 0)\n    elif i in tau:\n        m.addConstr(y[j] &gt;= y[i] + tau[i] - x[i])\n\n# プロジェクト終了制約\nm.addConstr(y[\"t\"] &lt;= T)\n\n# 開始ノード固定\nm.addConstr(y[\"s\"] == 0)\n\n# 最適化\nm.optimize()\n\n# 結果表示\nprint(\"Objective:\", m.objVal)\nfor i in x:\n    print(\"x_{} =\".format(i), x[i].X)\nfor i in y:\n    print(\"y_{} =\".format(i), y[i].X)\nObjective: 350.0\nx_A = 1.0\nx_B = 0.0\nx_C = 0.0\nx_D = 0.0\nx_E = 1.0\ny_s = 0.0\ny_t = 10.0\ny_A = 0.0\ny_B = 6.0\ny_C = 0.0\ny_D = 6.0\ny_E = 9.0\nこの結果から、作業 A を 1 日、作業 E を 1 日短縮することで、最小コスト 350 でプロジェクトを 10 日以内に完了できることがわかる。\n\n\n\n\nCamm, Jeffrey, James Cochran, Michael Fry, Jeffrey Ohlmann, David Anderson, Dennis Sweeney, と Thomas Williams. 2022. An introduction to management science: Quantitative approaches to decision making. 16th 版. Florence, AL: South-Western College Publishing.\n\n\nEiselt, H A, と Carl-Louis Sandblom. 2022. Operations research: A model-based approach. Cham: Springer International Publishing.\n\n\nHillier, Frederick, と Gerald Lieberman. 2025. ISE introduction to operations research. 11th 版. Columbus, OH: McGraw-Hill Education.\n\n\nPleguezuelo, Rafael Herrerı́as, José Garcı́a Pérez, と Salvador Cruz Rambaud. 2003. 「A note on the reasonableness of PERT hypotheses」. Oper. Res. Lett. 31 (1): 60–62.",
    "crumbs": [
      "ネットワーク最適化",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>PERT/CPM</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "参考文献",
    "section": "",
    "text": "Arrow, Kenneth J, Theodore Harris, and Jacob Marschak. 1951.\n“Optimal Inventory Policy.” Econometrica 19 (3):\n250.\n\n\nBrunelli, Matteo. 2015. Introduction to the Analytic Hierarchy\nProcess. 2015th ed. SpringerBriefs in Operations Research. Cham:\nSpringer International Publishing.\n\n\nCamm, Jeffrey, James Cochran, Michael Fry, Jeffrey Ohlmann, David\nAnderson, Dennis Sweeney, and Thomas Williams. 2022. An Introduction\nto Management Science: Quantitative Approaches to Decision Making.\n16th ed. Florence, AL: South-Western College Publishing.\n\n\nCrawford, Gordon, and Cindy Williams. 1985. “A Note on the\nAnalysis of Subjective Judgment Matrices.” Journal of\nMathematical Psychology, Some thoughts about the mathematics of the\nanalytic hierarchy process, 29 (4): 387–405.\n\n\nEiselt, H A, and Carl-Louis Sandblom. 2022. Operations Research: A\nModel-Based Approach. Cham: Springer International Publishing.\n\n\nHarris, Ford W. 1990. “How Many Parts to Make at Once.”\nOper. Res. 38 (6): 947–50.\n\n\nHillier, Frederick, and Gerald Lieberman. 2025. ISE\nIntroduction to Operations Research. 11th ed. Columbus, OH:\nMcGraw-Hill Education.\n\n\nHuber, Jakob, Sebastian Müller, Moritz Fleischmann, and Heiner\nStuckenschmidt. 2019. “A Data-Driven Newsvendor Problem: From Data\nto Decision.” Eur. J. Oper. Res. 278 (3): 904–15.\n\n\nPleguezuelo, Rafael Herrerı́as, José Garcı́a Pérez, and Salvador Cruz\nRambaud. 2003. “A Note on the Reasonableness of PERT\nHypotheses.” Oper. Res. Lett. 31 (1): 60–62.\n\n\nQin, Yan, Ruoxuan Wang, Asoo J Vakharia, Yuwen Chen, and Michelle M H\nSeref. 2011. “The Newsvendor Problem: Review and Directions for\nFuture Research.” Eur. J. Oper. Res. 213 (2): 361–74.\n\n\nScarf, Herbert. 1959. “The Optimality of (S, s)\nPolicies in the Dynamic Inventory Problem.”\n\n\nSnyder, Lawrence V, and Zuo-Jun Max Shen. 2019. Fundamentals of\nSupply Chain Theory. 2nd ed. Nashville, TN: John Wiley & Sons.",
    "crumbs": [
      "参考文献"
    ]
  },
  {
    "objectID": "appendices/probability.html",
    "href": "appendices/probability.html",
    "title": "付録 B — 確率",
    "section": "",
    "text": "B.1 正規分布\n離散型確率変数 \\(X\\) が特定の値 \\(x\\) をとる確率を\n\\[\nP(X = x) = p_X(x)\n\\]\nと表すとき、\\(p_X(x)\\) を \\(X\\) の確率質量関数 (PMF) という。\n連続型確率変数 \\(X\\) がある区間 \\([a, b]\\) にある値をとる確率を\n\\[\nP(a \\leq X \\leq b) = \\int_a^b f_X(x) dx\n\\]\nと表す。\\(f_X(x)\\) を \\(X\\) の確率密度関数 (PDF) という。\n確率変数 \\(X\\) の累積分布関数 (CDF) を\n\\[\nF_X(x) = P(X \\leq x) = \\begin{cases}\n\\sum_{k \\leq x} p_X(k) & \\text{if } X \\text{ is discrete} \\\\\n\\int_{-\\infty}^x f_X(t) dt & \\text{if } X \\text{ is continuous}\n\\end{cases}\n\\]\nと表す。確率密度関数 \\(f_X(x)\\) は累積分布関数 \\(F_X(x)\\) の微分である。\n\\[\nf_X(x) = \\frac{d}{dx} F_X(x)\n\\]\n連続型確率変数 \\(X\\) は正規分布（normal distribution）に従うとき、\\(X \\sim N(\\mu, \\sigma^2)\\) と表す。ここで \\(\\mu\\) は平均、\\(\\sigma^2\\) は分散である。\\(X\\) の確率密度関数は\n\\[\nf_X(x) = \\frac{1}{\\sqrt{2\\pi} \\sigma} e^{-\\frac{(x - \\mu)^2}{2\\sigma^2}}\n\\]\nと表す。平均は \\(E[X] = \\mu\\)、分散は \\(\\text{Var}(X) = \\sigma^2\\) である。\n\\(X\\) が \\(N(\\mu, \\sigma^2)\\) に従うとき、\\(Y = aX + b\\) は、\\(N(a\\mu + b, a^2\\sigma^2)\\) に従う。特に、\\(Z = \\frac{X - \\mu}{\\sigma}\\) は標準正規分布（standard normal distribution）に従う。すなわち、\\(Z \\sim N(0, 1)\\) である。\n連続型確率変数 \\(Y\\) が標準正規分布に従うとき、\\(Y\\) の累積分布関数は\n\\[\n\\Phi(y) = P(Y \\leq y) = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^y e^{-\\frac{t^2}{2}} dt\n\\]\nと表す。標準正規分布表から、\\(y\\) の値に対する \\(\\Phi(y)\\) を調べることができる。\nPython では、以下のように \\(\\Phi(y)\\) を計算できる。\nまた、\\(\\Phi(y)=0.95\\) のときの \\(y\\) の値を求めるには、以下のようにする。\n正規分布は再生性（reproductive property）を持つ。すなわち、\\(X_1, X_2, \\ldots, X_n\\) が独立に \\(N(\\mu_i, \\sigma_i^2)\\) に従うとき、\\(Y = \\sum_{i=1}^n a_i X_i\\) は \\(N\\left(\\sum_{i=1}^n a_i \\mu_i, \\sum_{i=1}^n a_i^2 \\sigma_i^2\\right)\\) に従う。",
    "crumbs": [
      "付録",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>確率</span>"
    ]
  },
  {
    "objectID": "appendices/probability.html#正規分布",
    "href": "appendices/probability.html#正規分布",
    "title": "付録 B — 確率",
    "section": "",
    "text": "from scipy.stats import norm\ndef phi(y):\n    return norm.cdf(y)\n\nphi(0)  # 0.5\n\nfrom scipy.stats import norm\ndef phi_inverse(p):\n    return norm.ppf(p)\n\nphi_inverse(0.95)  # 約1.64485",
    "crumbs": [
      "付録",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>確率</span>"
    ]
  },
  {
    "objectID": "appendices/standard_normal_table.html",
    "href": "appendices/standard_normal_table.html",
    "title": "付録 C — 標準正規分布表",
    "section": "",
    "text": "下表は、標準正規分布 \\(N(0, 1)\\) の累積分布関数\n\\[\n\\phi(z) = P(Z \\leq z) = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{z} e^{-\\frac{t^2}{2}} dt\n\\]\nの値を示すものである。\n\n例 C.1 \\(z = 1.23\\) のとき、\\(\\phi(1.23)\\) の値を求めよ。\n表の行から \\(1.2\\)、列から \\(+0.03\\) を選ぶ。交差する値は \\(0.89065\\) である。したがって、\\(\\phi(1.23) = 0.89065\\) である。\n\n\n例 C.2 \\(\\phi(z) = 0.89065\\) のとき、\\(z\\) の値を求めよ。\n表の中から \\(0.89065\\) を探す。行から \\(1.2\\)、列から \\(+0.03\\) を選ぶ。したがって、\\(z = 1.23\\) である。\n\n\n例 C.3 \\(X \\sim N(100, 15^2)\\) のとき、\\(P(X \\leq 120)\\) の値を求めよ。\n\\[\\begin{align}\nP(X \\leq 120) &= \\phi\\left(\\frac{120 - 100}{15}\\right) \\\\\n&= \\phi\\left(\\frac{20}{15}\\right) \\\\\n&\\approx \\phi(1.33) \\\\\n\\end{align}\\]\n\n表から \\(\\phi(1.33) \\approx 0.90824\\) である。\n\n例 C.4 \\(X \\sim N(100, 15^2)\\) のとき、\\(P(X \\leq x) = 0.9\\) のとき、\\(x\\)の値を求めよ。\n\\[\\begin{align}\nP(X \\leq x) &= 0.9 \\\\\n\\phi\\left(\\frac{x - 100}{15}\\right) &= 0.9 \\\\\n\\frac{x - 100}{15} &\\approx 1.28 \\\\\nx - 100 &\\approx 19.2 \\\\\nx &\\approx 119.2 \\\\\n\\end{align}\\]\nしたがって、\\(x \\approx 119.2\\) である。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nz\n−0.00\n−0.01\n−0.02\n−0.03\n−0.04\n−0.05\n−0.06\n−0.07\n−0.08\n−0.09\n\n\n\n\n-3.9\n0.00005\n0.00005\n0.00004\n0.00004\n0.00004\n0.00004\n0.00004\n0.00004\n0.00003\n0.00003\n\n\n-3.8\n0.00007\n0.00007\n0.00007\n0.00006\n0.00006\n0.00006\n0.00006\n0.00005\n0.00005\n0.00005\n\n\n-3.7\n0.00011\n0.00010\n0.00010\n0.00010\n0.00009\n0.00009\n0.00008\n0.00008\n0.00008\n0.00008\n\n\n-3.6\n0.00016\n0.00015\n0.00015\n0.00014\n0.00014\n0.00013\n0.00013\n0.00012\n0.00012\n0.00011\n\n\n-3.5\n0.00023\n0.00022\n0.00022\n0.00021\n0.00020\n0.00019\n0.00019\n0.00018\n0.00017\n0.00017\n\n\n-3.4\n0.00034\n0.00032\n0.00031\n0.00030\n0.00029\n0.00028\n0.00027\n0.00026\n0.00025\n0.00024\n\n\n-3.3\n0.00048\n0.00047\n0.00045\n0.00043\n0.00042\n0.00040\n0.00039\n0.00038\n0.00036\n0.00035\n\n\n-3.2\n0.00069\n0.00066\n0.00064\n0.00062\n0.00060\n0.00058\n0.00056\n0.00054\n0.00052\n0.00050\n\n\n-3.1\n0.00097\n0.00094\n0.00090\n0.00087\n0.00084\n0.00082\n0.00079\n0.00076\n0.00074\n0.00071\n\n\n-3.0\n0.00135\n0.00131\n0.00126\n0.00122\n0.00118\n0.00114\n0.00111\n0.00107\n0.00104\n0.00100\n\n\n-2.9\n0.00187\n0.00181\n0.00175\n0.00169\n0.00164\n0.00159\n0.00154\n0.00149\n0.00144\n0.00139\n\n\n-2.8\n0.00256\n0.00248\n0.00240\n0.00233\n0.00226\n0.00219\n0.00212\n0.00205\n0.00199\n0.00193\n\n\n-2.7\n0.00347\n0.00336\n0.00326\n0.00317\n0.00307\n0.00298\n0.00289\n0.00280\n0.00272\n0.00264\n\n\n-2.6\n0.00466\n0.00453\n0.00440\n0.00427\n0.00415\n0.00402\n0.00391\n0.00379\n0.00368\n0.00357\n\n\n-2.5\n0.00621\n0.00604\n0.00587\n0.00570\n0.00554\n0.00539\n0.00523\n0.00508\n0.00494\n0.00480\n\n\n-2.4\n0.00820\n0.00798\n0.00776\n0.00755\n0.00734\n0.00714\n0.00695\n0.00676\n0.00657\n0.00639\n\n\n-2.3\n0.01072\n0.01044\n0.01017\n0.00990\n0.00964\n0.00939\n0.00914\n0.00889\n0.00866\n0.00842\n\n\n-2.2\n0.01390\n0.01355\n0.01321\n0.01287\n0.01255\n0.01222\n0.01191\n0.01160\n0.01130\n0.01101\n\n\n-2.1\n0.01786\n0.01743\n0.01700\n0.01659\n0.01618\n0.01578\n0.01539\n0.01500\n0.01463\n0.01426\n\n\n-2.0\n0.02275\n0.02222\n0.02169\n0.02118\n0.02068\n0.02018\n0.01970\n0.01923\n0.01876\n0.01831\n\n\n-1.9\n0.02872\n0.02807\n0.02743\n0.02680\n0.02619\n0.02559\n0.02500\n0.02442\n0.02385\n0.02330\n\n\n-1.8\n0.03593\n0.03515\n0.03438\n0.03362\n0.03288\n0.03216\n0.03144\n0.03074\n0.03005\n0.02938\n\n\n-1.7\n0.04457\n0.04363\n0.04272\n0.04182\n0.04093\n0.04006\n0.03920\n0.03836\n0.03754\n0.03673\n\n\n-1.6\n0.05480\n0.05370\n0.05262\n0.05155\n0.05050\n0.04947\n0.04846\n0.04746\n0.04648\n0.04551\n\n\n-1.5\n0.06681\n0.06552\n0.06426\n0.06301\n0.06178\n0.06057\n0.05938\n0.05821\n0.05705\n0.05592\n\n\n-1.4\n0.08076\n0.07927\n0.07780\n0.07636\n0.07493\n0.07353\n0.07215\n0.07078\n0.06944\n0.06811\n\n\n-1.3\n0.09680\n0.09510\n0.09342\n0.09176\n0.09012\n0.08851\n0.08692\n0.08534\n0.08379\n0.08226\n\n\n-1.2\n0.11507\n0.11314\n0.11123\n0.10935\n0.10749\n0.10565\n0.10383\n0.10204\n0.10027\n0.09853\n\n\n-1.1\n0.13567\n0.13350\n0.13136\n0.12924\n0.12714\n0.12507\n0.12302\n0.12100\n0.11900\n0.11702\n\n\n-1.0\n0.15866\n0.15625\n0.15386\n0.15151\n0.14917\n0.14686\n0.14457\n0.14231\n0.14007\n0.13786\n\n\n-0.9\n0.18406\n0.18141\n0.17879\n0.17619\n0.17361\n0.17106\n0.16853\n0.16602\n0.16354\n0.16109\n\n\n-0.8\n0.21186\n0.20897\n0.20611\n0.20327\n0.20045\n0.19766\n0.19489\n0.19215\n0.18943\n0.18673\n\n\n-0.7\n0.24196\n0.23885\n0.23576\n0.23270\n0.22965\n0.22663\n0.22363\n0.22065\n0.21770\n0.21476\n\n\n-0.6\n0.27425\n0.27093\n0.26763\n0.26435\n0.26109\n0.25785\n0.25463\n0.25143\n0.24825\n0.24510\n\n\n-0.5\n0.30854\n0.30503\n0.30153\n0.29806\n0.29460\n0.29116\n0.28774\n0.28434\n0.28096\n0.27760\n\n\n-0.4\n0.34458\n0.34090\n0.33724\n0.33360\n0.32997\n0.32636\n0.32276\n0.31918\n0.31561\n0.31207\n\n\n-0.3\n0.38209\n0.37828\n0.37448\n0.37070\n0.36693\n0.36317\n0.35942\n0.35569\n0.35197\n0.34827\n\n\n-0.2\n0.42074\n0.41683\n0.41294\n0.40905\n0.40517\n0.40129\n0.39743\n0.39358\n0.38974\n0.38591\n\n\n-0.1\n0.46017\n0.45620\n0.45224\n0.44828\n0.44433\n0.44038\n0.43644\n0.43251\n0.42858\n0.42465\n\n\n-0.0\n0.50000\n0.49601\n0.49202\n0.48803\n0.48405\n0.48006\n0.47608\n0.47210\n0.46812\n0.46414\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nz\n+0.00\n+0.01\n+0.02\n+0.03\n+0.04\n+0.05\n+0.06\n+0.07\n+0.08\n+0.09\n\n\n\n\n0.0\n0.50000\n0.50399\n0.50798\n0.51197\n0.51595\n0.51994\n0.52392\n0.52790\n0.53188\n0.53586\n\n\n0.1\n0.53983\n0.54380\n0.54776\n0.55172\n0.55567\n0.55962\n0.56360\n0.56749\n0.57142\n0.57535\n\n\n0.2\n0.57926\n0.58317\n0.58706\n0.59095\n0.59483\n0.59871\n0.60257\n0.60642\n0.61026\n0.61409\n\n\n0.3\n0.61791\n0.62172\n0.62552\n0.62930\n0.63307\n0.63683\n0.64058\n0.64431\n0.64803\n0.65173\n\n\n0.4\n0.65542\n0.65910\n0.66276\n0.66640\n0.67003\n0.67364\n0.67724\n0.68082\n0.68439\n0.68793\n\n\n0.5\n0.69146\n0.69497\n0.69847\n0.70194\n0.70540\n0.70884\n0.71226\n0.71566\n0.71904\n0.72240\n\n\n0.6\n0.72575\n0.72907\n0.73237\n0.73565\n0.73891\n0.74215\n0.74537\n0.74857\n0.75175\n0.75490\n\n\n0.7\n0.75804\n0.76115\n0.76424\n0.76730\n0.77035\n0.77337\n0.77637\n0.77935\n0.78230\n0.78524\n\n\n0.8\n0.78814\n0.79103\n0.79389\n0.79673\n0.79955\n0.80234\n0.80511\n0.80785\n0.81057\n0.81327\n\n\n0.9\n0.81594\n0.81859\n0.82121\n0.82381\n0.82639\n0.82894\n0.83147\n0.83398\n0.83646\n0.83891\n\n\n1.0\n0.84134\n0.84375\n0.84614\n0.84849\n0.85083\n0.85314\n0.85543\n0.85769\n0.85993\n0.86214\n\n\n1.1\n0.86433\n0.86650\n0.86864\n0.87076\n0.87286\n0.87493\n0.87698\n0.87900\n0.88100\n0.88298\n\n\n1.2\n0.88493\n0.88686\n0.88877\n0.89065\n0.89251\n0.89435\n0.89617\n0.89796\n0.89973\n0.90147\n\n\n1.3\n0.90320\n0.90490\n0.90658\n0.90824\n0.90988\n0.91149\n0.91308\n0.91466\n0.91621\n0.91774\n\n\n1.4\n0.91924\n0.92073\n0.92220\n0.92364\n0.92507\n0.92647\n0.92785\n0.92922\n0.93056\n0.93189\n\n\n1.5\n0.93319\n0.93448\n0.93574\n0.93699\n0.93822\n0.93943\n0.94062\n0.94179\n0.94295\n0.94408\n\n\n1.6\n0.94520\n0.94630\n0.94738\n0.94845\n0.94950\n0.95053\n0.95154\n0.95254\n0.95352\n0.95449\n\n\n1.7\n0.95543\n0.95637\n0.95728\n0.95818\n0.95907\n0.95994\n0.96080\n0.96164\n0.96246\n0.96327\n\n\n1.8\n0.96407\n0.96485\n0.96562\n0.96638\n0.96712\n0.96784\n0.96856\n0.96926\n0.96995\n0.97062\n\n\n1.9\n0.97128\n0.97193\n0.97257\n0.97320\n0.97381\n0.97441\n0.97500\n0.97558\n0.97615\n0.97670\n\n\n2.0\n0.97725\n0.97778\n0.97831\n0.97882\n0.97932\n0.97982\n0.98030\n0.98077\n0.98124\n0.98169\n\n\n2.1\n0.98214\n0.98257\n0.98300\n0.98341\n0.98382\n0.98422\n0.98461\n0.98500\n0.98537\n0.98574\n\n\n2.2\n0.98610\n0.98645\n0.98679\n0.98713\n0.98745\n0.98778\n0.98809\n0.98840\n0.98870\n0.98899\n\n\n2.3\n0.98928\n0.98956\n0.98983\n0.99010\n0.99036\n0.99061\n0.99086\n0.99111\n0.99134\n0.99158\n\n\n2.4\n0.99180\n0.99202\n0.99224\n0.99245\n0.99266\n0.99286\n0.99305\n0.99324\n0.99343\n0.99361\n\n\n2.5\n0.99379\n0.99396\n0.99413\n0.99430\n0.99446\n0.99461\n0.99477\n0.99492\n0.99506\n0.99520\n\n\n2.6\n0.99534\n0.99547\n0.99560\n0.99573\n0.99585\n0.99598\n0.99609\n0.99621\n0.99632\n0.99643\n\n\n2.7\n0.99653\n0.99664\n0.99674\n0.99683\n0.99693\n0.99702\n0.99711\n0.99720\n0.99728\n0.99736\n\n\n2.8\n0.99744\n0.99752\n0.99760\n0.99767\n0.99774\n0.99781\n0.99788\n0.99795\n0.99801\n0.99807\n\n\n2.9\n0.99813\n0.99819\n0.99825\n0.99831\n0.99836\n0.99841\n0.99846\n0.99851\n0.99856\n0.99861\n\n\n3.0\n0.99865\n0.99869\n0.99874\n0.99878\n0.99882\n0.99886\n0.99889\n0.99893\n0.99896\n0.99900\n\n\n3.1\n0.99903\n0.99906\n0.99910\n0.99913\n0.99916\n0.99918\n0.99921\n0.99924\n0.99926\n0.99929\n\n\n3.2\n0.99931\n0.99934\n0.99936\n0.99938\n0.99940\n0.99942\n0.99944\n0.99946\n0.99948\n0.99950\n\n\n3.3\n0.99952\n0.99953\n0.99955\n0.99957\n0.99958\n0.99960\n0.99961\n0.99962\n0.99964\n0.99965\n\n\n3.4\n0.99966\n0.99968\n0.99969\n0.99970\n0.99971\n0.99972\n0.99973\n0.99974\n0.99975\n0.99976\n\n\n3.5\n0.99977\n0.99978\n0.99978\n0.99979\n0.99980\n0.99981\n0.99981\n0.99982\n0.99983\n0.99983\n\n\n3.6\n0.99984\n0.99985\n0.99985\n0.99986\n0.99986\n0.99987\n0.99987\n0.99988\n0.99988\n0.99989\n\n\n3.7\n0.99989\n0.99990\n0.99990\n0.99990\n0.99991\n0.99991\n0.99992\n0.99992\n0.99992\n0.99992\n\n\n3.8\n0.99993\n0.99993\n0.99993\n0.99994\n0.99994\n0.99994\n0.99994\n0.99995\n0.99995\n0.99995\n\n\n3.9\n0.99995\n0.99995\n0.99996\n0.99996\n0.99996\n0.99996\n0.99996\n0.99996\n0.99997\n0.99997",
    "crumbs": [
      "付録",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>標準正規分布表</span>"
    ]
  }
]