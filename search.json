[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "オペレーションズ・リサーチ",
    "section": "",
    "text": "Preface\nORを学ぶための教科書です．",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#注意点",
    "href": "index.html#注意点",
    "title": "オペレーションズ・リサーチ",
    "section": "注意点",
    "text": "注意点\n随時更新していきますので，読む際は必ずブラウザをリロードしてください．",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#python",
    "href": "index.html#python",
    "title": "オペレーションズ・リサーチ",
    "section": "Python",
    "text": "Python\nすべてのモデル，アルゴリズムについて，Pythonでの実装例を示します．講義では Python プログラミングについては扱いませんが，Pythonの基礎的な知識があると理解が深まります．\n以下の手順で，教材に掲載されているコードを Google Colab 上で簡単に実行できます．ぜひ試してみてください．\n\nGoogle アカウントにログインする\nGoogle Colab にアクセスする\n「+新しいノート」をクリックする\nコードをコピーして，セルに貼り付ける\nセルを実行する",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#フィードバック",
    "href": "index.html#フィードバック",
    "title": "オペレーションズ・リサーチ",
    "section": "フィードバック",
    "text": "フィードバック\n継続的に改善していきますので，誤字脱字，内容の不備，わかりにくい箇所などを見つけたら，劉子昂までご連絡ください．",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#内容",
    "href": "index.html#内容",
    "title": "オペレーションズ・リサーチ",
    "section": "内容",
    "text": "内容\n\n\n\n回\n内容\n\n\n\n\n1\nガイダンス\n\n\n2\n在庫モデル：EOQモデル\n\n\n3\n在庫モデル：新聞売り子問題\n\n\n4\n在庫モデル：安全在庫\n\n\n5\nAHP\n\n\n6\nPERT 1\n\n\n7\nPERT 2\n\n\n8\nPERT 3\n\n\n9\n包絡分析法\n\n\n10\n動的計画法\n\n\n11\n待ち行列 1\n\n\n12\n待ち行列 2\n\n\n13\n待ち行列 3",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "course-info.html",
    "href": "course-info.html",
    "title": "講義",
    "section": "",
    "text": "講義情報\n本授業では、オペレーションズ・リサーチ（OR）の中の代表的な手法であるPERT、在庫理論、待ち行列理論、動的計画法、階層分析法、及び包絡分析法の数理を理解し、具体的な問題への応用を学ぶ。",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#講義情報",
    "href": "course-info.html#講義情報",
    "title": "講義",
    "section": "",
    "text": "講義名：オペレーションズ・リサーチB\n曜日：水曜日\n時限：2時限目（10:50～12:30）\n教室：西館 W202\n担当教員：劉 子昂\nGoogle Classroom: Link",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#出席",
    "href": "course-info.html#出席",
    "title": "講義",
    "section": "出席",
    "text": "出席\n不定期に出席を取ります。\n出席は WebClass 上で取ります。以下の時間に注意してください。\n\n出席扱い : 10:50 - 11:09\n遅刻扱い : 11:10 - 11:29\n欠席扱い : 11:30 -",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#成績評価",
    "href": "course-info.html#成績評価",
    "title": "講義",
    "section": "成績評価",
    "text": "成績評価\n\n期末試験（100%）\n4回以上の欠席は単位取得不可。\n講義中の加点問題に正解した場合、試験の点数に加点します。",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#到達目標",
    "href": "course-info.html#到達目標",
    "title": "講義",
    "section": "到達目標",
    "text": "到達目標\n各分野について、下記の事項を目標して講義を行う。\n\nPERTの計算と解析方法を理解し、プロジェクトの評価を行うことができる。\n在庫モデルを理解し、自分で式を構築及び解析することができる。\n待ち行列理論の重要な式や定理を理論的に導出し、それらを適切に解釈することができる。\n動的計画法の基本的な考え方を理解し、簡単な問題への適用ができる。\n階層分析法による意思決定の手法を理解し、一対比較行列からウェイトと整合性を計算することができる。\n包絡分析法におけるCCRモデルを理解し、得られた結果を解釈することができる。\n\nさらに、これらの手法を用いて比較的簡単な現象をモデル化し、解析することができる。",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#orは重要",
    "href": "course-info.html#orは重要",
    "title": "講義",
    "section": "ORは重要",
    "text": "ORは重要\n経営工学において、最も重要な学問分野の一つ。\n日本経営工学会によると、「解決すべき課題の数理モデルを構築し、最適な手法を求めるオペレーションズ・リサーチ（OR）という分野は、経営工学の主要なテーマとなっています」。\n海外では、管理科学（Management Science）とORは同義語として使われることもよくある。",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#orの全体像",
    "href": "course-info.html#orの全体像",
    "title": "講義",
    "section": "ORの全体像",
    "text": "ORの全体像\n\n線形計画法\n整数計画法\n非線形計画法\n動的計画法\nグラフ理論・ネットワーク\nシミュレーション\n在庫モデル\n待ち行列\n多基準意思決定分析\nプロジェクトマネジメント\n…",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#orは難しい",
    "href": "course-info.html#orは難しい",
    "title": "講義",
    "section": "ORは難しい？",
    "text": "ORは難しい？\n\n基礎知識が必要\n微分積分、線形代数、確率、統計の基礎知識が必要です。これらの基礎が不十分な場合、授業についていけないです。基礎知識が不十分な場合、必ず復習してください。\nこの講義では、以下の工夫をしています。\n\n付録に必要な基礎知識のまとめがあります。随時更新しますので、参考にしてください。\n講義資料には例題、図、演習問題を多く用意しています。\nプログラミングの実装例も示します。\n\n\n\n数式が多い\nORは、問題を数理的にモデル化し、解析する学問です。数式をたくさん使い、証明も多いです。数式を読むのが苦手な人は、慣れるまで大変かもしれません。\nこの講義では、以下の工夫をしています。\n\n証明は省略なく丁寧に行います。\nわかりにくいところをコラムで補足します。",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#何を学ぶ",
    "href": "course-info.html#何を学ぶ",
    "title": "講義",
    "section": "何を学ぶ？",
    "text": "何を学ぶ？\n\n\nモデル：現実の問題を数理的に表現したもの\nモデリング：現実の問題を数理モデルで表現すること\n解：問題の答え\n最適化：最適解を見つけること\nアルゴリズム：問題を解く手順\n\n単に，結論・定理を覚えるだけでなく，モデリング，証明，アルゴリズムの理解が重要です。",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#python-について",
    "href": "course-info.html#python-について",
    "title": "講義",
    "section": "Python について",
    "text": "Python について\n\nすべてのアルゴリズム、モデルをPythonで実装します。\nPython の基礎については、この講義では説明しません。\nPython のコードを理解できなくても、授業内容の理解には支障ありません。\nYoutube などでは、2-3時間で Python 入門の動画がたくさんあります。事前に学習しておくことをお勧めします。",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#授業時間外の学習",
    "href": "course-info.html#授業時間外の学習",
    "title": "講義",
    "section": "授業時間外の学習",
    "text": "授業時間外の学習\n本授業の準備・復習等の授業時間外学習は、4時間を標準とする",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#私語",
    "href": "course-info.html#私語",
    "title": "講義",
    "section": "私語",
    "text": "私語\n\n講義中の私語は厳禁です．\n注意してもやめない場合は、減点を行います。",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#学生による授業改善アンケート",
    "href": "course-info.html#学生による授業改善アンケート",
    "title": "講義",
    "section": "学生による授業改善アンケート",
    "text": "学生による授業改善アンケート\n第14回の授業中に，以下のURLからアクセスして，授業改善アンケートに回答してください．\n学生による授業改善アンケート\n\nこのアンケートの目的は、授業の内容と方法を向上させることにあります。授業は学生のみなさんと教員とが協力してこそ、実り多いものとなります。\n回答内容が成績評価に影響することはありません。教員は回答の集計結果と自由記述回答のみを確認します。みなさんの学生証番号と個人名が担当教員に知られることはありません。\n責任のある回答にご協力ください。\nアクセスしにくい場合は、授業時間外でご回答ください。\nアンケート提出前に回答内容をよく確認してください。",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "course-info.html#期末試験2025",
    "href": "course-info.html#期末試験2025",
    "title": "講義",
    "section": "期末試験（2025）",
    "text": "期末試験（2025）\n\n試験時間：90分\n試験範囲：講義で扱ったすべての内容\n参照・使用できるもの\n\n電卓\n\n平方根，立方根の計算方法を確認しておいてください。\n\n公認カンニングペーパー（自筆，表面のみ）\n\n\n\n注意事項\n\n学生証：\n\n試験を受けるためには学生証の提示が必要です。\n\n携帯電話・スマートウォッチ等の通信機器：\n\nいかなる形態でも通信機器の使用は禁止しますので、電源を切り必ずかばん等にしまってください。\n時計や電卓の代用として使用することも出来ません。",
    "crumbs": [
      "講義"
    ]
  },
  {
    "objectID": "notation.html",
    "href": "notation.html",
    "title": "記号",
    "section": "",
    "text": "集合",
    "crumbs": [
      "記号"
    ]
  },
  {
    "objectID": "notation.html#集合",
    "href": "notation.html#集合",
    "title": "記号",
    "section": "",
    "text": "\\(A\\)\n\n集合。大文字で表す。\n\n\\(A \\setminus B\\)\n\n集合 \\(A\\) と集合 \\(B\\) の差集合。",
    "crumbs": [
      "記号"
    ]
  },
  {
    "objectID": "notation.html#線形代数",
    "href": "notation.html#線形代数",
    "title": "記号",
    "section": "線形代数",
    "text": "線形代数\n\n\n\n記号\n意味\n\n\n\n\n\\(\\mathbf{x}\\), \\(\\mathbf{y}\\)\nベクトル。太字の小文字で表す。\n\n\n\\(\\mathbf{A}\\), \\(\\mathbf{B}\\)\n行列。太字の大文字で表す。\n\n\n\\(\\mathbf{I}\\)\n単位行列。",
    "crumbs": [
      "記号"
    ]
  },
  {
    "objectID": "notation.html#確率統計",
    "href": "notation.html#確率統計",
    "title": "記号",
    "section": "確率統計",
    "text": "確率統計\n\\(X\\): 確率変数。大文字で表す。\n\\(\\mathbb{P}(X = x)\\): 確率変数 \\(X\\) が \\(x\\) をとる確率\n\\(\\mathbb{E}[X]\\): 確率変数 \\(X\\) の期待値\n\\(F_X(x)\\): 確率変数 \\(X\\) の累積分布関数\n\\(f_X(x)\\): 確率変数 \\(X\\) の確率密度関数\n\\(p_X(x)\\): 確率変数 \\(X\\) の確率質量関数\n\\(\\phi(z)\\): 標準正規分布の確率密度関数",
    "crumbs": [
      "記号"
    ]
  },
  {
    "objectID": "notation.html#関数",
    "href": "notation.html#関数",
    "title": "記号",
    "section": "関数",
    "text": "関数\n\\(A\\) は要素の間に順序が定義された集合とする。\n\\(\\max A\\): 集合 \\(A\\) の最大値。\n\\(\\min A\\): 集合 \\(A\\) の最小値。\n\\((x)^+\\): \\(x\\) と \\(0\\) のうち大きい方。すなわち、\\((x)^+ = \\max(x, 0)\\)。\n\\((x)^-\\): \\(x\\) と \\(0\\) のうち小さい方の絶対値。すなわち、\\((x)^- = \\max(-x, 0) = -\\min(x, 0)\\)。",
    "crumbs": [
      "記号"
    ]
  },
  {
    "objectID": "notation.html#例題",
    "href": "notation.html#例題",
    "title": "記号",
    "section": "例題",
    "text": "例題\n\n例 1 (差集合) \\(A = \\{1, 2, 3\\}\\)、\\(B = \\{2, 3, 4\\}\\) とする。このとき、\\(A \\setminus B = \\{1\\}\\) である。\n\n\n例 2 (最大値と最小値) \\(A = \\{1, 0, -1\\}\\) とする。このとき、\\(\\max A = 1\\)、\\(\\min A = -1\\) である。\n\n\n例 3 (正の部分) \\((10)^+ = 10\\)、\\((-30)^+ = 0\\) である。\n\n\n例 4 (負の部分) \\((10)^- = 0\\)、\\((-30)^- = 30\\) である。",
    "crumbs": [
      "記号"
    ]
  },
  {
    "objectID": "inventory/intro.html",
    "href": "inventory/intro.html",
    "title": "1  在庫管理とは",
    "section": "",
    "text": "1.1 在庫量\n商店・工場・倉庫などで、原材料・部品・製品などを適切に管理することを在庫管理（Inventory Management）という。一般的に、在庫管理の目的は、顧客の需要を満たしつつ、在庫に関わる費用を最小化することである。\n在庫量が多すぎると、保管費用がかかる。逆に、在庫量が少なすぎると、欠品が発生し、顧客の需要を満たせなくなる。在庫管理は次の二つの問題を決定する。\n科学的在庫管理（Scientific Inventory Management）では、これらの問題に答えるために、次の手順で在庫管理を行う。\n一般、\\(BO\\) と \\(OH\\) は次のように表される。\n\\[\nOH = I^+ = \\max(0, I)\n\\]\n\\[\nBO = I^- = \\max(0, -I)\n\\]",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>在庫管理とは</span>"
    ]
  },
  {
    "objectID": "inventory/intro.html#在庫量",
    "href": "inventory/intro.html#在庫量",
    "title": "1  在庫管理とは",
    "section": "",
    "text": "需要（demand）\n\nある期間に顧客が購入したい商品の量。通常、\\(d\\) で表す。\n\n手持ち在庫（on-hand inventory）\n\nある時点で、実際に手元にある在庫の量。\\(OH\\) で表す。\n\nバックオーダー（backorder）\n\n手持ち在庫がなく、満たせない需要。\\(BO\\) で表す。\n\n在庫量（inventory level）\n\nある時点での在庫の量。\\(I\\) で表す。\n\n\n\n\n\n\n例 1.1 手持ち在庫が \\(OH = 50\\)、需要が \\(d = 30\\) のとき、在庫量は次のように計算される。\n\\[\nI = 50 - 30 = 20\n\\]\n手持ち在庫が \\(OH = 50\\)、需要が \\(d = 70\\) のとき、在庫量は次のように計算される。\n\\[\nI = 50 - 70 = -20\n\\]\nこのとき、手持ち在庫は\n\\[\nOH = I^+ = \\max(0, I) = 0\n\\]\nとなる。バックオーダーは\n\\[\nBO = I^- = \\max(0, -I) = 20\n\\]\nとなる。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>在庫管理とは</span>"
    ]
  },
  {
    "objectID": "inventory/intro.html#在庫モデルの分類",
    "href": "inventory/intro.html#在庫モデルの分類",
    "title": "1  在庫管理とは",
    "section": "1.2 在庫モデルの分類",
    "text": "1.2 在庫モデルの分類\n在庫モデルは、次のような要素で分類される。\n\n需要（demand）\n\n需要が決定論的 (Deterministic) か確率的（Stochastic）か。\n\n観測（review）\n\n在庫量を連続観測 (Continuous Review) するか、周期観測 (Periodic Review) するか。連続観測の場合、在庫量が連続的に観測でき、いつでも発注が可能である。周期観測の場合、一定の期間（例えば1週間）ごとに在庫量を観測する。\n\nリードタイム（lead time）\n\n発注から納品までの期間。調達期間とも呼ばれる。リードタイムが決定論的か確率的か。また、リードタイムが0かどうか。在庫モデルを単純化するために、リードタイムを0とし、発注から納品までの期間を無視することもある。\n\nバックオーダー（backorder）\n\nバックオーダーが許容されるかどうか。需要が手持ち在庫を上回った場合、バックオーダーが許容されると、欠品が発生しても、後で需要を満たすことができる。バックオーダーが許容されない場合、欠品が発生すると、上回った需要は失われ、機会損失が発生する。\n\n計画期間（planning horizon）\n\n単一期間 (Single Period) か、複数期間 (Multi Period) か、無限 (Infinite) か。\n\n\n以下の表に、需要と観測に基づく、古典的な在庫モデルを示す。\n\n\n\n在庫モデル\n需要\n観測\n\n\n\n\nEOQモデル\n決定論的\n連続観測\n\n\nWagner-Whitin\n決定論的\n周期観測\n\n\n安全在庫\n確率的\n連続観測\n\n\n新聞売り子問題\n確率的\n周期観測",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>在庫管理とは</span>"
    ]
  },
  {
    "objectID": "inventory/intro.html#在庫の費用",
    "href": "inventory/intro.html#在庫の費用",
    "title": "1  在庫管理とは",
    "section": "1.3 在庫の費用",
    "text": "1.3 在庫の費用\nここでは、在庫に関わる費用を紹介する。\n\n発注費用（ordering cost）\n\n発注量に関わらず、1回の発注にかかる費用。調達費用、固定費用（fixed cost）などとも呼ばれる。通常、1回の発注にかかる費用を \\(K\\) とする。\n\n購入費用（purchase cost）\n\n商品を購入するためにかかる費用。通常、単位あたりの購入費用を \\(c\\) とする。\n\n欠品費用（stockout cost）\n\n需要が手持ち在庫を上回った場合に発生する費用。通常、単位あたりの欠品費用を \\(p\\) とする。\n\n保管費用（holding cost）\n\n在庫を保管するためにかかる倉庫費用、保険費用、税金、機会費用など。通常、単位時間あたりの1単位あたりの保管費用を \\(h\\) とする。\n\n\n\n例 1.2 (発注費用と購入費用) 毎回の発注量を \\(Q\\)、1回の発注にかかる費用を \\(K\\)、単位あたりの購入費用を \\(c\\) とする。1回の発注にかかる総費用は、次のように計算される。\n\\[\nK + cQ\n\\]\nとなる。\n\n\n例 1.3 (欠品費用) 在庫量を \\(I\\)、需要を \\(d\\)、単位あたりの欠品費用を \\(p\\) とする。欠品費用は次のように計算される。\n\\[\np (d - I)^+\n\\]\n\\(p = 10\\)、\\(I = 50\\)、\\(d = 70\\) のとき、欠品費用は次のように計算される。\n\\[\np (d - I)^+ = 10 (70 - 50)^+ = 200\n\\]\n\\(p = 10\\)、\\(I = 50\\)、\\(d = 20\\) のとき、欠品費用は次のように計算される。\n\\[\np (d - I)^+ = 10 (20 - 50)^+ = 0\n\\]\n\n\n\n例 1.4 (在庫量が一定の保管費用) 1日あたり1単位の在庫を保管するために、\\(h\\) の費用がかかるとする。30日間、50単位の在庫を保管するための総保管費用を計算せよ。\n保管費用は次のように計算される。 \\[\n30 \\times 50 \\times h = 1500h\n\\]\n下の図では、横軸が時間、縦軸が在庫量を表す。\n\n\nコード\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nt = np.linspace(0, 30, 1000)\ninventory = np.full_like(t, 50)\n\n# Plotting the inventory level\nplt.fill_between(t, inventory, color=\"lightgray\", alpha=0.5, label=\"Inventory Level\")\nplt.plot(t, inventory, label=\"Inventory Level\", color=\"black\", linewidth=2)\nplt.xlabel(\"Time\")\nplt.ylabel(\"Inventory Level\")\nplt.axhline(0, color=\"gray\", linewidth=1)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n一般的に、保管費用は次の式で計算される。\n\\[\n\\text{保管費用} = \\text{面積} \\times h\n\\]\n\n\n例 1.5 (在庫が時間とともに変化する保管費用) 通常、在庫量が定数ではなく、時間とともに変化する。ここでは、在庫量が時間とともに線形に減少し、0になると在庫が補充される場合を考える。毎回の発注量を \\(500\\) とする。\n下の図に示すように在庫量が時間とともに変化するとする。6 日間の保管費用を計算せよ。\n\n\nコード\n# Parameters\nd = 250  # Demand rate\nQ = 500  # Order quantity\nT = Q / d  # Cycle length\nt = np.linspace(0, 2.999 * T, 1000)\n\n# Inventory level over time\ninventory = np.maximum(0, Q - (d * t) % Q)\n\n# Plotting the inventory level\nplt.fill_between(t, inventory, color=\"lightgray\", alpha=0.5, label=\"Inventory Level\")\nplt.plot(t, inventory, label=\"Inventory Level\", color=\"black\", linewidth=2)\nplt.xlabel(\"Time\")\nplt.ylabel(\"Inventory Level\")\nplt.axhline(0, color=\"gray\", linewidth=1)\nplt.ylim(bottom=0, top=Q + 200)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n保管費用は \\(\\text{面積} \\times h\\) で計算される。それぞれの三角形の面積は \\(\\frac{1}{2} \\times 500 \\times 2\\) であるため、6 日間の保管費用は次のように計算される。\n\\[\n\\frac{2 \\times 500}{2} \\times 3 \\times h\n\\]",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>在庫管理とは</span>"
    ]
  },
  {
    "objectID": "inventory/intro.html#在庫方策",
    "href": "inventory/intro.html#在庫方策",
    "title": "1  在庫管理とは",
    "section": "1.4 在庫方策",
    "text": "1.4 在庫方策\n確率的在庫モデルにおいて、一つ重要な概念は在庫方策（inventory policy）である。在庫方策は、在庫の状況に応じて、在庫管理のルールを定めるものである。代表的な在庫方策を以下に示す。\n\n\\((r, Q)\\) 方策：在庫量を連続的に観測し、在庫量が発注点 \\(r\\) 以下になったときに発注量 \\(Q\\) を発注する方式である。発注点方式とも呼ばれる。\nBSP 方策（Base Stock Policy）：在庫量を定期的に観測し、在庫量が基準在庫 \\(S\\) 以下になったときに、在庫量を \\(S\\) まで補充する方式である。定期発注方式とも呼ばれる。\n\\((s, S)\\) 方策：在庫量を定期的に観測し、在庫量が発注点 \\(s\\) 以下になったときに、在庫量を補充点 \\(S\\) まで補充する方式である。\n\n一部の確率的在庫モデルにに対し、これらの在庫方策は最適であることが知られている。その場合、在庫方策が持つパラメータを最適化することで、在庫の期待コストを最小化することができる。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>在庫管理とは</span>"
    ]
  },
  {
    "objectID": "inventory/intro.html#練習問題",
    "href": "inventory/intro.html#練習問題",
    "title": "1  在庫管理とは",
    "section": "1.5 練習問題",
    "text": "1.5 練習問題\n\n在庫管理の目的は、_を満たしつつ、_を最小化することである。\n在庫管理の決定すべき二つの問題は、_と_である。\n在庫量 \\(I = -30\\)，需要 \\(d = 10\\) のとき、手持ち在庫 \\(OH\\) とバックオーダー \\(BO\\) を計算せよ。\n1回の発注にかかる費用 \\(K = 1000\\)、単位あたりの購入費用 \\(c = 50\\)、発注量 \\(Q = 200\\) のとき、3回の発注にかかる総費用を計算せよ。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>在庫管理とは</span>"
    ]
  },
  {
    "objectID": "inventory/eoq.html",
    "href": "inventory/eoq.html",
    "title": "2  経済的発注量",
    "section": "",
    "text": "2.1 記号\n経済的発注量（EOQ: Economic Order Quantity）モデルは，最も基本的な在庫管理モデルの一つである．Harris (1990) がこのモデルを最初に提案した．\nEOQモデルは，単位時間あたりの需要量は決定論的で，一定であると仮定する．すなわち，需要量は事前に分かっており，時間とともに変化しない．単位時間あたりの需要量は需要率（demand rate）と呼ばれ，記号 \\(d\\) で表される．リードタイムは0とし，発注から納品までの時間はないと仮定する．一回の発注量を \\(Q\\) とし，一定であるとする．欠品は許せないとする．全ての需要は満されなければならない．また，EOQモデルでは，在庫量は連続的に観測され，いつでも発注が可能であるとする．\n在庫に関わる費用は，1回あたりの発注費用 \\(K\\)，単位時間あたりの1単位の保管費用 \\(h\\) と，購入単価 \\(c\\) がある．\nEOQモデルの最適解は次の二つの性質を持つ(Snyder と Shen 2019)：\n以上の性質から，在庫量の時間的変化は下図のようになる．\n発注の間隔をサイクル(cycle)と呼び，サイクル期間は\n\\[\nT = \\frac{Q}{d}\n\\]\nで与えられる．",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>経済的発注量</span>"
    ]
  },
  {
    "objectID": "inventory/eoq.html#記号",
    "href": "inventory/eoq.html#記号",
    "title": "2  経済的発注量",
    "section": "",
    "text": "記号\n意味\n\n\n\n\n\\(d\\)\n単位時間あたりの需要量\n\n\n\\(K\\)\n1回あたりの発注費用\n\n\n\\(h\\)\n単位時間あたりの1単位の保管費用\n\n\n\\(c\\)\n購入単価\n\n\n\\(Q\\)\n発注量\n\n\n\\(T\\)\nサイクル期間\n\n\n\\(g(Q)\\)\n平均コスト",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>経済的発注量</span>"
    ]
  },
  {
    "objectID": "inventory/eoq.html#コスト関数",
    "href": "inventory/eoq.html#コスト関数",
    "title": "2  経済的発注量",
    "section": "2.2 コスト関数",
    "text": "2.2 コスト関数\nここでは，1サイクルあたりのコストを考える．\n発注費用：発注は1回だけ行うため，発注費用は \\(K\\) である．\n購入費用：\\(Q\\) 個の商品を単価 \\(c\\) で購入するため，購入費用は \\(cQ\\) である．\n保管費用：サイクル期間 \\(T\\) は \\(\\frac{Q}{d}\\) であるため，1サイクルあたりの保管費用は\n\\[\n\\frac{TQ}{2} h = \\frac{hQ^2}{2d}\n\\]\nとなる．\n以上より，1サイクルあたりのコストは次のように表される．\n\\[\nK + cQ + \\frac{hQ^2}{2d}\n\\]\n平均コストは，これをサイクル期間 \\(T\\) で割ったものとして定義される．したがって，平均コスト \\(g(Q)\\) は次のように表される．\n\\[\\begin{align*}\ng(Q) &= \\frac{1}{T} \\left( K + cQ + \\frac{hQ^2}{2d} \\right) \\\\\n&= \\frac{d}{Q} \\left( K + cQ + \\frac{hQ^2}{2d} \\right) \\\\\n&= \\frac{Kd}{Q} + c d + \\frac{hQ}{2}\n\\end{align*}\\]\n以上より，平均コストは発注量 \\(Q\\) の関数として次のように表される．\n\\[\ng(Q) = \\frac{Kd}{Q} + cd + \\frac{hQ}{2}\n\\]",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>経済的発注量</span>"
    ]
  },
  {
    "objectID": "inventory/eoq.html#最適発注量",
    "href": "inventory/eoq.html#最適発注量",
    "title": "2  経済的発注量",
    "section": "2.3 最適発注量",
    "text": "2.3 最適発注量\nEOQモデルの目的は，平均コスト \\(g(Q)\\) を最小化する発注量 \\(Q\\) を求めることである．\n平均コストの導関数 \\(g'(Q)\\) が 0 となる点を求めることで，最適発注量 \\(Q^*\\) を求めることができる．\n\\[\ng'(Q) = -\\frac{Kd}{Q^2} + \\frac{h}{2} = 0\n\\]\nこれを解くと，最適発注量\n\\[\nQ^* = \\sqrt{\\frac{2Kd}{h}}\n\\]\nを得る．これをEOQ公式（EOQ formula）と呼ぶ．\\(Q^*\\) を経済的発注量と呼ぶ（経済的は最適という意味である）．\n二階導関数 \\(g''(Q)\\) を求めて，最適発注量が最小値を与えることを確認する．\n\\[\ng''(Q) = \\frac{2Kd}{Q^3} &gt; 0\n\\]\n\\(g''(Q) &gt; 0\\) であるため，\\(Q^*\\) は最小値を与える．\n最適発注量 \\(Q^*\\) を次の定理にまとめる．\n\n定理 2.1 EOQモデルにおいて，最適発注量 \\(Q^*\\) は \\[\nQ^* = \\sqrt{\\frac{2Kd}{h}}\n\\tag{2.1}\\]\nで与えられる．\n\n\\(Q^*\\) を用いて，最適なサイクル期間 \\(T^*\\) を求めることができる．\n\\[\nT^* = \\frac{Q^*}{d} = \\sqrt{\\frac{2K}{hd}}\n\\tag{2.2}\\]\n式 2.1 と 式 2.2 から，以下の性質がわかる．\n\n\\(h\\) の増加に伴い，\\(Q^*\\) は減少する．保管費用が高い場合は，少量で高い頻度で発注することが望ましい．\n\\(K\\) の増加に伴い，\\(Q^*\\) は増加する．発注費用が高い場合は，多量で低い頻度で発注することが望ましい．\n\\(d\\) の増加に伴い，\\(Q^*\\) は増加する．\n\\(c\\) は \\(Q^*\\) に影響しない．購入単価は最適発注量に影響しない．\n\n次の図は，購入単価を \\(c = 0\\) とするとき，平均コスト \\(g(Q)\\)，発注コスト \\(\\frac{Kd}{Q}\\)，保管コスト \\(\\frac{hQ}{2}\\) のグラフを示す．\n\n\nコード\n# Parameters\nK = 40  # Order cost\nh = 10  # Holding cost\nd = 5  # Demand rate\nQ = np.linspace(1, 40, 400)  # Order quantity from 1 to 40\n\n# Cost calculations\norder_cost = K * d / Q\nholding_cost = (h * Q) / 2\naverage_cost = order_cost + holding_cost\noptimal_Q = np.sqrt(2 * K * d / h)\n\n# Plotting the costs\nplt.plot(Q, order_cost, label=r\"$Kd/Q$\", color=\"blue\")\nplt.plot(Q, holding_cost, label=r\"$hQ/2$\", color=\"orange\")\nplt.plot(Q, average_cost, label=r\"$g(Q)$\", color=\"green\", linewidth=2)\nplt.axvline(optimal_Q, color=\"red\", linestyle=\"--\", label=r\"$Q^*$\")\nplt.xlabel(\"Order Quantity Q\")\nplt.ylabel(\"Cost\")\nplt.ylim(bottom=0)\nplt.legend()\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n平均コストが最小となる発注量 \\(Q^*\\) は，発注コストと保管コストの交差点である．すなわち，発注コストと保管コストを等しくする発注量は最適な発注量 \\(Q^*\\) である．この性質は以下の式からわかる．\n\\[\n\\frac{Kd}{Q^*} = \\frac{hQ^*}{2} \\Longrightarrow Q^* = \\sqrt{\\frac{2Kd}{h}}\n\\]\nまた，この図からもわかるように，\\(Q\\) の増加に伴い，平均発注コストは減少し，平均保管コストは増加する．逆もまた然りである．\n\n例 2.2 ある電気量販店では，毎月250台のPCが販売されている．発注費用は5000円，保管費用は1台あたり月150円，購入単価は10万円とする．このとき，最適発注量 \\(Q^*\\) は次のように求められる．\n\\[\nQ^* = \\sqrt{\\frac{2 \\cdot 5000 \\cdot 250}{150}}\n\\]\nExcel では，下記のように計算できる．\n=SQRT(2 * 5000 * 250 / 150)\nPython では，次のようにeoq(K, d, h) 関数を定義し，最適発注量を計算できる．\n\ndef eoq(K, d, h):\n    \"\"\"\n    Calculate the Economic Order Quantity (EOQ).\n\n    Parameters:\n    K (float): Order cost\n    d (float): Demand rate\n    h (float): Holding cost\n\n    Returns:\n    float: Optimal order quantity Q*\n    \"\"\"\n    return np.sqrt(2 * K * d / h)\n\n\nif __name__ == \"__main__\":\n    K = 5000  # Order cost\n    d = 250  # Demand rate (units per month)\n    h = 150  # Holding cost (per unit per month)\n\n    Q_star = eoq(K, d, h)\n    T_star = Q_star / d\n    print(f\"Optimal Order Quantity (Q*): {Q_star:.2f}\")\n    print(f\"Optimal Cycle Time (T*): {T_star:.2f}\")\n\nOptimal Order Quantity (Q*): 129.10\nOptimal Cycle Time (T*): 0.52\n\n\nPCの場合は，注文量が整数である必要があるため，\\(g(129)\\) と \\(g(130)\\) を比較して最適発注量を決定する．",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>経済的発注量</span>"
    ]
  },
  {
    "objectID": "inventory/eoq.html#リードタイム",
    "href": "inventory/eoq.html#リードタイム",
    "title": "2  経済的発注量",
    "section": "2.4 リードタイム*",
    "text": "2.4 リードタイム*\nEOQ モデルでは，リードタイムは0と仮定している．リードタイムが \\(L &gt; 0\\) の場合も，最適発注量 \\(Q^*\\) も変換せず，\\(L\\) 期間前に \\(Q^*\\) を発注すればよい．\nここでは，\\(r\\) を発注点（reorder point）とする．在庫量が \\(r\\) になったときに発注を行う．リードタイム \\(L\\) の間に需要が \\(dL\\) 個あるため，発注点は次のように表される．\n\\[\nr = dL\n\\]\n\n例 2.3 上の例で，リードタイムが一週間とし，一か月を4週間とすると，リードタイムは \\(L = 1/4\\) となる．したがって，発注点は次のように求められる．\n\\[\nr = dL = 250 \\times \\frac{1}{4} = 62.5\n\\]\nPCの在庫量が63台になったときに発注を行う．",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>経済的発注量</span>"
    ]
  },
  {
    "objectID": "inventory/eoq.html#他のeoqモデル",
    "href": "inventory/eoq.html#他のeoqモデル",
    "title": "2  経済的発注量",
    "section": "2.5 他のEOQモデル*",
    "text": "2.5 他のEOQモデル*\n\nバックオーダーを考慮したEOQモデル\n数量割引（quantity discount）を考慮したEOQモデル\n\n総量割引（all-units discount）\n増分割引（incremental discount）",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>経済的発注量</span>"
    ]
  },
  {
    "objectID": "inventory/eoq.html#文献案内",
    "href": "inventory/eoq.html#文献案内",
    "title": "2  経済的発注量",
    "section": "2.6 文献案内",
    "text": "2.6 文献案内\nオペレーションズ・リサーチに関する教科書の多くは，EOQモデルを取り扱っている．モデルの分類から，「deterministic continuous-review inventory models」などの章で説明されていることが多い．\nリードタイムを考慮したEOQモデルについては，Snyder と Shen (2019) で説明されている．\n数量割引を考慮したEOQモデルについては，Snyder と Shen (2019) ，Camm ほか (2022) で説明されている．\nバックオーダーを考慮したEOQモデルについては，Snyder と Shen (2019) ，Camm ほか (2022) ，Hillier と Lieberman (2025) で説明されている．",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>経済的発注量</span>"
    ]
  },
  {
    "objectID": "inventory/eoq.html#練習問題",
    "href": "inventory/eoq.html#練習問題",
    "title": "2  経済的発注量",
    "section": "2.7 練習問題",
    "text": "2.7 練習問題\n\n練習 2.1 ある工場は，鋼材を毎日16トン消費し，年間250日稼働している．鋼材の購入単価は1トンあたり1100ドル，1回の発注にかかる固定費は5500ドル，保管費は鋼材1トンあたり年間は275ドルである．EOQモデルを用いて，次の問いに答えよ．\n\n最適な発注量を求めよ．\n最適なサイクル期間を求めよ．\n年間の平均費用を求めよ．\n\n\n\n解答 2.1. 需要率は \\(d = 4000\\) で，発注費用は \\(K = 5500\\)，保管費用は \\(h = 275\\)，購入単価は \\(c = 1100\\) である．\n経済的発注量 \\(Q^*\\) は\n\\[\nQ^* = \\sqrt{\\frac{2Kd}{h}} = \\sqrt{\\frac{2 \\cdot 5500 \\cdot 4000}{275}} = 400 \\text{ トン}\n\\]\nとなる．式 2.2 より，サイクル期間 \\(T^*\\) は\n\\[\nT^* = \\frac{Q^*}{d} = \\frac{400}{4000} = 0.1 \\text{ 年}\n\\]\nとなる．年間平均コスト \\(g(Q^*)\\) は \\[\ng(Q^*) = \\frac{Kd}{Q^*} + cd + \\frac{hQ^*}{2} = 4510000 \\text{ ドル}\n\\] となる．\n\n\nコード\nimport numpy as np\n\nK = 5500  # Order cost\nd = 4000  # Demand rate (units per year)\nh = 275  # Holding cost (per unit per year)\nc = 1100  # Purchase cost (per unit)\n\nQ_star = np.sqrt(2 * K * d / h)\nT_star = Q_star / d\ng_avg = (K * d / Q_star) + (c * d) + (h * Q_star / 2)\nprint(f\"Optimal Order Quantity (Q*): {Q_star:.2f} tons\")\nprint(f\"Optimal Cycle Time (T*): {T_star:.2f} years\")\nprint(f\"Average Annual Cost (g(Q*)): {g_avg:.2f} dollars\")\n\n\nOptimal Order Quantity (Q*): 400.00 tons\nOptimal Cycle Time (T*): 0.10 years\nAverage Annual Cost (g(Q*)): 4510000.00 dollars\n\n\n\n\n練習 2.2 ある家電量販店では，あるスマートフォンを毎週50台販売している．店舗はスマートフォンを1台あたりメーカーに10万円で購入している．毎回の発注には発注処理や配送などで5000円の固定費がかかる．また，スマートフォン1台あたりの保管費用は1週間で100円である．EOQモデルを用いて，次の問いに答えよ．\n\n最適な発注量を求めよ．\n最適なサイクル期間を求めよ．\n\n\n\n解答 2.2. 需要率は \\(d = 50\\) で，発注費用は \\(K = 5000\\)，保管費用は \\(h = 100\\) である．\n経済的発注量 \\(Q^*\\) は \\[\nQ^* = \\sqrt{\\frac{2Kd}{h}} = \\sqrt{\\frac{2 \\cdot 5000 \\cdot 50}{100}} \\approx 70.71 \\text{ 台}\n\\] となる．スマートフォンの場合は，注文量が整数である必要があるため，\\(g(70)\\) と \\(g(71)\\) を比較して最適発注量を決定する．\n\\[\ng(70) = \\frac{5000 \\cdot 50}{70} + 100 \\cdot 70 / 2 \\approx 7071.43\n\\] \\[\ng(71) = \\frac{5000 \\cdot 50}{71} + 100 \\cdot 71 / 2 \\approx 7071.13\n\\] \\(g(71) &lt; g(70)\\) であるため，最適発注量は \\(Q^* = 71\\) 台となる．\nサイクル期間 \\(T^*\\) は \\[\nT^* = \\frac{Q^*}{d} = \\frac{71}{50} = 1.42 \\text{ 週間}\n\\] となる．\n\n\nコード\nimport numpy as np\n\nK = 5000  # Order cost\nd = 50  # Demand rate (units per week)\nh = 100  # Holding cost (per unit per week)\nQ_star = np.sqrt(2 * K * d / h)\n\n\n# Since order quantity must be an integer, compare g(70) and g(71)\ndef g(Q):\n    return (K * d / Q) + (h * Q / 2)\n\n\ng_70 = g(70)\ng_71 = g(71)\noptimal_Q = 70 if g_70 &lt; g_71 else 71\nT_star = optimal_Q / d\nprint(f\"Optimal Order Quantity (Q*): {optimal_Q} units\")\nprint(f\"Optimal Cycle Time (T*): {T_star:.2f} weeks\")\n\n\nOptimal Order Quantity (Q*): 71 units\nOptimal Cycle Time (T*): 1.42 weeks\n\n\n\n\n\n\n\nCamm, Jeffrey, James Cochran, Michael Fry, Jeffrey Ohlmann, David Anderson, Dennis Sweeney, と Thomas Williams. 2022. An introduction to management science: Quantitative approaches to decision making. 16th 版. Florence, AL: South-Western College Publishing.\n\n\nHarris, Ford W. 1990. 「How many parts to make at once」. Oper. Res. 38 (6): 947–50.\n\n\nHillier, Frederick, と Gerald Lieberman. 2025. ISE introduction to operations research. 11th 版. Columbus, OH: McGraw-Hill Education.\n\n\nSnyder, Lawrence V, と Zuo-Jun Max Shen. 2019. Fundamentals of supply chain theory. 2nd 版. Nashville, TN: John Wiley & Sons.",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>経済的発注量</span>"
    ]
  },
  {
    "objectID": "inventory/safety.html",
    "href": "inventory/safety.html",
    "title": "3  安全在庫",
    "section": "",
    "text": "3.1 近似解法\n需要 \\(D\\) がある確率分布に従うと仮定する。リードタイムを \\(L\\) とし、既知の定数とする。発注費用を \\(K\\)、単位あたりの保管費用を \\(h\\) とする。在庫量が連続的に観測され、いつでも発注が可能であるとする連続観測の場合を考える。\n在庫管理には，\\((r, Q)\\) 方策が用いられるとする。在庫量が発注点 \\(r\\) 以下になったときに、発注量 \\(Q\\) を発注する。この場合、与えられたサービスレベルを満たすように、発注点 \\(r\\) と発注量 \\(Q\\) を決定することが目的である。\n単位期間あたりの需要を \\(D\\) とし、\\(D\\) は正規分布 \\(N(\\mu, \\sigma^2)\\) に従うと仮定する。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>安全在庫</span>"
    ]
  },
  {
    "objectID": "inventory/safety.html#近似解法",
    "href": "inventory/safety.html#近似解法",
    "title": "3  安全在庫",
    "section": "",
    "text": "ノート\n\n\n\nこの問題の定式化および厳密解法は、ここでは説明しない。Snyder と Shen (2019) の「Fundamentals of Supply Chain Theory」などの文献を参照されたい。 以下は \\((r, Q)\\) の近似解法を紹介する。\n\n\n\n\n3.1.1 発注量 \\(Q\\)\n\\(D\\) の平均需要 \\(\\mu\\) をEOQモデルの需要率とみなすと、発注量 \\(Q\\) は次のように求めることができる(Camm ほか 2022)。\n\\[\nQ = \\sqrt{\\frac{2K \\mu}{h}}\n\\]\n得られた発注量 \\(Q\\) は、最適解ではなく、近似解であることに注意されたい。\n\n例 3.2 単位期間あたりの需要 \\(D\\) が正規分布 \\(N(100, 20^2)\\) に従うと仮定する。発注費用 \\(K = 200\\)、単位あたりの保管費用 \\(h = 5\\) のとき、発注量 \\(Q\\) を求めよ。\n\\[\nQ = \\sqrt{\\frac{2K \\mu}{h}} = \\sqrt{\\frac{2 \\cdot 200 \\cdot 100}{5}} \\approx 89.44\n\\]\nPython では、以下のように計算できる。\n\n\nコード\nimport math\n\nK = 200\nh = 5\nmu = 100\nQ = math.sqrt((2 * K * mu) / h)\nprint(f\"order quantity: {Q:.2f}\")\n\n\norder quantity: 89.44\n\n\n\n\n\n3.1.2 発注点 \\(r\\)\nリードタイム期間中に発生する需要は \\(D_L \\sim N(\\mu_L, \\sigma_L^2)\\) とし、正規分布の再生性により、\n\\[\n\\mu_L = \\mu L, \\quad \\sigma_L^2 = \\sigma^2 L\n\\]\nになる。すなわち、リードタイム期間中の平均需要は \\(\\mu_L = \\mu L\\)、標準偏差は \\(\\sigma_L = \\sigma \\sqrt{L}\\) である。\n\n\n\n\n\n\nノート正規分布の再生性\n\n\n\n\\(X_1, X_2, \\ldots, X_n\\) が独立に同一の正規分布 \\(N(\\mu, \\sigma^2)\\) に従うならば、\\(Y = X_1 + X_2 + \\cdots + X_n\\) は正規分布 \\(N(n\\mu, n\\sigma^2)\\) に従う。\n\n\n\n例 3.3 単位期間あたりの需要 \\(D\\) が正規分布 \\(N(100, 20^2)\\) に従うと仮定する。リードタイム \\(L = 4\\) のとき、リードタイム期間中の平均需要 \\(\\mu_L\\) と標準偏差 \\(\\sigma_L\\) を求めよ。\n\\[\n\\mu_L = \\mu L = 100 \\cdot 4 = 400\n\\]\n\\[\n\\sigma_L = \\sigma \\sqrt{L} = 20 \\sqrt{4} = 40\n\\]\nこれにより，リードタイム期間中の需要 \\(D_L\\) は正規分布 \\(N(400, 40^2)\\) に従うことがわかる。\n\n発注点 \\(r\\) を決めるためには、サービスレベル（service level）を考える。ここでは、サービスレベルを、リードタイム期間中に需要を満たす確率と定義する。サービスレベルを \\(\\alpha\\) とし、\\(0 &lt; \\alpha &lt; 1\\) とする。\n与えられたサービスレベル \\(\\alpha\\) に対して、\\(D_L\\) が発注点 \\(r\\) 以下になる確率（欠品が発生しない確率、つまり、サービスレベル）が \\(\\alpha\\) になるように発注点 \\(r\\) を決定する。\n\\[\nP(D_L \\leq r) = \\alpha\n\\]\nもし、発注点 \\(r = \\mu_L\\) とすると、\\(P(D_L \\leq \\mu_L) = 0.5\\) となる。すなわち、50% の確率で欠品が発生することになる。\n\n\n\n\n\n\nノート\n\n\n\n\\[\nP(D_L \\leq \\mu_L) = P\\left(\\frac{D_L - \\mu_L}{\\sigma_L} \\leq 0\\right) = \\Phi(0) = 0.5\n\\]\n\n\nしたがって、サービスレベル \\(\\alpha &gt; 0.5\\) の場合、発注点 \\(r\\) は平均需要 \\(\\mu_L\\) より大きくなる必要がある。\\(r - \\mu_L\\) を安全在庫（safety stock）と呼び、\\(s\\) と表す。\n\\[\ns = r - \\mu_L\n\\]\nこの式を変形すると、発注点 \\(r\\) は次のように表される。\n\\[\nr = \\mu_L + s\n\\]\n従って、サービスレベル \\(P(D_L \\leq r) = \\alpha\\) は次のように表される。\n\\[\nP(D_L \\leq \\mu_L + s) = \\alpha\n\\]\n与えられたサービスレベル \\(\\alpha\\) に対して、安全在庫 \\(s\\) を求めることを考える。ここで、\\(s \\geq 0\\) とする。\n\\[\\begin{align}\nP(D_L - \\mu_L \\leq s) &= \\alpha \\\\\nP\\left(\\frac{D_L - \\mu_L}{\\sigma_L} \\leq \\frac{s}{\\sigma_L}\\right) &= \\alpha \\\\\n\\Phi\\left(\\frac{s}{\\sigma_L}\\right) &= \\alpha \\\\\n\\frac{s}{\\sigma_L} &= \\Phi^{-1}(\\alpha) \\\\\ns &= \\sigma_L \\Phi^{-1}(\\alpha) \\\\\ns &= \\sigma \\sqrt{L} \\Phi^{-1}(\\alpha)\n\\end{align}\\]\nここで、\\(\\Phi(\\cdot)\\) は標準正規分布の累積分布関数であり、\\(\\Phi^{-1}(\\alpha)\\) はその逆関数である。したがって、発注点 \\(r\\) は次のように表される。\n\\[\nr = \\mu_L + s = \\mu L + \\sigma \\sqrt{L} \\Phi^{-1}(\\alpha)\n\\]\n\\(\\Phi^{-1}(\\alpha)\\) は標準正規分布表、Excel、Python などを用いて求めることができる。\n\n例 3.4 単位期間あたりの需要 \\(D\\) が正規分布 \\(N(100, 20^2)\\) に従うと仮定する。リードタイム \\(L = 4\\)、発注点 \\(r = 500\\) のとき、安全在庫 \\(s\\) とサービスレベル \\(\\alpha\\) を求めよ。\nリードタイム期間中の平均需要は \\(\\mu_L = 400\\) である。したがって、安全在庫 \\(s\\) は次のように求められる。 \\[\ns = r - \\mu_L = 500 - 400 = 100\n\\]\nサービスレベル \\(\\alpha\\) は次のように求められる。\n\\[\n\\alpha = P(D_L \\leq r) = \\Phi\\left(\\frac{r - \\mu_L}{\\sigma_L}\\right) = \\Phi\\left(\\frac{100}{40}\\right) = \\Phi(2.5) \\approx 0.99379\n\\]\n発注点 \\(r = 500\\) のとき、安全在庫 \\(s\\) は100、サービスレベル \\(\\alpha\\) は約 99.379% である。\n\n\n例 3.5 リードタイム \\(L = 4\\)、平均需要 \\(\\mu = 100\\)、需要の標準偏差 \\(\\sigma = 20\\)、サービスレベル \\(\\alpha = 0.95\\) のとき、発注点 \\(r\\) と安全在庫 \\(s\\) を求める。\nリードタイム期間中の平均需要と標準偏差は次のように計算される。\n\\[\\begin{align}\n\\mu_L &= \\mu L = 100 \\cdot 4 = 400 \\\\\n\\sigma_L &= \\sigma \\sqrt{L} = 20 \\sqrt{4} = 40 \\\\\n\\end{align}\\]\n標準正規分布表から \\(\\Phi^{-1}(0.95) \\approx 1.64485\\) を得る。これを用いて安全在庫 \\(s\\) と発注点 \\(r\\) を求める。\n\\[\\begin{align}\ns &= \\sigma_L \\Phi^{-1}(0.95) \\approx 40 \\cdot 1.64485 \\approx 65.79 \\\\\nr &= \\mu_L + s \\approx 400 + 65.79 \\approx 465.79\n\\end{align}\\]\nしたがって、発注点 \\(r\\) は約465.79、必要な安全在庫 \\(s\\) は約65.79となる。\nPython では、以下のように計算できる。\n\n\nコード\nfrom scipy.stats import norm\n\nL = 4\nmu = 100\nsigma = 20\nalpha = 0.95\n\nmu_L = mu * L\nsigma_L = sigma * (L ** 0.5)\n\ns = sigma_L * norm.ppf(alpha)\nr = mu_L + s\n\nprint(f\"reorder point: {r:.2f},  safety stock: {s:.2f}\")\n\n\nreorder point: 465.79,  safety stock: 65.79",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>安全在庫</span>"
    ]
  },
  {
    "objectID": "inventory/safety.html#欠品費用を考慮する場合",
    "href": "inventory/safety.html#欠品費用を考慮する場合",
    "title": "3  安全在庫",
    "section": "3.2 欠品費用を考慮する場合*",
    "text": "3.2 欠品費用を考慮する場合*\nまた、欠品費用も考慮する場合、バックオーダーを考慮した EOQ モデルを用いて、発注量 \\(Q\\) は次のように求めることができる(Hillier と Lieberman 2025)。\n\\[\nQ = \\sqrt{\\frac{2K \\mu}{h}} \\sqrt{\\frac{p+h}{p}}\n\\]\n\\(p\\) は単位あたりの欠品費用である。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>安全在庫</span>"
    ]
  },
  {
    "objectID": "inventory/safety.html#文献案内",
    "href": "inventory/safety.html#文献案内",
    "title": "3  安全在庫",
    "section": "3.3 文献案内",
    "text": "3.3 文献案内",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>安全在庫</span>"
    ]
  },
  {
    "objectID": "inventory/safety.html#練習問題",
    "href": "inventory/safety.html#練習問題",
    "title": "3  安全在庫",
    "section": "3.4 練習問題",
    "text": "3.4 練習問題\n\n練習 3.1 ある会社は、A商品を販売している。\\((r, Q)\\) 方策に基づいて在庫管理を行っている。毎日の需要 \\(D\\) は正規分布 \\(N(150, 30^2)\\) に従う。商品を発注するための固定費用は \\(K = 300\\)、単位あたりの保管費用は \\(h = 4\\)，購入単価は \\(c = 20\\) である。リードタイムは \\(L = 4\\) 日である。この会社は，90% のサービスレベルを目標としている。このとき、発注量 \\(Q\\)、発注点 \\(r\\)、必要な安全在庫 \\(s\\) を求めよ。\n\n\n解答 3.1. 発注量 \\(Q\\) は次のように求められる。\n\\[\nQ = \\sqrt{\\frac{2K \\mu}{h}} = \\sqrt{\\frac{2 \\cdot 300 \\cdot 150}{4}} = 150\n\\]\nリードタイム期間中の平均需要と標準偏差は次のように計算される。\n\\[\n\\mu_L = \\mu L = 150 \\cdot 4 = 600\n\\]\n\\[\n\\sigma_L = \\sigma \\sqrt{L} = 30 \\sqrt{4} = 60\n\\]\n標準正規分布表から \\(\\Phi^{-1}(0.9) \\approx 1.28155\\) を得る。これを用いて安全在庫 \\(s\\) と発注点 \\(r\\) を求める。\n\\[\ns = \\sigma_L \\Phi^{-1}(0.9) \\approx 60 \\cdot 1.28155 \\approx 76.89\n\\]\n\\[\nr = \\mu_L + s \\approx 600 + 76.89 \\approx 676.89\n\\]\nしたがって、発注量 \\(Q\\) は150、発注点 \\(r\\) は約676.89、必要な安全在庫 \\(s\\) は約76.89となる。\n\n\nコード\nimport math\nfrom scipy.stats import norm\nK = 300\nh = 4\nmu = 150\nsigma = 30\nL = 4\nalpha = 0.9\nQ = math.sqrt((2 * K * mu) / h)\nmu_L = mu * L\nsigma_L = sigma * (L ** 0.5)\ns = sigma_L * norm.ppf(alpha)\nr = mu_L + s\nprint(f\"order quantity: {Q:.2f}, reorder point: {r:.2f},  safety stock: {s:.2f}\")\n\n\norder quantity: 150.00, reorder point: 676.89,  safety stock: 76.89\n\n\n\n\n\n\n\nCamm, Jeffrey, James Cochran, Michael Fry, Jeffrey Ohlmann, David Anderson, Dennis Sweeney, と Thomas Williams. 2022. An introduction to management science: Quantitative approaches to decision making. 16th 版. Florence, AL: South-Western College Publishing.\n\n\nHillier, Frederick, と Gerald Lieberman. 2025. ISE introduction to operations research. 11th 版. Columbus, OH: McGraw-Hill Education.\n\n\nSnyder, Lawrence V, と Zuo-Jun Max Shen. 2019. Fundamentals of supply chain theory. 2nd 版. Nashville, TN: John Wiley & Sons.",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>安全在庫</span>"
    ]
  },
  {
    "objectID": "inventory/wagner-whitin.html",
    "href": "inventory/wagner-whitin.html",
    "title": "4  Wagner-Whitin モデル",
    "section": "",
    "text": "記号\n意味\n\n\n\n\n\\(\\mathcal{T}\\)\n期間の集合、\\(\\mathcal{T} = \\{1, 2, \\ldots, T\\}\\)\n\n\n\\(K\\)\n1回あたりの発注費用\n\n\n\\(h\\)\n単位あたりの保管費用\n\n\n\\(d_t\\)\n第 \\(t\\) 期の需要量\n\n\n\\(q_t\\)\n第 \\(t\\) 期の発注量\n\n\n\\(x_t\\)\n第 \\(t\\) 期の在庫量\n\n\n\\(y_t\\)\n第 \\(t\\) 期に発注する場合は 1、しない場合は 0\n\n\n\\(M\\)\n非負の大きな数\n\n\n\nWagner-Whitin モデルは次のように定式化される。\n\\[\\begin{align}\n\\text{minimize} \\quad & \\sum_{t=1}^{T} (K y_t + h x_t) \\\\\n\\text{subject to} \\quad & x_t = x_{t-1} + q_t - d_t \\quad & \\forall t \\in \\mathcal{T} \\\\\n& q_t \\geq 0 \\quad & \\forall t \\in \\mathcal{T} \\\\\n& q_t \\leq M y_t \\quad & \\forall t \\in \\mathcal{T} \\\\\n& x_t \\geq 0 \\quad & \\forall t \\in \\mathcal{T} \\\\\n& y_t \\in \\{0, 1\\} \\quad & \\forall t \\in \\mathcal{T}\n\\end{align}\\]",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Wagner-Whitin モデル</span>"
    ]
  },
  {
    "objectID": "inventory/newsvendor.html",
    "href": "inventory/newsvendor.html",
    "title": "5  新聞売り子問題",
    "section": "",
    "text": "5.1 記号\nこれまで紹介した EOQ 在庫モデルは、需要が決定論的であると仮定していた。ここからは、需要が確率的であると仮定した在庫モデルを紹介する。\n新聞売り子問題（Newsvendor Problem）は，古典的な確率的在庫モデルの一つである。新聞は次の日には売れなくなるため，新聞売り子問題は最も単純な perishable 在庫モデルとして知られている。新聞に限らず，食品や花などの生鮮品の在庫管理にも応用される。\n新聞売り子が新聞を仕入れ，販売する問題を考える。新聞 1 部の欠品費用を \\(p\\)，保管費用を \\(h\\) とする。新聞売子問題において，\\(p\\) を在庫不足費用（underage cost），\\(h\\) を在庫超過費用（overage cost）とも呼ぶ。\\(p \\gt 0\\)，\\(h \\gt 0\\) とし，初期在庫は 0 とする。\n新聞の需要 \\(D\\) を確率変数とするとき，新聞売り子はどれだけの新聞を発注すればよいかという問題である。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>新聞売り子問題</span>"
    ]
  },
  {
    "objectID": "inventory/newsvendor.html#記号",
    "href": "inventory/newsvendor.html#記号",
    "title": "5  新聞売り子問題",
    "section": "",
    "text": "記号\n意味\n\n\n\n\n\\(h\\)\n1 個当たりの在庫超過費用\n\n\n\\(p\\)\n1 個当たりの在庫不足費用\n\n\n\\(D\\)\n需要（確率変数）\n\n\n\\(d\\)\n需要の観測値\n\n\n\\(f_D(d)\\)\n需要 \\(D\\) の確率密度関数\n\n\n\\(F_D(d)\\)\n需要 \\(D\\) の累積分布関数\n\n\n\\(S\\)\n発注量\n\n\n\\(g(S, d)\\)\n発注量 \\(S\\)，需要の観測値 \\(d\\) に対するコスト\n\n\n\\(g(S)\\)\n\\(g(S, d)\\) の期待値，\\(g(S) = \\mathbb{E}[g(S, D)]\\)",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>新聞売り子問題</span>"
    ]
  },
  {
    "objectID": "inventory/newsvendor.html#定式化",
    "href": "inventory/newsvendor.html#定式化",
    "title": "5  新聞売り子問題",
    "section": "5.2 定式化",
    "text": "5.2 定式化\n新聞売り子が \\(S\\) 部の新聞を仕入れ，需要 \\(D\\) が \\(d\\) であったとする。このとき，新聞売り子のコスト \\(g(S, d)\\) は以下のように表される。\n\\[\ng(S, d) = h (S - d)^+ + p (d - S)^+\n\\tag{5.1}\\]\n\n例 5.2 発注量 \\(S = 100\\)，需要 \\(D\\) の観測値 \\(d = 120\\)，在庫超過費用が \\(h = 10\\)，在庫不足費用が \\(p = 5\\) のとき，コスト \\(g(S, d)\\) は以下のように求められる。\n\\[\ng(100, 120) = 10 (100 - 120)^+ + 5 (120 - 100)^+ = 100\n\\]\n\n観測値 \\(d\\) が分かれば，コスト \\(g(S, d)\\) を計算できる。しかし，需要 \\(D\\) が確率変数であることを思い出そう。ここからは，需要 \\(D\\) が連続型確率変数であると仮定する。\n需要 \\(D\\) の確率密度関数を \\(f_D(d)\\)，累積分布関数を \\(F_D(d)\\) とする。発注量を \\(S\\) としたとき，需要 \\(D \\leq S\\) である確率は，累積分布関数 \\(F_D(S)\\) で与えられる。\n\\[\nP(D \\leq S) = F_D(S) = \\int_{0}^{S} f_D(d) dd\n\\tag{5.2}\\]\n\n例 5.3 需要 \\(D\\) が一様分布 \\(U(100,300)\\) に従うとき，確率密度関数 \\(f_D(250)\\) と累積分布関数 \\(F_D(250)\\) は以下のように表される。\n\nコード\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import uniform\n\n# 一様分布のパラメータ\na = 100\nb = 300\n# 需要の範囲\nd = np.linspace(a - 50, b + 50, 1000)\n# plot pdf with shaded area\nplt.figure(figsize=(4, 4))\nplt.plot(d, uniform.pdf(d, a, b - a))\nplt.fill_between(\n    d,\n    0,\n    uniform.pdf(d, a, b - a),\n    where=(d &lt;= 250),\n    color=\"skyblue\",\n    alpha=0.5,\n    label=\"F(250)\",\n)\nplt.xlabel(r\"$D$\")\nplt.ylabel(r\"$f_D(d)$\")\nplt.xlim(a - 50, b + 50)\nplt.ylim(0, 0.006)\nplt.show()\n\n# plot cdf\nplt.figure(figsize=(4, 4))\nplt.plot(d, uniform.cdf(d, a, b - a))\nplt.axvline(250, color=\"r\", linestyle=\"--\", label=\"d=250\")\nplt.xlabel(r\"$D$\")\nplt.ylabel(r\"$F_D(d)$\")\nplt.xlim(a - 50, b + 50)\nplt.ylim(0, 1.1)\nplt.show()\n\n\n\n\n\n\n\n確率密度関数 \\(f_D(d)\\)\n\n\n\n\n\n\n\n累積分布関数 \\(F_D(d)\\)\n\n\n\n\n\n需要 \\(D \\leq 250\\) である確率は，累積分布関数 \\(F_D(250)\\) で与えられる。\n\\[\nP(D \\leq 250) = F_D(250) = \\int_{100}^{250} f_D(d) dd = 0.75\n\\]\n需要 \\(D &gt; 250\\) である確率は \\(1 - F_D(250)\\) で与えられる。\n\\[\nP(D &gt; 250) = 1 - F_D(250) = 1 - \\int_{100}^{250} f_D(d) dd = 0.25\n\\]\n\n\\(D\\) が確率変数であるため，コストも確率変数となる。新聞売り子問題の目的は，コストの期待値を最小化することである。\nここで，コストの期待値を \\(g(S) = \\mathbb{E}[g(S, D)]\\) とする。\\(g(S, D)\\) は 式 5.1 で与えられるため，コストの期待値 \\(g(S)\\) は以下のように表される。\n\\[\\begin{align}\ng(S) &= \\mathbb{E}[g(S, D)] \\\\\n&= \\mathbb{E}[h (S - D)^+ + p (D - S)^+] \\\\\n&= \\mathbb{E}[h (S - D)^+] + \\mathbb{E}[p (D - S)^+] \\\\\n&= h \\mathbb{E}[(S - D)^+] + p \\mathbb{E}[(D - S)^+] \\\\\n\\end{align}\\]\nこの式により，コストの期待値 \\(g(S)\\) は，\\((S - D)^+\\) の期待値かける在庫超過費用 \\(h\\) と，\\((D - S)^+\\) の期待値かける在庫不足費用 \\(p\\) の和であることが分かる。\n\n\n\n\n\n\nノート期待値の線形性（Linearity of Expectation）\n\n\n\n\\(X\\) と \\(Y\\) を確率変数，\\(a\\) と \\(b\\) を定数とする。このとき，\n\\[\n\\mathbb{E}[X + Y] = \\mathbb{E}[X] + \\mathbb{E}[Y]\n\\]\n\\[\n\\mathbb{E}[aX + b] = a\\mathbb{E}[X] + b\n\\]\nが成り立つ。\n\n\n需要 \\(D\\) が連続型確率変数であるため，\\(\\mathbb{E}[(S - D)^+]\\) と \\(\\mathbb{E}[(D - S)^+]\\) は以下のように表される。 \\[\\begin{align}\n\\mathbb{E}[(S - D)^+]\n&= \\int_{0}^{\\infty} (S - d)^+ f_D(d) dd = \\int_{0}^{S} (S - d) f_D(d) dd \\\\\n\\mathbb{E}[(D - S)^+]\n&= \\int_{0}^{\\infty} (d - S)^+ f_D(d) dd = \\int_{S}^{\\infty} (d - S) f_D(d) dd\n\\end{align}\\]\n\n\n\n\n\n\nノート連続型確率変数の期待値\n\n\n\n\\(X\\) を連続型確率変数，\\(f_X(x)\\) を \\(X\\) の確率密度関数とする。このとき，\\(X\\) の期待値 \\(\\mathbb{E}[X]\\) は以下のように表される。\n\\[\n\\mathbb{E}[X] = \\int_{-\\infty}^{\\infty} x f_X(x) dx\n\\]\n\\(\\mathbb{E}[g(X)]\\) は以下のように表される。\n\\[\n\\mathbb{E}[g(X)] = \\int_{-\\infty}^{\\infty} g(x) f_X(x) dx\n\\]\n\n\nしたがって，コストの期待値 \\(g(S)\\) は以下のように表される。\n\\[\\begin{align}\ng(S) &= \\mathbb{E}[g(S, D)] \\\\\n&= h \\mathbb{E}[(S - D)^+] + p \\mathbb{E}[(D - S)^+] \\\\\n&= h \\int_{0}^{S} (S - d) f_D(d) dd + p \\int_{S}^{\\infty} (d - S) f_D(d) dd\n\\end{align}\\]\n\n例 5.4 在庫超過費用が \\(h = 10\\)，在庫不足費用が \\(p = 5\\) のとき，発注量 \\(S = 150\\) に対するコストの期待値 \\(g(150)\\) は以下のように求められる。\n\\[\ng(150) = 10 \\int_{0}^{150} (150 - d) f_D(d) dd + 5 \\int_{150}^{\\infty} (d - 150) f_D(d) dd\n\\]",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>新聞売り子問題</span>"
    ]
  },
  {
    "objectID": "inventory/newsvendor.html#最適化",
    "href": "inventory/newsvendor.html#最適化",
    "title": "5  新聞売り子問題",
    "section": "5.3 最適化",
    "text": "5.3 最適化\n以上の議論から，新聞売り子問題は，コストの期待値 \\(g(S)\\) を最小化する発注量 \\(S\\) を求める問題に帰着される。手順は以下の通りである。\n\n\\(g(S)\\) の1階微分を求める。\n\\(dg(S)/dS = 0\\) を解く。\n2階微分を求め，\\(g(S)\\) が凸関数であることを確認する。\n\n式 5.2 を用い，\\(g(S)\\) の1階微分は以下のように求める。\n\\[\\begin{align}\n\\frac{dg(S)}{dS} &= h \\int_{0}^{S} f_D(d) dd - p \\int_{S}^{\\infty} f_D(d) dd \\\\\n&= h F_D(S) - p (1 - F_D(S)) \\\\\n\\end{align}\\]\nよって，\\(dg(S)/dS = 0\\) から，\n\\[\\begin{align}\nh F_D(S) - p (1 - F_D(S)) &= 0 \\\\\nF_D(S) &= \\frac{p}{h + p}\n\\end{align}\\]\nになる。2 階微分は\n\\[\\begin{align}\n\\frac{d^2g(S)}{dS^2} &= h f_D(S) + p f_D(S) \\\\\n&= (h + p) f_D(S) &gt; 0\n\\end{align}\\]\nである。したがって，コスト関数 \\(g(S)\\) は凸関数であり，1 階微分が 0 になる点は最小値を与える。\n\n\n\n\n\n\nヒント\n\n\n\n\\(p &gt; 0\\)，\\(h &gt; 0\\)，\\(f_D(S) &gt; 0\\) より，\\((h + p) f_D(S) &gt; 0\\) が成り立つ。\n\n\nコスト関数 \\(g(S)\\) を最小化するための最適発注量 \\(S^*\\) は\n\\[\nS^* = F_D^{-1}\\left(\\frac{p}{h + p}\\right)\n\\]\nとなる。ここで，\\(F_D^{-1}\\) は需要 \\(D\\) の累積分布関数の逆関数である。\n\n\n\n\n\n\nノート逆関数（Inverse Function）\n\n\n\nある関数 \\(y = f(x)\\) に対し，次の条件を満たす関数 \\(x = f^{-1}(y)\\) を \\(f(x)\\) の逆関数と呼ぶ。\n\\[\nf(f^{-1}(y)) = y, \\quad f^{-1}(f(x)) = x\n\\]\n\n\n\n定理 5.1 新聞売り子問題における最適発注量 \\(S^*\\) は，\n\\[\nS^* = F_D^{-1}\\left(\\frac{p}{h + p}\\right)\n\\]\nで与えられる。\n\n\n5.3.1 正規分布の場合\n需要 \\(D\\) が正規分布 \\(N(\\mu, \\sigma^2)\\) に従うとき，新聞売り子問題の最適発注量 \\(S^*\\) は以下の式を満たす。\n\\[\nF_D(S^*) = \\Phi\\left(\\frac{S^* - \\mu}{\\sigma}\\right) = \\frac{p}{h + p}\n\\]\nここで，\n\\[\nz = \\Phi^{-1}\\left(\\frac{p}{h + p}\\right)\n\\]\nとおくと，\n\\[\nS^* = \\sigma z + \\mu\n\\]\nで与えられる。標準正規分布表を用いて \\(z\\) を調べることができる。\n\n\n\n\n\n\nノート標準正規分布（Standard Normal Distribution）\n\n\n\n平均 0，分散 1 の正規分布を標準正規分布（standard normal distribution）と呼ぶ。標準正規分布に従う確率変数を \\(Y\\) とすると，\\(Y \\sim N(0, 1)\\) と表される。標準正規分布の確率密度関数を \\(\\phi(z)\\)，累積分布関数を \\(\\Phi(z)\\) と表す。\n与えられた \\(X \\sim N(\\mu, \\sigma^2)\\) の累積分布関数 \\(F_X(x)\\) の値を求めるには，以下のように変換する。\n\\[\\begin{align}\nF_X(x) &= P(X \\leq x) \\\\\n&= P \\left( \\frac{X - \\mu}{\\sigma} \\leq \\frac{x - \\mu}{\\sigma} \\right) \\\\\\\\\n&= P\\left( Y \\leq \\frac{x - \\mu}{\\sigma} \\right) \\\\\\\\\n&= \\Phi \\left( \\frac{x - \\mu}{\\sigma} \\right)\n\\end{align}\\]\n与えられた \\(z\\) に対し，\\(\\Phi(z)\\) の値は標準正規分布表（standard normal table）を用いて調べることができる。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>新聞売り子問題</span>"
    ]
  },
  {
    "objectID": "inventory/newsvendor.html#臨界率",
    "href": "inventory/newsvendor.html#臨界率",
    "title": "5  新聞売り子問題",
    "section": "5.4 臨界率",
    "text": "5.4 臨界率\n以上の議論から，最適発注量 \\(S^*\\) は以下の式を満たす。\n\\[\nF_D(S) = P(D \\leq S) = \\frac{p}{h + p}\n\\]\nここで，\\(F_D(S) = P(D \\leq S)\\) は需要 \\(D\\) が発注量 \\(S\\) 以下である確率を表す。言い換えると，欠品が発生しない確率を表す。この確率のことはサービスレベル（service level）と呼ぶ。定理 5.1 は，サービスレベルを \\(p/(h+p)\\) に等しくする発注量 \\(S\\) が最適であることを示している。\nこの \\(p/(h+p)\\) は臨界率（critical ratio）と呼ばれる。\n\n注釈 5.1. \n\n在庫不足費用 \\(p\\) の増加に伴い，サービスレベル \\(p/(h+p)\\) は増加し，最適発注量 \\(S^* = F_D^{-1}(p/(h+p))\\) も増加する。\n在庫超過費用 \\(h\\) の増加に伴い，サービスレベル \\(p/(h+p)\\) は減少し，最適発注量 \\(S^* = F_D^{-1}(p/(h+p))\\) も減少する。\n直感的に，在庫不足費用が増加すると，欠品を避けるために発注量が増加し，サービスレベルも上昇する。一方，在庫超過費用が増加すると，過剰在庫を避けるために発注量が減少し，サービスレベルも低下する。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>新聞売り子問題</span>"
    ]
  },
  {
    "objectID": "inventory/newsvendor.html#例題",
    "href": "inventory/newsvendor.html#例題",
    "title": "5  新聞売り子問題",
    "section": "5.5 例題",
    "text": "5.5 例題\n\n例 5.5 需要 \\(D\\) が正規分布 \\(N(100, 25)\\) に従う新聞売り子問題を考える。在庫超過費用が \\(h = 10\\)，在庫不足費用が \\(p = 40\\) のとき，最適発注量 \\(S^*\\) を求める。\n定理 5.1 より，\\(S^*\\) は以下の式で与えられる。\n\\[\nS^* = F_D^{-1}\\left(\\frac{p}{h + p}\\right) = F_D^{-1}\\left(\\frac{40}{10 + 40}\\right) = F_D^{-1}\\left(0.8\\right)\n\\]\n言い換えると，\\(F_D(S^*) = 0.8\\) を満たす \\(S^*\\) を求めればよい。これを図で表すと，面積が 0.8 になるような \\(S^*\\) を求めることに相当する。\n\n\nコード\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import norm\n\n# 正規分布のパラメータ\nmu = 100\nsigma = 5\n\n# 需要の範囲\nd = np.linspace(mu - 4 * sigma, mu + 4 * sigma, 1000)\nS_star = norm.ppf(0.8, loc=mu, scale=sigma)\n\n# plot the normal distribution\nplt.plot(d, norm.pdf(d, mu, sigma))\nplt.fill_between(\n    d,\n    0,\n    norm.pdf(d, mu, sigma),\n    where=(d &lt;= S_star),\n    color=\"skyblue\",\n    alpha=0.5,\n    label=\"F(S*)\",\n)\nplt.xlabel(\"Demand\")\nplt.ylabel(\"Probability Density\")\nplt.axvline(mu, color=\"r\", linestyle=\"--\", label=\"mu\")\nplt.axvline(S_star, color=\"g\", linestyle=\"--\", label=\"S*\")\nplt.ylim(0, 0.09)\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n下では，Excel，Python，標準正規分布表を用いて \\(S^*\\) を求める方法を示す。\n\n5.5.1 標準正規分布表\n標準正規分布表 を調べると，\\(\\Phi(z) = 0.8\\) のとき，\\(z\\) は約 0.84 である。したがって，\\(S^*\\) は\n\\[\nS^* = z \\sigma + \\mu \\approx 0.84 \\times 5 + 100 = 104.2\n\\]\nとなる。\n\n\n5.5.2 Excel\nExcel では，NORM.INV(確率,平均,標準偏差) 関数を用いて \\(F_D^{-1}(0.8)\\) を求めることができる。\n=NORM.INV(0.8, 100, 5)\n\n\n5.5.3 Python\nPython では，SciPy ライブラリの ppf() 関数を用いて，逆関数を求めることができる。\n\nfrom scipy.stats import norm\n\n# 正規分布のパラメータ\nmu = 100\nsigma = 5\n\n# 在庫超過費用と在庫不足費用\nh = 10\np = 40\n\n# 臨界率\ncritical_ratio = p / (h + p)\n\n# 最適発注量\nS_star = norm.ppf(critical_ratio, loc=mu, scale=sigma)\nprint(f\"Optimal order quantity S*: {S_star:.2f}\")\n\nOptimal order quantity S*: 104.21",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>新聞売り子問題</span>"
    ]
  },
  {
    "objectID": "inventory/newsvendor.html#再定式化",
    "href": "inventory/newsvendor.html#再定式化",
    "title": "5  新聞売り子問題",
    "section": "5.6 再定式化",
    "text": "5.6 再定式化\n新聞 1 部の仕入れ価格を \\(c\\)，販売価格を \\(r\\)，残存価額を \\(v\\)，欠品費用を \\(p\\)，保管費用を \\(h\\) とする。ここで，以下の条件を満たすとする。\n\n\\(r &gt; c\\). 販売価格は仕入れ価格より高い。\n\\(r &gt; v\\). 販売価格は残存価値より高い。\n\n新聞売り子が \\(S\\) 部の新聞を仕入れ，需要 \\(D\\) が \\(d\\) であったとする。このとき，新聞売り子の利益 \\(\\pi(S, d)\\) は以下のように表される。\n\n5.6.1 コスト関数\n\\[\\begin{align}\n\\pi(S, d) & = r \\min\\{d, S\\} - cS + v \\max\\{0, S - d\\} \\\\\n& \\quad - h \\max\\{0, S - d\\} - p \\max\\{0, d - S\\}\n\\end{align}\\]\n第一項は販売利益，第二項は仕入れコスト，第三項は残存価値，第四項は保管コスト，第五項は欠品コストである。\n以下は，\\(\\max\\{0, x\\} = x^+\\) を用いて書き換えた形である。整理すると，利益は以下のように表される。\n\\[\n\\pi(S, d) = r \\min\\{d, S\\} - cS + (v - h) (S - d)^+ - p (d - S)^+\n\\]\n第一項を以下のように書き換えることができる。\n\\[\nr \\min\\{d, S\\} = r d - r (d - S)^+\n\\]\n\n\n\n\n\n\nノート\n\n\n\n\n\\(d &lt; S\\) の場合，\\(r \\min\\{d, S\\} = r d\\) となる。\n\\(d &gt;= S\\) の場合，\\(r \\min\\{d, S\\} = r d - r(d - S) = r S\\) となる。\n\n\n\nしたがって，利益は以下のように書き換えられる。\n\\[\n\\pi(S, d) = r d - cS + (v- h) (S - d)^+ - (p + r) (d - S)^+\n\\]\n利益の最大化は，コストの最小化に帰着される。したがって，コスト関数 \\(g(S, d) = -\\pi(S, d)\\) は以下のように表される。\n\\[\ng(S, d) = cS - rd + (h - v) (S - d)^+ + (p + r) (d - S)^+\n\\]\n\\(D\\) が確率変数であるため，コストの期待値 \\(g(S)\\) は以下のように表される。\n\\[\\begin{align}\ng(S) &= \\mathbb{E}[g(S, D)] \\\\\n&= \\int_{0}^{\\infty} g(S, d) f_D(d) dd \\\\\n&= cS - r\\mathbb{E}[D] + (h - v) \\mathbb{E}[(S - D)^+] + (p + r) \\mathbb{E}[(D - S)^+] \\\\\n&= c S - r \\mu + (h - v)  \\int_{0}^{\\infty}(S - d)^+ f_D(d) dd + (p + r) \\int_{0}^{\\infty} (d - S)^+ f_D(d) dd \\\\\n&= c S - r \\mu + (h - v) \\int_{0}^{S} (S - d) f_D(d) dd + (p + r) \\int_{S}^{\\infty} (d - S) f_D(d) dd\n\\end{align}\\]\n\n\n5.6.2 最適化\n\\(g(S)\\) の1階微分は以下のように求める。\n\\[\\begin{align}\n\\frac{dg(S)}{dS} &= c + (h - v) F_D(S) - (p + r) (1 - F_D(S)) \\\\\n\\end{align}\\]\nよって，\\(dg(S)/dS = 0\\) から，\n\\[\\begin{align}\nc + (h - v) F_D(S) - (p + r) (1 - F_D(S)) &= 0 \\\\\nF_D(S) &= \\frac{p + r - c}{h + p + r - v}\n\\end{align}\\]\nになる。2 階微分は\n\\[\\begin{align}\n\\frac{d^2g(S)}{dS^2} &= (h - v) f_D(S) + (p + r) f_D(S) \\\\\n&= (h - v + p + r) f_D(S)\n\\end{align}\\]\nである。したがって，コスト関数 \\(g(S)\\) は凸関数であり，1 階微分が 0 になる点は最小値を与える。\nコスト関数 \\(g(S)\\) を最小化するための最適発注量 \\(S^*\\) は\n\\[\nS^* = F_D^{-1}\\left(\\frac{p + r - c}{h + p + r - v}\\right)\n\\] となる。ここで，\\(F_D^{-1}\\) は需要 \\(D\\) の累積分布関数の逆関数である。\n新聞売り子問題において，より一般的に，在庫超過費用（overage cost）と 在庫不足費用（underage cost）を考慮する。\n\\[\nC_o = h + c - v, \\quad C_u = p + r - c\n\\]\n\n\n5.6.3 臨界率\n在庫超過費用 \\(C_o\\) は，在庫が余ったときのコストである。1 部の在庫超過に対し，保管コストと仕入れコストが発生するが，残存価額が得られないため，\\(C_o = h + c - v\\) となる。\n在庫不足費用 \\(C_u\\) は，在庫が不足したときのコストである。1 部の在庫不足に対し，欠品コスト \\(p\\) と失われた販売機会の利益 \\(r - c\\) が発生するため，\\(C_u = p + r - c\\) となる。\n従って，\n\\[\\begin{align*}\nS^* &= F_D^{-1}\\left(\\frac{p + r - c}{h + p + r - v}\\right)\\\\\n&= F_D^{-1}\\left(\\frac{C_u}{C_o + C_u}\\right)\n\\end{align*}\\]\nが得られる。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>新聞売り子問題</span>"
    ]
  },
  {
    "objectID": "inventory/newsvendor.html#初期在庫を考慮した新聞売り子問題",
    "href": "inventory/newsvendor.html#初期在庫を考慮した新聞売り子問題",
    "title": "5  新聞売り子問題",
    "section": "5.7 初期在庫を考慮した新聞売り子問題*",
    "text": "5.7 初期在庫を考慮した新聞売り子問題*\n新聞売り子の初期在庫を \\(I\\) とする。\\(I \\leq S^*\\)の場合，最適発注量は \\(S^* - I\\) となる。すなわち，在庫量を \\(S^*\\) にすればよい。\nまた，\\(g(S)\\) は凸関数であるため，\\(I &gt; S^*\\) の場合，何も発注しないことが最適である。\nしたがって，最適発注量は\n\\[\nQ =\n\\begin{cases}\nS^* - I, & \\text{if } I \\le S^*, \\\\[6pt]\n0, & \\text{if } I &gt; S^* .\n\\end{cases}\n\\]\nとなる。\nこのような発注方式を Base Stock Policy (BSP) と呼ぶ。BSP は，各期間の在庫量を観測し，在庫量が \\(S^*\\) に引き上げられるように発注する方式である。新聞売り子問題において，BSP は最適な方策であると知られている。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>新聞売り子問題</span>"
    ]
  },
  {
    "objectID": "inventory/newsvendor.html#文献案内",
    "href": "inventory/newsvendor.html#文献案内",
    "title": "5  新聞売り子問題",
    "section": "5.8 文献案内",
    "text": "5.8 文献案内\nArrow, Harris, と Marschak (1951) は，新聞売り子問題を初めて定式化した。\nScarf (1959) の論文では，\\((s, S)\\) 方策が発注費用を考慮した複数期間の新聞売り子問題において最適であることを示している。\n実際には，需要の分布が不明であることが多い。Huber ほか (2019) は，データ駆動新聞売り子問題（Data-Driven Newsvendor Problem）に関する研究が行われている。\nQin ほか (2011) は，新聞売り子問題に関する研究をレビューした。",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>新聞売り子問題</span>"
    ]
  },
  {
    "objectID": "inventory/newsvendor.html#練習問題",
    "href": "inventory/newsvendor.html#練習問題",
    "title": "5  新聞売り子問題",
    "section": "5.9 練習問題",
    "text": "5.9 練習問題\n\n練習 5.1 ある弁当屋では，1 個 500 円で弁当を仕入れ，1 個 800 円で販売している。売れ残った弁当を廃棄する場合，1 個当たり 10 円の廃棄費用がかかる。 弁当の需要 \\(D\\) は，正規分布 \\(N(50, 8^2)\\) に従うとする。このとき，最適な弁当の発注量を求めよ。\n\n\n解答 5.1. 弁当 1 個当たりの在庫超過費用 \\(h\\)，在庫不足費用 \\(p\\) は以下のように求められる。 \\[\nh = 10 + 500 = 510, \\quad p = 800 - 500 = 300\n\\]\nしたがって，\\(S^*\\) は以下のように求められる。\n\\[\nS^* = F_D^{-1}\\left(\\frac{p}{h + p}\\right) = F_D^{-1}\\left(\\frac{300}{510 + 300}\\right) \\approx F_D^{-1}\\left(0.37\\right)\n\\]\n標準正規分布表を調べると，\\(\\Phi(z) = 0.37\\) のとき，\\(z\\) は約 -0.33 である。したがって，\\(S^*\\) は\n\\[\nS^* = -0.33 \\times \\sigma + \\mu = -0.33 \\times 8 + 50 \\approx 47.36\n\\]\nとなる。\nPython を用いて計算すると，以下のようになる。\n\n\nコード\nfrom scipy.stats import norm\n\n# 正規分布のパラメータ\nmu = 50\nsigma = 8\n# 在庫超過費用と在庫不足費用\nh = 510\np = 300\n# 臨界率\ncritical_ratio = p / (h + p)\n# 最適発注量\nS_star = norm.ppf(critical_ratio, loc=mu, scale=sigma)\nprint(f\"Optimal order quantity S*: {S_star:.4f}\")\n\n\nOptimal order quantity S*: 47.3530\n\n\n\n\n\n\n\nArrow, Kenneth J, Theodore Harris, と Jacob Marschak. 1951. 「Optimal Inventory Policy」. Econometrica 19 (3): 250.\n\n\nHuber, Jakob, Sebastian Müller, Moritz Fleischmann, と Heiner Stuckenschmidt. 2019. 「A data-driven newsvendor problem: From data to decision」. Eur. J. Oper. Res. 278 (3): 904–15.\n\n\nQin, Yan, Ruoxuan Wang, Asoo J Vakharia, Yuwen Chen, と Michelle M H Seref. 2011. 「The newsvendor problem: Review and directions for future research」. Eur. J. Oper. Res. 213 (2): 361–74.\n\n\nScarf, Herbert. 1959. 「The optimality of (S, s) policies in the dynamic inventory problem」.",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>新聞売り子問題</span>"
    ]
  },
  {
    "objectID": "inventory/summary.html",
    "href": "inventory/summary.html",
    "title": "6  まとめ",
    "section": "",
    "text": "在庫管理の目的は，発注量と発注時期を決定し，顧客の需要を満たしつつ，コストを最小化することである．\n科学的在庫管理では，在庫モデルを定式化し，発注量と発注時期を決定する．\n在庫方策は，在庫の状況に応じて，発注量と発注時期を決定するルールである．\\((s, S)\\) 方策，\\((r, Q)\\) 方策，BSP 方策などがある．\n安全在庫の章では，コストを最小化するのではなく，サービスレベルを満たすための在庫方策を決定する方法を学んだ．\n\n紹介した在庫モデルを分類すると，次の表のようになる．\n\n\n\nモデル名\n分類\n\n\n\n\nEOQ モデル\n決定論的連続観測モデル\n\n\n安全在庫\n確率的連続観測モデル\n\n\nWagner-Whitin モデル\n多期間決定論的周期観測モデル\n\n\n新聞売り子問題\n単一期間確率的周期観測モデル",
    "crumbs": [
      "在庫モデル",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>まとめ</span>"
    ]
  },
  {
    "objectID": "mcda/ahp.html",
    "href": "mcda/ahp.html",
    "title": "7  階層分析法",
    "section": "",
    "text": "7.1 代替案\nAHPは，複数の代替案の中から一つの代替案を選択するための手法である．\n代替案の集合 \\(X = \\{x_1, x_2, \\ldots, x_n\\}\\) とする．代替案の重要度を\n\\[\n\\mathbf{w} = (w_1, w_2, \\ldots, w_n)^T\n\\]\nで表す．ここで，\\(w_i\\) は代替案 \\(x_i\\) の重要度を表し，\\(\\sum_{i=1}^n w_i = 1\\) を満たす．AHPでは，\\(\\mathbf{w}\\) を計算できるものとする．計算する方法は後述する．\n\\(w_i\\) が大きいほど，代替案 \\(x_i\\) が望ましいとする．\\(w_i &gt; w_j\\) ならば，代替案 \\(x_i\\) は代替案 \\(x_j\\) より望ましい．このとき，\\(x_i \\succ x_j\\) と表す．\nこのように，それぞれの代替案の重要度が与えられるならば，望ましい代替案の選択は容易である．しかし，実際には，代替案の重要度を直接決定することは難しい．",
    "crumbs": [
      "多基準意思決定分析",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>階層分析法</span>"
    ]
  },
  {
    "objectID": "mcda/ahp.html#代替案",
    "href": "mcda/ahp.html#代替案",
    "title": "7  階層分析法",
    "section": "",
    "text": "例 7.1 旅行先の代替案 \\[\nX = \\{\\text{北海道}, \\text{沖縄}, \\text{九州}\\}\n\\]\nとし，各代替案の重要度を \\(\\mathbf{w} = (0.3, 0.5, 0.2)^T\\) とするとき， \\[\n\\text{沖縄} \\succ \\text{北海道} \\succ \\text{九州}\n\\] である．",
    "crumbs": [
      "多基準意思決定分析",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>階層分析法</span>"
    ]
  },
  {
    "objectID": "mcda/ahp.html#記号",
    "href": "mcda/ahp.html#記号",
    "title": "7  階層分析法",
    "section": "7.2 記号",
    "text": "7.2 記号\n\n\n\n記号\n意味\n\n\n\n\n\\(\\mathbf{A}\\)\n一対比較行列\n\n\n\\(X\\)\n代替案の集合\n\n\n\\(x_i\\)\n代替案 \\(i\\)\n\n\n\\(a_{ij}\\)\n一対比較値\n\n\n\\(\\mathbf{w}\\)\n重要度ベクトル",
    "crumbs": [
      "多基準意思決定分析",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>階層分析法</span>"
    ]
  },
  {
    "objectID": "mcda/ahp.html#一対比較",
    "href": "mcda/ahp.html#一対比較",
    "title": "7  階層分析法",
    "section": "7.3 一対比較",
    "text": "7.3 一対比較\nすべての代替案を並べて比較することは難しい．そこで，AHPでは，2つの代替案を比較する一対比較 (pairwise comparison)を用いる．その理由として，\\(\\{x_1, x_2, \\ldots, x_n\\}\\) の中から最も望ましい代替案を選ぶことは難しいが，2つの代替案 \\(x_i\\) と \\(x_j\\) のどちらが望ましいかを決定することは比較的容易であることが挙げられる．\nAHPでは，\\(x_i\\) は \\(x_j\\) よりどれくらい望ましいかを一対比較値で表す．正式には，一対比較値 \\(a_{ij}\\) は \\(x_i\\) が \\(x_j\\) より \\(a_{ij}\\) 倍望ましいことを表す．\n例えば，\\(a_{ij} = 3\\) ならば，\\(x_i\\) は \\(x_j\\) より3倍望ましいことを表す．例 7.1 で，\\(a_{12} = 3\\) ならば，\\(x_1\\) （北海道）は \\(x_2\\) （沖縄）より3倍望ましいことを表す．\nSaatyは，一対比較値を以下の尺度で表すことを提案した．\nTable: The fundamental scale of absolute numbers (Saaty, 2008)\n\n\n\n\n\n\n\n\nImportance\nDefinition\nExplanation\n\n\n\n\n1\nEqual\nTwo activities contribute equally to the objective\n\n\n2\nWeak or slight\n-\n\n\n3\nModerate\nExperience and judgment slightly favor one activity over another\n\n\n4\nModerate plus\n-\n\n\n5\nStrong\nExperience and judgment strongly favor one activity over another\n\n\n6\nStrong plus\n-\n\n\n7\nVery strong\nAn activity is favored very strongly over another activity\n\n\n8\nVery, very strong\n-\n\n\n9\nExtreme\nThe evidence favoring one activity over another is of the highest possible order",
    "crumbs": [
      "多基準意思決定分析",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>階層分析法</span>"
    ]
  },
  {
    "objectID": "mcda/ahp.html#一対比較行列",
    "href": "mcda/ahp.html#一対比較行列",
    "title": "7  階層分析法",
    "section": "7.4 一対比較行列",
    "text": "7.4 一対比較行列\nすべての代替案の組み合わせについて一対比較を行い，その結果を一対比較行列 (pairwise comparison matrix)にまとめる．一対比較行列は \\(\\mathbf{A} = [a_{ij}]_{n \\times n}\\) と定義され，以下のように表される。\n\\[\n\\mathbf{A} = \\begin{bmatrix}\na_{11} & a_{12} & \\cdots & a_{1n} \\\\\na_{21} & a_{22} & \\cdots & a_{2n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{n1} & a_{n2} & \\cdots & a_{nn} \\\\\n\\end{bmatrix}\n\\]\n理論的には，\n\\[\na_{ij} \\approx \\frac{w_i}{w_j} \\quad \\forall i, j\n\\]\nが想定されている．\n\n\n\n\n\n\nヒント\n\n\n\n意思決定者が一対比較を行うとき，\\(\\mathbf{w} = (w_1, w_2, \\ldots, w_n)^T\\) が知らないが，合理的な意思決定者ならば，\\(a_{ij} = w_i/w_j\\) を満たすと考えられる．\n\n\n意思決定者が完全に合理的であるならば，\\(a_{ij} = w_i/w_j\\) を満たす． このとき，一対比較行列 \\(\\mathbf{A}\\) は以下のようになる．\n\\[\n\\mathbf{A} = \\begin{bmatrix}\nw_1/w_1 & w_1/w_2 & \\cdots & w_1/w_n \\\\\nw_2/w_1 & w_2/w_2 & \\cdots & w_2/w_n \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nw_n/w_1 & w_n/w_2 & \\cdots & w_n/w_n \\\\\n\\end{bmatrix}\n\\]\nこのとき，\\(\\mathbf{A}\\) は完全に整合性 (consistency) を持つと言う．\\(\\mathbf{A}\\) は，以下の性質が成り立つ．\n\n\\(a_{ii} = 1, \\forall i\\)\n\\(a_{ij} = 1/a_{ji}, \\forall i, j\\)\n\\(a_{ik} = a_{ij} a_{jk}, \\forall i, j, k\\)\n\n\n\n\n\n\n\nヒント\n\n\n\n\\(a_{ij} = w_i/w_j\\) とするとき，これらの性質は，以下のように導かれる．\n\\[\na_{ii} = \\frac{w_i}{w_i} = 1\n\\]\n\\[\na_{ij} = \\frac{w_i}{w_j} = \\frac{1}{\\frac{w_j}{w_i}} = \\frac{1}{a_{ji}}\n\\]\n\\[\na_{ik} = \\frac{w_i}{w_k} = \\frac{w_i}{w_j} \\times \\frac{w_j}{w_k} = a_{ij} a_{jk}\n\\]\n\n\n\n例 7.2 A さんがクッキー（\\(x_1\\)）はチョコレート（\\(x_2\\)）より3倍好きで，チョコレート（\\(x_2\\)）はアイスクリーム（\\(x_3\\)）より2倍好きならば，クッキーはアイスクリームより6倍好きである．すなわち，\\(a_{12} = 3\\)，\\(a_{23} = 2\\) ならば，\\(a_{13} = 6\\) である．また，A さんがクッキーはチョコレートより3倍好きであるならば，チョコレートはクッキーの1/3倍好きである．すなわち，\\(a_{12} = 3\\) ならば，\\(a_{21} = 1/3\\) である．\n\n\n例 7.3 旅行先の代替案 \\(X = \\{\\text{北海道}, \\text{沖縄}, \\text{九州}\\}\\) とし，以下の一対比較を行ったとする．\n\n\\(x_1\\) （北海道）は \\(x_2\\) （沖縄）より3倍望ましい\n\\(x_1\\) （北海道）は \\(x_3\\) （九州）より6倍望ましい\n\\(x_2\\) （沖縄）は \\(x_3\\) （九州）より2倍望ましい\n\nこのとき，一対比較行列 \\(\\mathbf{A}\\) は以下のようになる．\n\\[\n\\mathbf{A} = \\begin{bmatrix}\n1 & 3 & 6 \\\\\n1/3 & 1 & 2 \\\\\n1/6 & 1/2 & 1 \\\\\n\\end{bmatrix}\n\\]",
    "crumbs": [
      "多基準意思決定分析",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>階層分析法</span>"
    ]
  },
  {
    "objectID": "mcda/ahp.html#重要度ベクトル",
    "href": "mcda/ahp.html#重要度ベクトル",
    "title": "7  階層分析法",
    "section": "7.5 重要度ベクトル",
    "text": "7.5 重要度ベクトル\n一対比較行列 \\(\\mathbf{A}\\) が与えられたとき，重要度ベクトル \\(\\mathbf{w}\\) を計算する方法を説明する．\nまず，意思決定者が完全に合理的であるならば，\\(a_{ij} = w_i/w_j\\) を満たすため，\\(\\mathbf{A}\\) は\n\\[\n\\mathbf{A} = \\begin{bmatrix}\nw_1/w_1 & w_1/w_2 & \\cdots & w_1/w_n \\\\\nw_2/w_1 & w_2/w_2 & \\cdots & w_2/w_n \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nw_n/w_1 & w_n/w_2 & \\cdots & w_n/w_n \\\\\n\\end{bmatrix}\n\\]\nであるから，\\(\\mathbf{A}\\) の各列は比例している．このとき，重要度ベクトル \\(\\mathbf{w}\\) は，\\(\\mathbf{A}\\) の任意の列を正規化することで求められる．\n例 7.3 の一対比較行列 \\(\\mathbf{A}\\) を考える．\n\\[\n\\mathbf{A} = \\begin{bmatrix}\n1 & 3 & 6 \\\\\n1/3 & 1 & 2 \\\\\n1/6 & 1/2 & 1 \\\\\n\\end{bmatrix}\n\\]\nこのとき，\\(\\mathbf{A}\\) の第3列を正規化すると，重要度ベクトル \\(\\mathbf{w}\\) は以下のようになる． \\[\nw_1 = \\frac{6}{6 + 2 + 1} = \\frac{6}{9} \\approx 0.67\n\\] \\[\nw_2 = \\frac{2}{6 + 2 + 1} = \\frac{2}{9} \\approx 0.22\n\\] \\[\nw_3 = \\frac{1}{6 + 2 + 1} = \\frac{1}{9} \\approx 0.11\n\\]",
    "crumbs": [
      "多基準意思決定分析",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>階層分析法</span>"
    ]
  },
  {
    "objectID": "mcda/ahp.html#階層",
    "href": "mcda/ahp.html#階層",
    "title": "7  階層分析法",
    "section": "7.6 階層",
    "text": "7.6 階層\nAHPでは，複数の評価基準（criterion）を用いて代替案を評価することができる．例えば，旅行先の代替案を評価するとき，費用，距離，環境などの評価基準を用いることができる．\n\n\n\n\n\n\nヒント\n\n\n\n意思決定者が直接代替案を一対比較することは難しいが，評価基準を用いて代替案を評価することは比較的容易であると考えられる．\n\n\nAHPでは，評価基準を用いて代替案を評価するために，階層 (hierarchy) を用いる．階層は，以下の要素から構成される．\n\n目的 (goal)\n評価基準 (criteria)\n代替案 (alternatives)\n\n正式に，評価基準の集合を \\(C = \\{c_1, c_2, \\ldots, c_m\\}\\) とする．\n例えば，旅行先の代替案を \\(X = \\{\\text{北海道}, \\text{沖縄}, \\text{九州}\\}\\) とし，評価基準 \\(C = \\{\\text{気候}, \\text{食事}, \\text{費用}\\}\\) とする．このとき，以下のような階層を考える．\nmermaid-figure-error\nこのような階層構造を用いることで，評価基準に基づいて代替案を評価することができる．各評価基準 \\(c_k \\in C\\) を用いて，代替案の一対比較行列 \\(\\mathbf{A}^{(k)}\\) を構築する．\n例えば，\\(A^{(1)}\\)，\\(A^{(2)}\\)，\\(A^{(3)}\\) をそれぞれ評価基準 \\(c_1\\)，\\(c_2\\)，\\(c_3\\) に対応する一対比較行列とする．\n\\[\n\\mathbf{A}^{(1)} = \\begin{bmatrix}\n1 & 1/3 & 3 \\\\\n3 & 1 & 9 \\\\\n1/3 & 1/9 & 1 \\\\\n\\end{bmatrix}, \\quad\n\\mathbf{A}^{(2)} = \\begin{bmatrix}\n1 & 1 & 4 \\\\\n1 & 1 & 4 \\\\\n1/4 & 1/4 & 1 \\\\\n\\end{bmatrix}, \\quad\n\\mathbf{A}^{(3)} = \\begin{bmatrix}\n1 & 1/2 & 1/6 \\\\\n2 & 1 & 1/3 \\\\\n6 & 3 & 1 \\\\\n\\end{bmatrix}\n\\]\n\n\n\n\n\n\nヒント\n\n\n\n以上の一対比較行列から見ると，この人は以下のような評価をしていることがわかる．\n\n気候に関しては，沖縄が最も望ましく，次に北海道，最後に九州である\n食事に関しては，北海道と沖縄が同じくらい望ましく，九州が最も望ましくない\n費用に関しては，九州が最も望ましく，次に沖縄，最後に北海道である\n\n\n\n重要度ベクトル \\(\\mathbf{w}^{(k)}\\) をそれぞれの一対比較行列 \\(\\mathbf{A}^{(k)}\\) から計算する．\n\\[\n\\mathbf{w}^{(1)} = \\begin{bmatrix}\n3/13 \\\\\n9/13 \\\\\n1/13 \\\\\n\\end{bmatrix}, \\quad\n\\mathbf{w}^{(2)} = \\begin{bmatrix}\n4/9 \\\\\n4/9 \\\\\n1/9 \\\\\n\\end{bmatrix}, \\quad\n\\mathbf{w}^{(3)} = \\begin{bmatrix}\n1/9 \\\\\n2/9 \\\\\n6/9 \\\\\n\\end{bmatrix}\n\\]\n各評価基準 \\(c_k \\in C\\) において，代替案の重要度ベクトル \\(\\mathbf{w}^{(k)}\\) が計算できた．次に，評価基準はどれくらい重要かを評価する．評価基準の一対比較行列 \\(\\mathbf{B}\\) を構築する．\n例えば，以下のような一対比較行列 \\(\\mathbf{B}\\) を考える．\n\n評価基準 \\(c_1\\) （気候）は \\(c_2\\) （食事）より1/4倍重要である\n評価基準 \\(c_1\\) （気候）は \\(c_3\\)（費用）より2倍重要である\n評価基準 \\(c_2\\) （食事）は \\(c_3\\)（費用）より8倍重要である\n\n\n\n\n\n\n\nヒント\n\n\n\nこの人は，食事を最も重要視しており，次に気候，最後に費用を重要視していることがわかる．\n\n\n\\[\n\\mathbf{B} = \\begin{bmatrix}\n1 & 1/4 & 2 \\\\\n4 & 1 & 8 \\\\\n1/2 & 1/8 & 1 \\\\\n\\end{bmatrix}\n\\]\n同様に，重要度ベクトル \\(\\mathbf{v}\\) を一対比較行列 \\(\\mathbf{B}\\) から計算する．\n\\[\n\\mathbf{v} = \\begin{bmatrix}\n2/11 \\\\\n8/11 \\\\\n1/11 \\\\\n\\end{bmatrix}\n\\]\n最終的に，代替案の重要度ベクトル \\(\\mathbf{w}\\) は以下のように計算される．\n\\[\n\\mathbf{w} = \\sum_{k=1}^m v_k \\mathbf{w}^{(k)}\n= \\frac{2}{11} \\begin{bmatrix}\n3/13 \\\\\n9/13 \\\\\n1/13 \\\\\n\\end{bmatrix}\n+ \\frac{8}{11} \\begin{bmatrix}\n4/9 \\\\\n4/9 \\\\\n1/9 \\\\\n\\end{bmatrix}\n+ \\frac{1}{11} \\begin{bmatrix}\n1/9 \\\\\n2/9 \\\\\n6/9 \\\\\n\\end{bmatrix}\n\\approx \\begin{bmatrix}\n0.38 \\\\\n0.47 \\\\\n0.16 \\\\\n\\end{bmatrix}\n\\]\n\n\nコード\nimport numpy as np\n\nw1 = np.array([3/13, 9/13, 1/13])\nw2 = np.array([4/9, 4/9, 1/9])\nw3 = np.array([1/9, 2/9, 6/9])\nv = np.array([2/11, 8/11, 1/11])\nw = v[0] * w1 + v[1] * w2 + v[2] * w3\nw\n\n\narray([0.37529138, 0.46930847, 0.15540016])\n\n\nこのとき，重要度ベクトル \\(\\mathbf{w}\\) から，望ましい代替案は \\(x_2\\) （沖縄）であることがわかる．\n\n\n\n\n\n\nノート階層の一般化\n\n\n\n今回は，目標，評価基準，代替案の3層の階層を考えたが，評価基準の下にさらに評価基準を追加するなど，より複雑な階層を考えることもできる．",
    "crumbs": [
      "多基準意思決定分析",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>階層分析法</span>"
    ]
  },
  {
    "objectID": "mcda/ahp.html#重要度ベクトルの推定",
    "href": "mcda/ahp.html#重要度ベクトルの推定",
    "title": "7  階層分析法",
    "section": "7.7 重要度ベクトルの推定",
    "text": "7.7 重要度ベクトルの推定\nしかし，人間の評価は必ずしも合理的でないため，一般には \\(a_{ij} = w_i/w_j\\) を満たさない．このとき，他の方法で一対比較行列 \\(\\mathbf{A}\\) から重要度ベクトル \\(\\mathbf{w}\\) を計算する必要がある．計算する方法として，主に幾何平均法 (geometric mean method) と固有ベクトル法 (eigenvector method) の2つがある．\n\n\n\n\n\n\nヒント\n\n\n\n幾何平均法と固有ベクトル法のどちらが優れているかについては議論がある．AHPの創始者であるSaatyは固有ベクトル法が優れていると主張しているが，幾何平均法が優れているとする出張する研究もある．\n他にもnormalized columns methodという方法もあるが，理論的根拠がないと言われている．\n\n\n\n7.7.1 幾何平均法\nCrawford と Williams (1985) は，幾何平均法を提案した．幾何平均法では，重要度ベクトル \\(\\mathbf{w}\\) の各要素 \\(w_k\\) を以下のように計算する．\n\\[\nw_k = \\frac{\\left(\\prod_{j=1}^n a_{kj}\\right)^{1/n}}{\\sum_{i=1}^n \\left(\\prod_{j=1}^n a_{ij}\\right)^{1/n}} \\quad \\forall k\n\\]\n\n\n\n\n\n\nヒント\n\n\n\n\\(\\mathbf{A}\\) の各行の幾何平均を計算し，正規化することで，重要度ベクトル \\(\\mathbf{w}\\) を求めている．\n\n\n例 7.3 の一対比較行列 \\(\\mathbf{A}\\) を考える．\n\\[\n\\mathbf{A} = \\begin{bmatrix}\n1 & 3 & 6 \\\\\n1/3 & 1 & 2 \\\\\n1/6 & 1/2 & 1 \\\\\n\\end{bmatrix}\n\\]\nこのとき，重要度ベクトル \\(\\mathbf{w}\\) は以下のようになる．これは，理論から計算した重要度ベクトルと一致する．\n\\[\nw_1 = \\frac{(1 \\times 3 \\times 6)^{1/3}}{(1 \\times 3 \\times 6)^{1/3} + (1/3 \\times 1 \\times 2)^{1/3} + (1/6 \\times 1/2 \\times 1)^{1/3}}  \\approx 0.67\n\\]\n\\[\nw_2 = \\frac{(1/3 \\times 1 \\times 2)^{1/3}}{(1 \\times 3 \\times 6)^{1/3} + (1/3 \\times 1 \\times 2)^{1/3} + (1/6 \\times 1/2 \\times 1)^{1/3}}  \\approx 0.22\n\\]\n\\[\nw_3 = \\frac{(1/6 \\times 1/2 \\times 1)^{1/3}}{(1 \\times 3 \\times 6)^{1/3} + (1/3 \\times 1 \\times 2)^{1/3} + (1/6 \\times 1/2 \\times 1)^{1/3}}  \\approx 0.11\n\\]\n一般に，一対比較行列 \\(\\mathbf{A}\\) が整合性を持つならば，幾何平均法で計算した重要度ベクトル \\(\\mathbf{w}\\) は理論から計算した重要度ベクトルと一致する．興味があれば，証明してみよう．\n\n\n7.7.2 固有ベクトル法*\n\n\n\n\n\n\nヒント\n\n\n\n固有ベクトル法は直感的に理解することが難しいため，講義では扱わない．\n\n\n一対比較行列 \\(\\mathbf{A}\\) が整合性を持つとき，\n\\[\n\\mathbf{A} \\mathbf{w} = \\begin{bmatrix}\nw_1/w_1 & w_1/w_2 & \\cdots & w_1/w_n \\\\\nw_2/w_1 & w_2/w_2 & \\cdots & w_2/w_n \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nw_n/w_1 & w_n/w_2 & \\cdots & w_n/w_n \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\nw_1 \\\\\nw_2 \\\\\n\\vdots \\\\\nw_n \\\\\n\\end{bmatrix}\n= \\begin{bmatrix}\nn w_1 \\\\\nn w_2 \\\\\n\\vdots \\\\\nn w_n \\\\\n\\end{bmatrix}\n= n \\mathbf{w}\n\\]\nが成り立つ．式 \\(\\mathbf{A} \\mathbf{w} = n \\mathbf{w}\\) より，\\(\\mathbf{w}\\) は \\(\\mathbf{A}\\) の固有ベクトル，\\(n\\) は \\(\\mathbf{A}\\) の固有値である．\nSaatyは，最大固有値 \\(\\lambda_{max}\\) に対応する固有ベクトルを重要度ベクトルとして用いることを提案した．すなわち，重要度ベクトル \\(\\mathbf{w}\\) を求めるには，以下の式を解く．\n\\[\n\\mathbf{A} \\mathbf{w} = \\lambda_{max} \\mathbf{w}\n\\]\n例 7.3 の一対比較行列が与えられたとする．\n\\[\n\\mathbf{A} = \\begin{bmatrix}\n1 & 3 & 6 \\\\\n1/3 & 1 & 2 \\\\\n1/6 & 1/2 & 1 \\\\\n\\end{bmatrix}\n\\]\nこのとき，\\(\\mathbf{A}\\) の固有値は，\\(\\det(\\mathbf{A} - \\lambda \\mathbf{I}) = 0\\) を解くことで求められる．\n\\[\\begin{align*}\n\\det(\\mathbf{A} - \\lambda \\mathbf{I}) &= \\det\\begin{bmatrix}\n1 - \\lambda & 3 & 6 \\\\\n1/3 & 1 - \\lambda & 2 \\\\\n1/6 & 1/2 & 1 - \\lambda \\\\\n\\end{bmatrix} \\\\\n&= -\\lambda^3 + 3\\lambda^2 \\\\\n&= -\\lambda^2(\\lambda - 3)\n\\end{align*}\\]\n\\(\\lambda^2(\\lambda - 3) = 0\\) より，\\(\\lambda = 0, 3\\) が得られる．この例において，\\(\\mathbf{A}\\) の最大固有値は \\(\\lambda_{max} = 3\\) であり，それ以外の固有値は \\(\\lambda = 0\\) である．また，\\(\\mathbf{A}\\) は \\(3 \\times 3\\) 行列であるため，\\(\\lambda_{max} = n\\) が成り立つ．これは特別な例ではなく，一般に 命題 7.1 が成り立つ．\n\n命題 7.1 整合性のある \\(n \\times n\\) 行列 \\(\\mathbf{A}\\) の最大固有値は \\(\\lambda_{max} = n\\) であり，それ以外の固有値は \\(\\lambda = 0\\) である．\n\n行列 \\(\\mathbf{A}\\) は整合性を持たないとき，\\(\\lambda_{max} &gt; n\\) が成り立つ．命題 7.2 は \\(\\lambda_{max}\\) の性質を述べている．\n\n命題 7.2 (Saaty) \\(\\mathbf{A}\\) を一対行列とする．\\(\\mathbf{A}\\) が整合性を持つならば，\\(\\lambda_{max} = n\\) である．\\(\\mathbf{A}\\) が整合性を持たないならば，\\(\\lambda_{max} &gt; n\\) である．",
    "crumbs": [
      "多基準意思決定分析",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>階層分析法</span>"
    ]
  },
  {
    "objectID": "mcda/ahp.html#整合性",
    "href": "mcda/ahp.html#整合性",
    "title": "7  階層分析法",
    "section": "7.8 整合性*",
    "text": "7.8 整合性*\n計算された重要度ベクトル \\(\\mathbf{w}\\) が一対比較行列 \\(\\mathbf{A}\\) とどれくらい整合しているかを評価する指標として，様々な指標が提案されている．．\n\n7.8.1 CI\nSaatyは，一対比較行列 \\(\\mathbf{A}\\) の整合性を評価する指標として整合度 (consistency index, CI) を提案した．\n\\[\nCI = \\frac{\\lambda_{max} - n}{n - 1}\n\\]\n\n\n7.8.2 GCI\nAguarón が平均幾何整合度 (geometric consistency index, GCI) を提案した．\n一対比較値 \\(a_{ij}\\) と重要度ベクトル \\(\\mathbf{w}\\) から，以下のように \\(e_{ij}\\) を定義する．\n\\[\ne_{ij} = a_{ij} \\frac{w_j}{w_i}\n\\]\n\\(a_{ij} = w_i/w_j\\) を満たすならば，\\(e_{ij} = 1\\) である．\nGCIは以下のように定義される．\n\\[\nGCI = \\frac{2}{(n-1)(n-2)} \\sum_{i=1}^{n-1} \\sum_{j=i+1}^{n} \\left(\\ln e_{ij}\\right)^2\n\\]",
    "crumbs": [
      "多基準意思決定分析",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>階層分析法</span>"
    ]
  },
  {
    "objectID": "mcda/ahp.html#文献案内",
    "href": "mcda/ahp.html#文献案内",
    "title": "7  階層分析法",
    "section": "7.9 文献案内",
    "text": "7.9 文献案内\nSaaty (1977) は初めてAHPを提案している．この論文では，固有ベクトル法と整合性の指標CIを提案している．\nCrawford と Williams (1985) は幾何平均法を提案している．\nBrunelli (2015) はAHPを丁寧に解説した書籍である．深く理解したい人にお勧めする．",
    "crumbs": [
      "多基準意思決定分析",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>階層分析法</span>"
    ]
  },
  {
    "objectID": "mcda/ahp.html#用語",
    "href": "mcda/ahp.html#用語",
    "title": "7  階層分析法",
    "section": "7.10 用語",
    "text": "7.10 用語\n\n\n\nEnglish\nJapanese\n\n\n\n\nmulti-criteria decision making (MCDM)\n多基準意思決定\n\n\nAnalytic Hierarchy Process (AHP)\n階層分析法\n\n\nConsistency index\n整合度\n\n\npairwise comparison matrix\n一対比較行列\n\n\nalternative\n代替案\n\n\ncriterion\n評価基準\n\n\npriority vector\n重要度ベクトル",
    "crumbs": [
      "多基準意思決定分析",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>階層分析法</span>"
    ]
  },
  {
    "objectID": "mcda/ahp.html#練習問題",
    "href": "mcda/ahp.html#練習問題",
    "title": "7  階層分析法",
    "section": "7.11 練習問題",
    "text": "7.11 練習問題\n\n練習 7.1 ある会社が新しい工場の建設場所を選ぶために，3つの都市を代替案として検討している．\n\n都市Aは都市Bよりも2倍望ましい\n都市Aは都市Cよりも4倍望ましい\n都市Bは都市Cよりも2倍望ましい\n\nこのとき，一対比較行列を構築し，重要度ベクトルを計算せよ．\n\n\n解答 7.1. 一対比較行列 \\(\\mathbf{A}\\) は以下のようになる．\n\\[\n\\mathbf{A} = \\begin{bmatrix}\n1 & 2 & 4 \\\\\n1/2 & 1 & 2 \\\\\n1/4 & 1/2 & 1 \\\\\n\\end{bmatrix}\n\\]\n\\(\\mathbf{A}\\) は整合性を持つため，\\(\\mathbf{A}\\) の任意の列を正規化することで，重要度ベクトル \\(\\mathbf{w}\\) を求めることができる．\n\\[\nw = \\begin{bmatrix}\n4/7 \\\\\n2/7 \\\\\n1/7 \\\\\n\\end{bmatrix}\n\\]\n\n\n練習 7.2 ある学生が大学を選ぶために，3つの大学を代替案として検討している．\n\n大学Aは大学Bよりも3倍望ましい\n大学Aは大学Cよりも5倍望ましい\n大学Bは大学Cよりも2倍望ましい\n\nこのとき，一対比較行列を構築し，重要度ベクトルを計算せよ．\n\n\n解答 7.2. 一対比較行列 \\(\\mathbf{A}\\) は以下のようになる．\n\\[\n\\mathbf{A} = \\begin{bmatrix}\n1 & 3 & 5 \\\\\n1/3 & 1 & 2 \\\\\n1/5 & 1/2 & 1 \\\\\n\\end{bmatrix}\n\\]\n\\(\\mathbf{A}\\) は整合性を持たないため，幾何平均法で重要度ベクトル \\(\\mathbf{w}\\) を求める．\n\\[\nw_1 = \\frac{(1 \\times 3 \\times 5)^{1/3}}{(1 \\times 3 \\times 5)^{1/3} + (1/3 \\times 1 \\times 2)^{1/3} + (1/5 \\times 1/2 \\times 1)^{1/3}}  \\approx 0.65\n\\]\n\\[\nw_2 = \\frac{(1/3 \\times 1 \\times 2)^{1/3}}{(1 \\times 3 \\times 5)^{1/3} + (1/3 \\times 1 \\times 2)^{1/3} + (1/5 \\times 1/2 \\times 1)^{1/3}}  \\approx 0.23\n\\]\n\\[\nw_3 = \\frac{(1/5 \\times 1/2 \\times 1)^{1/3}}{(1 \\times 3 \\times 5)^{1/3} + (1/3 \\times 1 \\times 2)^{1/3} + (1/5 \\times 1/2 \\times 1)^{1/3}}  \\approx 0.12\n\\]\n\n\nコード\nimport numpy as np\n\nA = np.array([[1, 3, 5], [1/3, 1, 2], [1/5, 1/2, 1]])\nw1 = (np.prod(A[0, :]))**(1/3)\nw2 = (np.prod(A[1, :]))**(1/3)\nw3 = (np.prod(A[2, :]))**(1/3)\nw = np.array([w1, w2, w3])\nw = w / np.sum(w)\nw\n\n\narray([0.64832901, 0.22965079, 0.12202019])\n\n\n\n\n練習 7.3 ある学生が就職先を選ぶために，3つの企業を代替案として検討している．評価基準として，給与，勤務地，企業の評判を考える．\n\n給与に関しては，企業Aは企業Bよりも2倍望ましく，企業Aは企業Cよりも3倍望ましく，企業Bは企業Cよりも2倍望ましい．\n勤務地に関しては，企業Aは企業Bと同じくらい望ましく，企業Aは企業Cよりも4倍望ましく，企業Bは企業Cよりも4倍望ましい．\n企業の評判に関しては，企業Bは企業Aの2倍望ましく，企業Cは企業Bの4倍望ましく，企業Cは企業Aの8倍望ましい．\n\nまた，この学生は，評価基準として，給与は勤務地の2倍，勤務地は企業の評判の2倍重要，給与は企業の評判の4倍重要と考えている．\nこのとき，AHPを用いて重要度ベクトルを計算し，最も望ましい企業を選べ．\n\n\n解答 7.3. 給与に関する一対比較行列 \\(\\mathbf{A}^{(1)}\\) は以下のようになる．\n\\[\n\\mathbf{A}^{(1)} = \\begin{bmatrix}\n1 & 1 & 4 \\\\\n1 & 1 & 4 \\\\\n1/4 & 1/4 & 1 \\\\\n\\end{bmatrix}\n\\]\n勤務地に関する一対比較行列 \\(\\mathbf{A}^{(2)}\\) は以下のようになる．\n\\[\n\\mathbf{A}^{(2)} = \\begin{bmatrix}\n1 & 2 & 6 \\\\\n1/2 & 1 & 3 \\\\\n1/6 & 1/3 & 1 \\\\\n\\end{bmatrix}\n\\]\n企業の評判に関する一対比較行列 \\(\\mathbf{A}^{(3)}\\) は以下のようになる．\n\\[\n\\mathbf{A}^{(3)} = \\begin{bmatrix}\n1 & 1/2 & 1/8 \\\\\n2 & 1 & 1/4 \\\\\n8 & 4 & 1 \\\\\n\\end{bmatrix}\n\\]\n重要度ベクトル \\(\\mathbf{w}^{(k)}\\) をそれぞれの一対比較行列 \\(\\mathbf{A}^{(k)}\\) から計算する．\n\\[\n\\mathbf{w}^{(1)} = \\begin{bmatrix}\n4/9 \\\\\n4/9 \\\\\n1/9 \\\\\n\\end{bmatrix}, \\quad\n\\mathbf{w}^{(2)} = \\begin{bmatrix}\n6/10 \\\\\n3/10 \\\\\n1/10 \\\\\n\\end{bmatrix}, \\quad\n\\mathbf{w}^{(3)} = \\begin{bmatrix}\n1/11 \\\\\n2/11 \\\\\n8/11 \\\\\n\\end{bmatrix}\n\\]\n評価基準の一対比較行列 \\(\\mathbf{B}\\) は以下のようになる．\n\\[\n\\mathbf{B} = \\begin{bmatrix}\n1 & 2 & 4 \\\\\n1/2 & 1 & 2 \\\\\n1/4 & 1/2 & 1 \\\\\n\\end{bmatrix}\n\\]\n重要度ベクトル \\(\\mathbf{v}\\) を一対比較行列 \\(\\mathbf{B}\\) から計算する．\n\\[\n\\mathbf{v} = \\begin{bmatrix}\n4/7 \\\\\n2/7 \\\\\n1/7 \\\\\n\\end{bmatrix}\n\\]\n最終的に，代替案の重要度ベクトル \\(\\mathbf{w}\\) は以下のように計算される．\n\\[\n\\mathbf{w} = \\sum_{k=1}^m v_k \\mathbf{w}^{(k)}\n= \\frac{4}{7} \\begin{bmatrix}\n4/9 \\\\\n4/9 \\\\\n1/9 \\\\\n\\end{bmatrix}\n+ \\frac{2}{7} \\begin{bmatrix}\n6/10 \\\\\n3/10 \\\\\n1/10 \\\\\n\\end{bmatrix}\n+ \\frac{1}{7} \\begin{bmatrix}\n1/11 \\\\\n2/11 \\\\\n8/11 \\\\\n\\end{bmatrix}\n\\approx \\begin{bmatrix}\n0.44 \\\\\n0.37 \\\\\n0.20 \\\\\n\\end{bmatrix}\n\\]\n\n\nコード\nimport numpy as np\n\nw1 = np.array([4/9, 4/9, 1/9])\nw2 = np.array([6/10, 3/10, 1/10])\nw3 = np.array([1/11, 2/11, 8/11])\nv = np.array([4/7, 2/7, 1/7])\nw = v[0] * w1 + v[1] * w2 + v[2] * w3\nw\n\n\narray([0.43838384, 0.36565657, 0.1959596 ])\n\n\nこのとき，重要度ベクトル \\(\\mathbf{w}\\) から，望ましい代替案は企業Aであることがわかる．\n\n\n\n\n\nBrunelli, Matteo. 2015. Introduction to the Analytic Hierarchy Process. 2015th 版. SpringerBriefs in Operations Research. Cham: Springer International Publishing.\n\n\nCrawford, Gordon, と Cindy Williams. 1985. 「A note on the analysis of subjective judgment matrices」. Journal of Mathematical Psychology, Some thoughts about the mathematics of the analytic hierarchy process, 29 (4): 387–405.\n\n\nSaaty, Thomas L. 1977. 「A scaling method for priorities in hierarchical structures」. J. Math. Psychol. 15 (3): 234–81.",
    "crumbs": [
      "多基準意思決定分析",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>階層分析法</span>"
    ]
  },
  {
    "objectID": "network/graph.html",
    "href": "network/graph.html",
    "title": "8  グラフ理論",
    "section": "",
    "text": "8.1 無向グラフ\nグラフ（graph）は、点（vertex）の集合\\(V\\)と辺（edge）の集合\\(E\\)から構成され、\\(G=(V,E)\\)で表される。\nグラフは、有向グラフ（directed graph）と無向グラフ（undirected graph）に分けられる。\n無向グラフは、辺の方向を持たないグラフである。辺は、2つの点の集合として表される。\nグラフ \\(G = (V, E)\\) において、\\(e = \\{v, u\\} \\in E\\) を満たすとき、点 \\(v\\) と \\(u\\) は隣接（adjacent）しているといい、\\(e\\) は \\(v\\) と \\(u\\) を接続（incident）しているという。\n点 \\(v\\) に接続している辺の数を、\\(v\\) の次数（degree）という。例 8.1 の場合、\\(v_1\\) の次数は 3、\\(v_2\\) の次数は 2 である。",
    "crumbs": [
      "ネットワーク最適化",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>グラフ理論</span>"
    ]
  },
  {
    "objectID": "network/graph.html#無向グラフ",
    "href": "network/graph.html#無向グラフ",
    "title": "8  グラフ理論",
    "section": "",
    "text": "例 8.1 (無向グラフの例) グラフ\n\\[\nG = ({v_1, v_2, v_3, v_4}, \\{\\{v_1,v_2\\},\\{v_2,v_3\\},\\{v_3,v_4\\},\\{v_4,v_1\\},\\{v_1,v_3\\}\\})\n\\]\nは、点の集合\\(V=\\{v_1,v_2,v_3,v_4\\}\\)と辺の集合\\(E=\\{\\{v_1,v_2\\},\\{v_2,v_3\\},\\{v_3,v_4\\},\\{v_4,v_1\\},\\{v_1,v_3\\}\\}\\)からなる。\n\n\nコード\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# グラフの作成（頂点を番号で定義）\nG = nx.Graph()\nG.add_edges_from([(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)])\n\n# 頂点ラベルを LaTeX 形式に変換\nlabels = {i: rf\"$v_{i}$\" for i in G.nodes()}\n\n# レイアウト（円形）\npos = nx.circular_layout(G)\n\n# ラベルの位置を少し外側へ移動\nlabel_pos = {}\nfor k, (x, y) in pos.items():\n    r = np.sqrt(x**2 + y**2)  # 原点からの距離\n    scale = 1.15  # 外側に押し出す係数（調整可）\n    label_pos[k] = (x / r * scale, y / r * scale)\n\nplt.figure(figsize=(4, 4))\n# ノード描画\nnx.draw_networkx_nodes(G, pos, node_color=\"black\", node_size=120, edgecolors=\"black\")\n# エッジ描画\nnx.draw_networkx_edges(G, pos, edge_color=\"black\", width=1.2)\n# 外側にラベル描画\nnx.draw_networkx_labels(G, label_pos, labels, font_size=12, font_weight=\"regular\")\nplt.axis(\"off\")\nplt.show()",
    "crumbs": [
      "ネットワーク最適化",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>グラフ理論</span>"
    ]
  },
  {
    "objectID": "network/graph.html#有向グラフ",
    "href": "network/graph.html#有向グラフ",
    "title": "8  グラフ理論",
    "section": "8.2 有向グラフ",
    "text": "8.2 有向グラフ\n有向グラフは、辺に方向があるグラフである。辺は、2つの点の順序対として表される。\n\n例 8.2 (有向グラフの例) グラフ\n\\[\nG = ({v_1, v_2, v_3, v_4}, \\{(v_1,v_2),(v_2,v_3),(v_3,v_4),(v_4,v_1),(v_1,v_3)\\})\n\\]\nは、点の集合\\(V=\\{v_1,v_2,v_3,v_4\\}\\)と辺の集合\\(E=\\{(v_1,v_2),(v_2,v_3),(v_3,v_4),(v_4,v_1),(v_1,v_3)\\}\\)からなる。\n\n\nコード\nimport networkx as nx\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# グラフの作成（頂点を番号で定義）\nG = nx.DiGraph()\nG.add_edges_from([(1, 2), (2, 3), (3, 4), (4, 1), (1, 3)])\n\n# 頂点ラベルを LaTeX 形式に変換\nlabels = {i: rf\"$v_{i}$\" for i in G.nodes()}\n\n# レイアウト（円形）\npos = nx.circular_layout(G)\n\n# ラベルの位置を少し外側へ移動\nlabel_pos = {}\nfor k, (x, y) in pos.items():\n    r = np.sqrt(x**2 + y**2)  # 原点からの距離\n    scale = 1.15  # 外側に押し出す係数（調整可）\n    label_pos[k] = (x / r * scale, y / r * scale)\n\nplt.figure(figsize=(4, 4))\n\n# ノード描画\nnx.draw_networkx_nodes(G, pos, node_color=\"black\", node_size=120, edgecolors=\"black\")\n\n# エッジ描画\nnx.draw_networkx_edges(G, pos, edge_color=\"black\", width=1.2, arrowsize=15)\n\n# 外側にラベル描画\nnx.draw_networkx_labels(G, label_pos, labels, font_size=12, font_weight=\"regular\")\n\nplt.axis(\"off\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\nグラフ \\(G = (V, E)\\) において、点 \\(v\\) から出る辺の数を出次数（outdegree）といい、点 \\(v\\) に入る辺の数を入次数（indegree）という。例 8.2 の場合、\\(v_1\\) の出次数は 2、入次数は 1 である。",
    "crumbs": [
      "ネットワーク最適化",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>グラフ理論</span>"
    ]
  },
  {
    "objectID": "network/graph.html#パス",
    "href": "network/graph.html#パス",
    "title": "8  グラフ理論",
    "section": "8.3 パス",
    "text": "8.3 パス\n\\(G = (V, E)\\) において、パス（path）\\(P\\) とは、点の組\n\\[\nP = (v_{i_1}, v_{i_2}, \\ldots, v_{i_k})\n\\]\nであって、各 \\(j = 1, 2, \\ldots, k-1\\) に対して \\((v_{i_j}, v_{i_{j+1}}) \\in E\\) を満たすものをいう。パスの長さ（length）は、パスに含まれる辺の数である。",
    "crumbs": [
      "ネットワーク最適化",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>グラフ理論</span>"
    ]
  },
  {
    "objectID": "pert/project.html",
    "href": "pert/project.html",
    "title": "9  クリティカルパス",
    "section": "",
    "text": "9.1 プロジェクト\nプロジェクトは、多くの作業からなる。プロジェクトを完遂できるように、作業のスケジュールを作成する必要がある。その方法として、PERT（Program Evaluation and Review Technique）とCPM（Critical Path Method）がある。現在では、PERTとCPMが統合され、PERT/CPMとして知られている(Camm ほか 2022; Hillier と Lieberman 2025)。\nここで、ある作業の開始前に完了しなければならない作業を先行作業（Immediate Predecessor）と呼ぶ。また、ある作業の完了後に開始できる作業を後続作業（Immediate Successor）と呼ぶ。\nまとめると、プロジェクトは、次の要素で構成される。",
    "crumbs": [
      "PERT/CPM",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クリティカルパス</span>"
    ]
  },
  {
    "objectID": "pert/project.html#プロジェクト",
    "href": "pert/project.html#プロジェクト",
    "title": "9  クリティカルパス",
    "section": "",
    "text": "作業：プロジェクトを構成する仕事。活動、アクティビティとも呼ばれる。\n先行関係：それぞれの作業の先行作業を定義する関係。\n作業時間：各作業に必要な時間。\n\n\n例 9.1 学生の田中さんと佐藤さんが協力し、ある授業のレポートを作成することになった。このレポートを作成するためには、下の表に示すように、いくつかの作業を行う必要がある。\n\n\n\n作業\n作業内容\n先行作業\n時間（日）\n\n\n\n\nA\n課題の理解\n-\n2\n\n\nB\nデータ収集\nA\n3\n\n\nC\nデータ分析\nB\n4\n\n\nD\n文献調査\nA\n2\n\n\nE\nレポート作成\nC, D\n5",
    "crumbs": [
      "PERT/CPM",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クリティカルパス</span>"
    ]
  },
  {
    "objectID": "pert/project.html#プロジェクトネットワーク",
    "href": "pert/project.html#プロジェクトネットワーク",
    "title": "9  クリティカルパス",
    "section": "9.2 プロジェクト・ネットワーク",
    "text": "9.2 プロジェクト・ネットワーク\nプロジェクトをネットワークで表現したものをプロジェクト・ネットワーク（Project Network）と呼ぶ。プロジェクト・ネットワークには、AOA（Activity on Arrow）や AON（Activity on Node）という 2 種類の表現方法がある。\nAOA では、作業を辺で表現し、先行関係を点で表現する。AON では、作業を点で表現し、先行関係を辺で表現する。AON のほうが理解と作成が容易で、実務でも AON がよく使われる(Camm ほか 2022; Hillier と Lieberman 2025; Eiselt と Sandblom 2022)。これは以降、AON に基づいて説明する。\nプロジェクト・ネットワークは \\(G = (V, E)\\) という有向グラフで表される。ここで、\\(V\\) は始点 \\(s\\)、終点 \\(t\\) と各作業を表す点の集合であり、\\(E\\) は先行関係を表す辺の集合である。辺 \\((v, u) \\in E\\) では、\\(v\\) が \\(u\\) の先行作業であることを意味する。\n辺 \\((s, v) \\in E\\) は、作業 \\(v\\) が先行作業を持たないことを意味し、辺 \\((v, t) \\in E\\) は、作業 \\(v\\) が後続作業を持たないことを意味する。作業 \\(v\\) の先行作業の集合を \\(\\mathcal{P}(v)\\) と表す。作業 \\(v\\) の後続作業の集合を \\(\\mathcal{S}(v)\\) と表す。\n作業点 \\(v \\in V\\) には、作業時間 \\(\\tau(v)\\) が与えられている。始点 \\(s\\) と終点 \\(t\\) の作業時間は \\(\\tau(s) = \\tau(t) = 0\\) とする。\n例 9.1 のプロジェクト・ネットワークは次の図のようになる。\n\n\nコード\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport numpy as np\n\n# グラフの作成（頂点を番号で定義）\nG = nx.DiGraph()\nedges = [\n    (\"s\", \"A\"),\n    (\"A\", \"B\"),\n    (\"A\", \"D\"),\n    (\"B\", \"C\"),\n    (\"C\", \"E\"),\n    (\"D\", \"E\"),\n    (\"E\", \"t\"),\n]\nG.add_edges_from(edges)\n\nfor layer, nodes in enumerate(nx.topological_generations(G)):\n    for node in nodes:\n        G.nodes[node][\"layer\"] = layer\n\npos = nx.multipartite_layout(G, subset_key=\"layer\")\n\nlabel_pos = {}\nfor k, (x, y) in pos.items():\n    r = np.sqrt(x**2 + y**2) if np.sqrt(x**2 + y**2) &gt; 0 else 1\n    scale = 1.12\n    label_pos[k] = (x * scale, y * scale)\n\n# Plotting\nnx.draw_networkx(\n    G,\n    pos=pos,\n    with_labels=True,\n    node_color=\"white\",\n    node_size=500,\n    edgecolors=\"black\",\n)\nplt.axis(\"off\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n例 9.2 以下の作業リストに基づいて、プロジェクト・ネットワークを作成せよ。\n\n\n\n作業\n先行作業\n時間（日）\n\n\n\n\nA\n-\n2\n\n\nB\n-\n3\n\n\nC\nA\n4\n\n\nD\nA\n2\n\n\nE\nB\n5\n\n\nF\nC, D, E\n9\n\n\nG\nE\n2\n\n\n\n\n\nコード\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport numpy as np\n\n# グラフの作成（頂点を番号で定義）\nG = nx.DiGraph()\nedges = [\n    (\"s\", \"A\"),\n    (\"s\", \"B\"),\n    (\"A\", \"C\"),\n    (\"A\", \"D\"),\n    (\"C\", \"F\"),\n    (\"D\", \"F\"),\n    (\"B\", \"E\"),\n    (\"E\", \"G\"),\n    (\"E\", \"F\"),\n    (\"G\", \"t\"),\n    (\"F\", \"t\"),\n]\nG.add_edges_from(edges)\n\nfor layer, nodes in enumerate(nx.topological_generations(G)):\n    for node in nodes:\n        G.nodes[node][\"layer\"] = layer\n\npos = nx.multipartite_layout(G, subset_key=\"layer\")\n\nlabel_pos = {}\nfor k, (x, y) in pos.items():\n    r = np.sqrt(x**2 + y**2) if np.sqrt(x**2 + y**2) &gt; 0 else 1\n    scale = 1.12\n    label_pos[k] = (x * scale, y * scale)\n\n# Plotting\nnx.draw_networkx(\n    G,\n    pos=pos,\n    with_labels=True,\n    node_color=\"white\",\n    node_size=500,\n    edgecolors=\"black\",\n)\nplt.axis(\"off\")\nplt.show()",
    "crumbs": [
      "PERT/CPM",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クリティカルパス</span>"
    ]
  },
  {
    "objectID": "pert/project.html#sec-critical-path",
    "href": "pert/project.html#sec-critical-path",
    "title": "9  クリティカルパス",
    "section": "9.3 クリティカルパス",
    "text": "9.3 クリティカルパス\nプロジェクト・ネットワークにおいて、始点 \\(s\\) から終点 \\(t\\) までの経路をパスと呼ぶ。パスの長さは、そのパス上の作業時間の合計である。パス \\(P = (s, v_{i_1}, v_{i_2}, \\ldots, v_{i_k}, t)\\) の長さは、\n\\[\n\\sum_{v \\in P} \\tau(v) = \\tau(v_{i_1}) + \\tau(v_{i_2}) + \\cdots + \\tau(v_{i_k})\n\\]\nである。\n最も長いパスをクリティカルパス（Critical Path）と呼ぶ。クリティカルパスに含まれる作業をクリティカル作業（Critical Activity）と呼ぶ。クリティカル作業が遅延すると、プロジェクト全体の完了が遅延する。\nクリティカルパスを求める問題は、最長路問題に帰着できるが、ここで述べる方法は、プロジェクトにおける様々な有用な情報も提供する。\n\n9.3.1 最早開始時刻と最早終了時刻\n作業点 \\(v \\in V\\) の最も早く開始できる時間を最早開始時刻（Earliest Start Time）と呼び、\\(ES(v)\\) と表す。\\(v\\) の最も早く終了できる時間を最早終了時刻（Earliest Finish Time）と呼び、\\(EF(v)\\) と表す。始点 \\(s\\) の最早開始時刻は \\(ES(s) = 0\\) とする。\n\\(v\\) の最早終了時刻は、最早開始時刻に作業時間を加えたものである。\n\\[\nEF(v) = ES(v) + \\tau(v)\n\\]\n\\(u\\) の最早開始時刻は、\\(u\\) の先行作業 \\(v \\in \\mathcal{P}(u)\\) の中で最早終了時刻 \\(EF(v)\\) が最大のものである。\n\\[\nES(u) = \\max_{v \\in \\mathcal{P}(u)} EF(v)\n\\]\nで与えられる。\n\n例 9.3 作業点 \\(D\\) の先行作業を \\(A, B, C\\) とする．そのとき，\\(\\mathcal{P}(D) = \\{A, B, C\\}\\) である．\\(EF(A) = 2\\)，\\(EF(B) = 3\\)，\\(EF(C) = 6\\) とすると，\\(D\\) の最早開始時刻は，\n\\[\nES(D) = \\max\\{EF(A), EF(B), EF(C)\\} = \\max\\{2, 3, 6\\} = 6\n\\]\nである．\n\n\nコード\nimport matplotlib.pyplot as plt\nimport networkx as nx\n\n# グラフの作成（頂点を番号で定義）\nG = nx.DiGraph()\nedges = [\n    (\"A\", \"D\"),\n    (\"B\", \"D\"),\n    (\"C\", \"D\"),\n]\nG.add_edges_from(edges)\n\n# A, B, C を縦に並べる\n\npos = {\n    \"A\": (0, 1),\n    \"B\": (0, 0),\n    \"C\": (0, -1),\n    \"D\": (2, 0),\n}\n# Plotting\nnx.draw_networkx(\n    G,\n    pos=pos,\n    with_labels=True,\n    node_color=\"white\",\n    node_size=500,\n    edgecolors=\"black\",\n)\nplt.axis(\"off\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n最早開始時刻と最早終了時刻を求めるアルゴリズムは下の通りである。ここで、点をトポロジカルオーダー(topological order)で処理するとは、\\(v\\) のすべての先行作業 \\(u \\in \\mathcal{P}(v)\\) が \\(v\\) より前に処理されるように点を順序付けることである。\n\nAlgorithm 9.1 Forward Pass Algorithm\n\n\\(ES(s) \\leftarrow 0\\), \\(EF(s) \\leftarrow 0\\).\nFor each \\(v \\in V \\setminus \\{s\\}\\) in topological order do\n\n\\(ES(v) \\leftarrow \\max_{u \\in \\mathcal{P}(v)} EF(u)\\).\n\\(EF(v) \\leftarrow ES(v) + \\tau(v)\\).\n\n\n\n例 9.2 のプロジェクト・ネットワークに対して、最早開始時刻と最早終了時刻を求めると、次の表のようになる。\n\n\n\n\\(v\\)\n\\(\\mathcal{P}(v)\\)\n\\(\\tau(v)\\)\n\\(ES(v)\\)\n\\(EF(v)\\)\n\n\n\n\ns\n-\n0\n0\n0\n\n\nA\ns\n2\n0\n2\n\n\nB\ns\n3\n0\n3\n\n\nC\nA\n4\n2\n6\n\n\nD\nA\n2\n2\n4\n\n\nE\nB\n5\n3\n8\n\n\nF\nC, D, E\n9\n8\n17\n\n\nG\nE\n2\n8\n10\n\n\nt\nF, G\n0\n17\n17\n\n\n\n作業 F を開始するためには、作業 C、D、E のすべてが完了している必要がある。そのため、作業 F の開始時間は、作業 C、D、E の中で最も遅い完了時間に依存する。作業 C、D、E の完了時間はそれぞれ 6 日、4 日、8 日であるため、作業 F の最も早い開始時間は 8 日となる。\n\n\n9.3.2 最遅開始時刻と最遅終了時刻\n作業点 \\(v\\) の遅くとも始めないといけない時間を最遅開始時刻（Latest Start Time）と呼び、\\(LS(v)\\) と表す。\\(v\\) の遅くとも終わらせないといけない時間を最遅終了時刻（Latest Finish Time）と呼び、\\(LF(v)\\) と表す。\n終点 \\(t\\) の最遅終了時刻は \\(LF(t) = EF(t)\\) とする。\n\\(v\\) の最遅開始時刻は、最遅終了時刻から作業時間を引いたものである。\n\\[\nLS(v) = LF(v) - \\tau(v)\n\\]\n\\(u\\) の最遅終了時刻は、\\(u\\) の後続作業 \\(v \\in \\mathcal{S}(u)\\) の中で \\(LS(v)\\) が最小のものである。\n\\[\nLF(u) = \\min_{v \\in \\mathcal{S}(u)} LS(v)\n\\]\n\n例 9.4 作業点 \\(C\\) の後続作業を \\(D, E, F\\) とする．そのとき，\\(\\mathcal{S}(C) = \\{D, E, F\\}\\) である．\\(LS(D) = 6\\)，\\(LS(E) = 3\\)，\\(LS(F) = 8\\) とすると，\\(C\\) の最遅終了時刻は， \\[\nLF(C) = \\min\\{LS(D), LS(E), LS(F)\\} = \\min\\{6, 3, 8\\} = 3\n\\] である．\n\n\nコード\nimport matplotlib.pyplot as plt\n\nimport networkx as nx\n\n# グラフの作成（頂点を番号で定義）\nG = nx.DiGraph()\nedges = [\n    (\"C\", \"D\"),\n    (\"C\", \"E\"),\n    (\"C\", \"F\"),\n]\nG.add_edges_from(edges)\n\npos = {\n    \"C\": (0, 0),\n    \"D\": (2, 1),\n    \"E\": (2, 0),\n    \"F\": (2, -1),\n}\n# Plotting\nnx.draw_networkx(\n    G,\n    pos=pos,\n    with_labels=True,\n    node_color=\"white\",\n    node_size=500,\n    edgecolors=\"black\",\n)\nplt.axis(\"off\")\nplt.show()\n\n\n\n\n\n\n\n\n\n\n例 9.2 のプロジェクト・ネットワークに対して、最遅開始時刻と最遅終了時刻を求めると、次の表のようになる。\n\n\n\n\\(v\\)\n\\(\\mathcal{S}(v)\\)\n\\(\\tau(v)\\)\n\\(LS(v)\\)\n\\(LF(v)\\)\n\n\n\n\ns\nA, B\n0\n0\n0\n\n\nA\nC, D\n2\n2\n4\n\n\nB\nE\n3\n0\n3\n\n\nC\nF\n4\n4\n8\n\n\nD\nF\n2\n6\n8\n\n\nE\nF, G\n5\n3\n8\n\n\nF\nt\n9\n8\n17\n\n\nG\nt\n2\n15\n17\n\n\nt\n-\n0\n17\n17\n\n\n\n最遅開始時刻と最遅終了時刻を求めるアルゴリズムは下の通りである。ここで、点を逆トポロジカルオーダー（reverse topological order）で処理するとは、\\(v\\) のすべての後続作業 \\(u \\in \\mathcal{S}(v)\\) が \\(v\\) より前に処理されるように点を順序付けることである。\n\nAlgorithm 9.2 Backward Pass Algorithm\n\n\\(LF(t) \\leftarrow EF(t)\\), \\(LS(t) \\leftarrow EF(t)\\).\nFor each \\(v \\in V \\setminus \\{t\\}\\) in reverse topological order do\n\n\\(LF(v) \\leftarrow \\min_{u \\in \\mathcal{S}(v)} LS(u)\\).\n\\(LS(v) \\leftarrow LF(v) - \\tau(v)\\).\n\n\n\n\n\n9.3.3 スラック\n作業点 \\(v\\) のスラック（Slack）を \\(SL(v)\\) と表す。スラックは、\n\\[\nSL(v) = LS(v) - ES(v) = LF(v) - EF(v)\n\\]\nで与えられる。スラックは、作業 \\(v\\) の開始または終了を遅らせることができる時間を示す。\n例 9.2 のプロジェクト・ネットワークに対して、スラックを求めると、次の表のようになる。\n\n\n\n\\(v\\)\n\\(\\tau(v)\\)\n\\(ES(v)\\)\n\\(EF(v)\\)\n\\(LS(v)\\)\n\\(LF(v)\\)\n\\(SL(v)\\)\n\n\n\n\ns\n0\n0\n0\n0\n0\n0\n\n\nA\n2\n0\n2\n2\n4\n2\n\n\nB\n3\n0\n3\n0\n3\n0\n\n\nC\n4\n2\n6\n4\n8\n2\n\n\nD\n2\n2\n4\n6\n8\n4\n\n\nE\n5\n3\n8\n3\n8\n0\n\n\nF\n9\n8\n17\n8\n17\n0\n\n\nG\n2\n8\n10\n15\n17\n7\n\n\nt\n0\n17\n17\n17\n17\n0\n\n\n\nスラックが 0 の作業はクリティカル作業である。したがって、例 9.2 のプロジェクト・ネットワークにおけるクリティカルパスは、\\(s \\to B \\to E \\to F \\to t\\) であり、このパスの長さは 17 日である。\n\n\n\n\nCamm, Jeffrey, James Cochran, Michael Fry, Jeffrey Ohlmann, David Anderson, Dennis Sweeney, と Thomas Williams. 2022. An introduction to management science: Quantitative approaches to decision making. 16th 版. Florence, AL: South-Western College Publishing.\n\n\nEiselt, H A, と Carl-Louis Sandblom. 2022. Operations research: A model-based approach. Cham: Springer International Publishing.\n\n\nHillier, Frederick, と Gerald Lieberman. 2025. ISE introduction to operations research. 11th 版. Columbus, OH: McGraw-Hill Education.",
    "crumbs": [
      "PERT/CPM",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>クリティカルパス</span>"
    ]
  },
  {
    "objectID": "pert/uncertain.html",
    "href": "pert/uncertain.html",
    "title": "10  不確実性を考慮したPERT/CPM",
    "section": "",
    "text": "10.1 3 点見積もり\n以上の方法では、作業の所要時間が確定していることを前提としている。しかし、実際には、所要時間の推定は難しい場合が多い。そこで、作業の所要時間を確率変数として扱い、3 点見積もり（Three-Point Estimation）という方法でその作業時間の平均と分散を推定する。\n3 点見積もりでは、次の 3 つの所要時間を事前に与えられたとする。\n一般に、\\(a \\leq m \\leq b\\) である。\nこの \\(a\\)、\\(m\\)、\\(b\\) に基づいて、所要時間の平均 \\(\\hat{\\mu}\\) と分散 \\(\\hat{\\sigma}^2\\) を次のように推定する。\n\\[\n\\hat{\\mu} = \\frac{a + 4m + b}{6}, \\quad \\hat{\\sigma}^2 = \\left(\\frac{b - a}{6}\\right)^2\n\\tag{10.1}\\]\nそこで、\\(\\mu(v)\\) と \\(\\sigma^2(v)\\) をそれぞれ作業点 \\(v\\) の所要時間の平均と分散とする。\\(a(v)\\)、\\(m(v)\\)、\\(b(v)\\) をそれぞれ作業点 \\(v\\) の楽観値、最頻値、悲観値とする。このとき、すべての作業点 \\(v \\in V\\) に対して、\n\\[\n\\mu(v) = \\frac{a(v) + 4m(v) + b(v)}{6}, \\quad \\sigma^2(v) = \\left(\\frac{b(v) - a(v)}{6}\\right)^2\n\\]\nで \\(\\mu(v)\\) と \\(\\sigma^2(v)\\) を計算する。\n例 9.2 のプロジェクト・ネットワークに対して、各作業点の楽観値、最頻値、悲観値が次のように与えられたとするとき、平均と分散を求めると、次の表のようになる。",
    "crumbs": [
      "PERT/CPM",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>不確実性を考慮したPERT/CPM</span>"
    ]
  },
  {
    "objectID": "pert/uncertain.html#点見積もり",
    "href": "pert/uncertain.html#点見積もり",
    "title": "10  不確実性を考慮したPERT/CPM",
    "section": "",
    "text": "楽観値（Optimistic Time, \\(a\\)）：予想される最短の所要時間。\n最頻値（Most Likely Time, \\(m\\)）：最も可能性が高い所要時間。\n悲観値（Pessimistic Time, \\(b\\)）：予想される最長の所要時間。\n\n\n\n\n\n\n\n\n\nノート\n\n\n\n作業の所要時間がベータ分布に従うと仮定した場合は、式 10.1 が \\(\\mu\\) と \\(\\sigma^2\\) の良い推定量となる。これらの式の詳細な導出は省略する。興味のある読者は、Pleguezuelo, Pérez, と Rambaud (2003) を参照されたい。\n\n\n\n\n\n\n\n\n\n\n\\(v\\)\n\\(a\\)\n\\(m\\)\n\\(b\\)\n\\(\\mu\\)\n\\(\\sigma^2\\)\n\n\n\n\ns\n0\n0\n0\n0\n0\n\n\nA\n0.5\n2\n3.5\n2\n0.25\n\n\nB\n1.5\n3\n4.5\n3\n0.25\n\n\nC\n1.5\n3\n4.5\n3\n0.25\n\n\nD\n0.5\n2\n3.5\n2\n0.25\n\n\nE\n1\n5.5\n7\n5\n1\n\n\nF\n5\n8\n17\n9\n4\n\n\nG\n0.5\n2\n3.5\n2\n0.25\n\n\nt\n0\n0\n0\n0\n0",
    "crumbs": [
      "PERT/CPM",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>不確実性を考慮したPERT/CPM</span>"
    ]
  },
  {
    "objectID": "pert/uncertain.html#不確実性を考慮したpertcpm",
    "href": "pert/uncertain.html#不確実性を考慮したpertcpm",
    "title": "10  不確実性を考慮したPERT/CPM",
    "section": "10.2 不確実性を考慮したPERT/CPM",
    "text": "10.2 不確実性を考慮したPERT/CPM\n3 点見積もりを用いて、各作業点 \\(v \\in V\\) の所要時間の平均 \\(\\mu(v)\\) と分散 \\(\\sigma^2(v)\\) を求めたとする。このとき、与えられた時間までにプロジェクトが完了する確率を求めたい。例えば，「プロジェクトが 30 日以内に完了する確率はどれくらいか？」という問いである。\nプロジェクト・ネットワークにおけるパス \\(P = (s, v_{i_1}, v_{i_2}, \\ldots, v_{i_k}, t)\\) の所要時間の平均 \\(\\mu(P)\\) と分散 \\(\\sigma^2(P)\\) は、それぞれ次のように推定できる。\n\\[\n\\mu(P) = \\sum_{v \\in P} \\mu(v), \\quad \\sigma^2(P) = \\sum_{v \\in P} \\sigma^2(v)\n\\]\nパス \\(P\\) の所要時間の標準偏差 \\(\\sigma(P)\\) は、\n\\[\n\\sigma(P) = \\sqrt{\\sigma^2(P)}\n\\]\nで与えられる。求められたパスの中で、所要時間の平均 \\(\\mu(P)\\) が最大のパスをクリティカルパス \\(P^*\\) とする。セクション 9.3 で述べた方法でクリティカルパスを求めることができる。\nクリティカルパス \\(P^*\\) の所要時間を \\(X\\) とし、与えられた時間 \\(d\\) までにプロジェクトが完了する確率を \\(\\mathbb{P}(X \\leq d)\\) と表す。\n\n\n\n\n\n\nノート\n\n\n\nここでは、計算を簡単にするために、クリティカルパスが最も時間がかかるパスであると仮定している。しかし，実際には、平均値から計算されたクリティカルパスが、最も時間がかかるパスであるとは限らない。これにより，クリティカルパスをを用いて計算された確率は，実際の確率よりも過大評価される可能性がある。\nここで述べる方法をすべてのパスに適用し、各パスの確率を計算すれば、より正確な確率を得ることができる\n\n\n\\[\n\\mathbb{P}(X \\leq d) = \\phi\\left(\\frac{d - \\mu(P^*)}{\\sigma(P^*)}\\right)\n\\]\nここで、\\(\\phi(z)\\) は標準正規分布の確率密度関数である。\\(z\\) は次のように計算し、標準正規分布表を用いて \\(\\phi(z)\\) を調べる。\n\\[\nz = \\frac{d - \\mu(P^*)}{\\sigma(P^*)}\n\\]\n例 9.2 では、クリティカルパスは \\(s \\to B \\to E \\to F \\to t\\) であり、このパスの所要時間の平均、分散、標準偏差は次のように計算できる。\n\\[\n\\mu(P^*) = 3 + 5 + 9 = 17\n\\]\n\\[\n\\sigma^2(P^*) = 0.25 + 1 + 4 = 5.25\n\\]\n\\[\n\\sigma(P^*) = \\sqrt{5.25} \\approx 2.29\n\\]\n与えられた時間 \\(d = 20\\) 日までにプロジェクトが完了する確率を求めるには、次のように計算する。\n\\(z\\) を計算すると、\n\\[\nz = \\frac{20 - 17}{2.29} \\approx 1.31\n\\]\n標準正規分布表を用いて、\\(\\phi(1.31) \\approx 0.9049\\) である。したがって、与えられた時間 \\(d = 20\\) 日までにプロジェクトが完了する確率は約 90.49% である。\n\n\n\n\nPleguezuelo, Rafael Herrerı́as, José Garcı́a Pérez, と Salvador Cruz Rambaud. 2003. 「A note on the reasonableness of PERT hypotheses」. Oper. Res. Lett. 31 (1): 60–62.",
    "crumbs": [
      "PERT/CPM",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>不確実性を考慮したPERT/CPM</span>"
    ]
  },
  {
    "objectID": "pert/tradeoff.html",
    "href": "pert/tradeoff.html",
    "title": "11  時間とコストのトレードオフ",
    "section": "",
    "text": "11.1 時間とコストのトレードオフ\nプロジェクトの所要時間を短縮するために、追加のコストをかけて作業時間を短縮することができる場合がある。このような場合、決められた時間までにプロジェクトを完了するために、どの作業をどれだけ短縮すればよいかを決定する問題を考える。",
    "crumbs": [
      "PERT/CPM",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>時間とコストのトレードオフ</span>"
    ]
  },
  {
    "objectID": "pert/tradeoff.html#時間とコストのトレードオフ",
    "href": "pert/tradeoff.html#時間とコストのトレードオフ",
    "title": "11  時間とコストのトレードオフ",
    "section": "",
    "text": "11.1.1 問題の定式化\nプロジェクト・ネットワーク \\(G = (V, E)\\) に対して、各作業点 \\(i \\in V\\) に次のパラメータが与えられるとする。\n\n\\(c_i\\): 作業 \\(i\\) の単位時間あたりの短縮コスト\n\\(M_i\\): 作業 \\(i\\) の最大短縮時間\n\\(T\\): プロジェクトの完了時間の上限\n\\(\\tau_i\\): 作業 \\(i\\) の標準所要時間\n\n決定変数は次の通りである。\n\n\\(y_i\\): 作業 \\(i\\) の開始時間\n\\(x_i\\): 作業 \\(i\\) の短縮時間\n\nプロジェクトの所要時間を短縮するためのコストは\n\\[\n\\sum_{i \\in V} c_i x_i\n\\]\nで与えられる。\\(j\\) が \\(i\\) の後続作業である場合，作業 \\(j\\) はすべての先行作業 \\(i\\) が完了した後に開始できるため，\n\\[\ny_j \\geq y_i + \\tau_i - x_i , \\quad \\forall (i, j) \\in E\n\\]\nがある．また、各作業の最大短縮時間 \\(M_i\\) により、すべての作業 \\(i \\in V\\) について、\n\\[\n0 \\leq x_i \\leq M_i\n\\]\nである。プロジェクト全体の完了時間は終点 \\(t\\) の終了時間 \\(y_t\\) であり、これが上限 \\(T\\) 以下である必要があるから、\n\\[\ny_t \\leq T\n\\] である。始点 \\(s\\) の開始時間は 0 とするから、 \\[\ny_s = 0\n\\] である。\nこのとき、この問題は次の線形計画問題として定式化できる。\n\\[\\begin{align*}\n\\text{minimize} \\quad & \\sum_{i \\in V} c_i x_i &\\\\\n\\text{subject to} \\quad & y_j \\geq y_i + \\tau_i - x_i, \\quad & \\forall (i, j) \\in E \\\\\n& 0 \\leq x_i \\leq M_i, \\quad & \\forall i \\in V \\\\\n& y_t \\leq T \\\\\n& y_s = 0\n\\end{align*}\\]\n\n\n11.1.2 例題\nプロジェクト・ネットワークはグラフ \\(G = (V, E)\\) で表す。作業の集合は\n\\[\nV = \\{s, t, A, B, C, D, E\\}\n\\] であり、辺の集合は\n\\[\nE = \\{(s, A), (s, C), (A, B), (C, D), (B, E), (D, E), (E, t)\\}\n\\] である。ここで、\\(s\\) は始点、\\(t\\) は終点である。プロジェクト全体の所要時間の上限を \\(T = 10\\) とする。\n作業時間、コスト、最大短縮時間は次の表のように与えられる。\n\n\n\n作業\n\\(\\tau_i\\)\n\\(c_i\\)\n\\(M_i\\)\n\n\n\n\nA\n7\n100\n3\n\n\nB\n3\n150\n1\n\n\nC\n6\n200\n2\n\n\nD\n3\n150\n2\n\n\nE\n2\n250\n1\n\n\n\nこの問題を次のように定式化できる。\n\\[\\begin{align*}\n\\text{minimize} \\quad & 100x_A + 150x_B + 200x_C + 150x_D + 250x_E &\\\\\n\\text{subject to} \\quad & y_A \\geq 0 \\\\\n& y_C \\geq 0 \\\\\n& y_B \\geq y_A + 7 - x_A \\\\\n& y_D \\geq y_C + 6 - x_C \\\\\n& y_E \\geq y_B + 3 - x_B \\\\\n& y_E \\geq y_D + 3 - x_D \\\\\n& y_t \\geq y_E + 2 - x_E \\\\\n& 0 \\leq x_A \\leq 3 \\\\\n& 0 \\leq x_B \\leq 1 \\\\\n& 0 \\leq x_C \\leq 2 \\\\\n& 0 \\leq x_D \\leq 2 \\\\\n& 0 \\leq x_E \\leq 1 \\\\\n& y_t \\leq 10 \\\\\n& y_s = 0\n\\end{align*}\\]\nこの線形計画問題は、最適化ソルバーを用いて解くことができる。以下に Gurobi を用いた実装例を示す。\n!pip install gurobipy\nfrom gurobipy import Model, GRB\n\n# データ定義\nV = [\"s\", \"t\", \"A\", \"B\", \"C\", \"D\", \"E\"]\nE = [(\"s\", \"A\"), (\"s\", \"C\"), (\"A\", \"B\"), (\"C\", \"D\"), (\"B\", \"E\"), (\"D\", \"E\"), (\"E\", \"t\")]\n\ntau = {\"A\": 7, \"B\": 3, \"C\": 6, \"D\": 3, \"E\": 2}\ncost = {\"A\": 100, \"B\": 150, \"C\": 200, \"D\": 150, \"E\": 250}\nM = {\"A\": 3, \"B\": 1, \"C\": 2, \"D\": 2, \"E\": 1}\n\nT = 10\n\n# モデル作成\nm = Model(\"Project_Crashing\")\nm.setParam(\"OutputFlag\", 0) \n\n# 変数定義\nx = {i: m.addVar(lb=0, ub=M[i], name=\"x_{}\".format(i)) for i in M}\ny = {i: m.addVar(lb=0, name=\"y_{}\".format(i)) for i in V}\n\n# 目的関数\nm.setObjective(sum(cost[i] * x[i] for i in M), GRB.MINIMIZE)\n\n# 制約\nfor i, j in E:\n    if i == \"s\":\n        m.addConstr(y[j] &gt;= 0)\n    elif i in tau:\n        m.addConstr(y[j] &gt;= y[i] + tau[i] - x[i])\n\n# プロジェクト終了制約\nm.addConstr(y[\"t\"] &lt;= T)\n\n# 開始ノード固定\nm.addConstr(y[\"s\"] == 0)\n\n# 最適化\nm.optimize()\n\n# 結果表示\nprint(\"Objective:\", m.objVal)\nfor i in x:\n    print(\"x_{} =\".format(i), x[i].X)\nfor i in y:\n    print(\"y_{} =\".format(i), y[i].X)\nObjective: 350.0\nx_A = 1.0\nx_B = 0.0\nx_C = 0.0\nx_D = 0.0\nx_E = 1.0\ny_s = 0.0\ny_t = 10.0\ny_A = 0.0\ny_B = 6.0\ny_C = 0.0\ny_D = 6.0\ny_E = 9.0\nこの結果から、作業 A を 1 日、作業 E を 1 日短縮することで、最小コスト 350 でプロジェクトを 10 日以内に完了できることがわかる。",
    "crumbs": [
      "PERT/CPM",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>時間とコストのトレードオフ</span>"
    ]
  },
  {
    "objectID": "pert/tradeoff.html#文献案内",
    "href": "pert/tradeoff.html#文献案内",
    "title": "11  時間とコストのトレードオフ",
    "section": "11.2 文献案内",
    "text": "11.2 文献案内",
    "crumbs": [
      "PERT/CPM",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>時間とコストのトレードオフ</span>"
    ]
  },
  {
    "objectID": "pert/tradeoff.html#練習問題",
    "href": "pert/tradeoff.html#練習問題",
    "title": "11  時間とコストのトレードオフ",
    "section": "11.3 練習問題",
    "text": "11.3 練習問題\n\n練習 11.1 次の作業リストに基づいて、以下の問いに答えよ。\n\n\n\n作業\n先行作業\n時間（日）\n\n\n\n\nA\n-\n4\n\n\nB\n-\n3\n\n\nC\nA\n2\n\n\nD\nA\n5\n\n\nE\nB\n6\n\n\nF\nC, D\n4\n\n\nG\nE\n3\n\n\n\n\nプロジェクト・ネットワークをAONで書け。\n各作業の最早開始時刻、最早終了時刻、最遅開始時刻、最遅終了時刻、スラックを求めよ。\nこのプロジェクトのクリティカルパスを求めよ。\n\n\n\n解答 11.1. \n\nプロジェクト・ネットワークは次のようになる。\n\n\n\nコード\nimport matplotlib.pyplot as plt\nimport networkx as nx\nimport numpy as np\n\n# グラフの作成（頂点を番号で定義）\nG = nx.DiGraph()\nedges = [\n    (\"s\", \"A\"),\n    (\"s\", \"B\"),\n    (\"A\", \"C\"),\n    (\"A\", \"D\"),\n    (\"C\", \"F\"),\n    (\"D\", \"F\"),\n    (\"B\", \"E\"),\n    (\"E\", \"G\"),\n    (\"F\", \"t\"),\n    (\"G\", \"t\"),\n]\nG.add_edges_from(edges)\nfor layer, nodes in enumerate(nx.topological_generations(G)):\n    for node in nodes:\n        G.nodes[node][\"layer\"] = layer\npos = nx.multipartite_layout(G, subset_key=\"layer\") \nlabel_pos = {}\nfor k, (x, y) in pos.items():\n    r = np.sqrt(x**2 + y**2) if np.sqrt(x**2 + y**2) &gt; 0 else 1\n    scale = 1.12\n    label_pos[k] = (x * scale, y * scale)\n# Plotting\nnx.draw_networkx(\n    G,\n    pos=pos,\n    with_labels=True,\n    node_color=\"white\",\n    node_size=500,\n    edgecolors=\"black\",\n)\nplt.axis(\"off\")\nplt.show()\n\n\n\n\n\n\n\n\n\n2~3. 省略",
    "crumbs": [
      "PERT/CPM",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>時間とコストのトレードオフ</span>"
    ]
  },
  {
    "objectID": "dea/intro.html",
    "href": "dea/intro.html",
    "title": "12  入力と出力",
    "section": "",
    "text": "12.1 1入力1出力\nデータ包絡分析（DEA: Data Envelopment Analysis）は，分析対象の効率性を評価するための手法である．DEAでは，分析対象のことをDMU（Decision Making Unit）と呼ばれ，複数の入力（input）から複数の出力（output）への変換を行うものである．\n下の表は，いくつかのDMUの例を示している．\n\\(n\\) 個のDMUがあり，\\(\\text{DMU}_j\\) (\\(j=1,2,\\ldots,n\\)) は1つの入力 \\(x_j\\) と1つの出力 \\(y_j\\) を持つとする．そのとき，\\(\\text{DMU}_j\\) の効率性は\n\\[\n\\frac{y_j}{x_j}\n\\]\nで評価できる．単位入力あたりの出力を表している．この値が大きいほど，効率的であると評価できる．",
    "crumbs": [
      "データ包絡分析",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>入力と出力</span>"
    ]
  },
  {
    "objectID": "dea/intro.html#入力1出力",
    "href": "dea/intro.html#入力1出力",
    "title": "12  入力と出力",
    "section": "",
    "text": "例 12.1 (1入力1出力の問題例) ある会社は，以下の6つの店舗を運営している．効率的である店舗はどれか．\n\n\n\n店舗\nA\nB\nC\nD\nE\nF\n\n\n\n\n店員数（\\(x\\)）\n2\n3\n3\n4\n2\n5\n\n\n売上高（\\(y\\)）\n1\n3\n2\n3\n2\n2\n\n\n\n\\(\\text{DMU}_j\\) の店員数を \\(x_j\\)，売上高を \\(y_j\\) とすると，店舗 \\(j\\) の効率性は \\(y_j/x_j\\) で計算できる．結果から，\\(B, E\\) が最も効率的であることがわかる．\n\n\nコード\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndata = {\n    \"store\": [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"],\n    \"employee\": [2, 3, 3, 4, 2, 5],\n    \"sale\": [1, 3, 2, 3, 2, 2],\n}\ndf = pd.DataFrame(data)\ndf[\"theta\"] = df[\"sale\"] / df[\"employee\"]\nprint(df)\n\n\n  store  employee  sale     theta\n0     A         2     1  0.500000\n1     B         3     3  1.000000\n2     C         3     2  0.666667\n3     D         4     3  0.750000\n4     E         2     2  1.000000\n5     F         5     2  0.400000\n\n\n横軸に店員数，縦軸に売上高をとって，点 \\((x_j, y_j)\\) をプロットした散布図を下の図に示す．原点から点 \\((x_j, y_j)\\) を結ぶ直線の傾きは，\\(y_j/x_j\\) に等しい．\n\n\nコード\nplt.scatter(df[\"employee\"], df[\"sale\"])\nfor i in range(len(df)):\n    plt.text(df[\"employee\"][i] + 0.1, df[\"sale\"][i], df[\"store\"][i])\nplt.plot([0, 4], [0, 4], color=\"red\", linestyle=\"--\", label=\"efficient frontier\")\nplt.xlabel(\"Employee\")\nplt.ylabel(\"Sale\")\nplt.xlim(0, 6)\nplt.ylim(0, 4)\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n店舗BとEは，効率的（efficient）と言える．また，原点から店舗B（または店舗E）を結ぶ直線を効率的フロンティア（efficient frontier）と呼ぶ．",
    "crumbs": [
      "データ包絡分析",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>入力と出力</span>"
    ]
  },
  {
    "objectID": "dea/intro.html#入力1出力-1",
    "href": "dea/intro.html#入力1出力-1",
    "title": "12  入力と出力",
    "section": "12.2 2入力1出力",
    "text": "12.2 2入力1出力\n\n例 12.2 (2入力1出力の問題例) ある会社は，以下の6つの店舗を運営している．効率的である店舗はどれか．\n\n\n\n店舗\nA\nB\nC\nD\nE\nF\n\n\n\n\n店員数\n4\n7\n8\n4\n2\n5\n\n\n面積\n3\n3\n1\n2\n4\n2\n\n\n売上高\n1\n1\n1\n1\n1\n1\n\n\n\n\\(\\text{DMU}_j\\) の店員数を \\(x_{j}\\)，面積を \\(y_{j}\\)，売上高を \\(z_{j}\\) とする．それぞれの店舗に対して，次の2つの比率を計算する．\n\\[\n\\frac{x_{j}}{z_{j}},\\quad \\frac{y_{j}}{z_{j}}\n\\]\nこれらの値が小さいほど，効率的であると評価できる．\n\\(x_{j}/z_{j}\\) と \\(y_{j}/z_{j}\\) を横軸と縦軸にとった散布図を下の図に示す．\n\n\nコード\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndata = {\n    \"store\": [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"],\n    \"employee\": [4, 7, 8, 4, 2, 5],\n    \"area\": [3, 3, 1, 2, 4, 2],\n    \"sale\": [1, 1, 1, 1, 1, 1],\n}\ndf = pd.DataFrame(data)\nplt.figure(figsize=(8, 6))\nplt.scatter(df[\"employee\"], df[\"area\"])\nfor i in range(len(df)):\n    plt.text(df[\"employee\"][i] + 0.1, df[\"area\"][i], df[\"store\"][i])\nplt.plot(\n    [2, 2, 4, 8, 11],\n    [5, 4, 2, 1, 1],\n    color=\"red\",\n    linestyle=\"--\",\n    label=\"efficient frontier\",\n)\nplt.xlabel(\"Employee/Sale\")\nplt.ylabel(\"Area/Sale\")\nplt.xlim(0, 11)\nplt.ylim(0, 5)\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\nDEAでは，任意の両点の線分上の点が実現可能であると仮定する．例えば，点 \\(D\\) と点 \\(E\\) を用いて，\\((wx_D + (1-w)x_E, wy_D + (1-w)y_E)\\) で表される点は，実現可能であると仮定する．\n\\(C, D, E\\) は効率的で，これらの点を結ぶ折れ線が効率的フロンティアとなる．",
    "crumbs": [
      "データ包絡分析",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>入力と出力</span>"
    ]
  },
  {
    "objectID": "dea/intro.html#入力2出力",
    "href": "dea/intro.html#入力2出力",
    "title": "12  入力と出力",
    "section": "12.3 1入力2出力",
    "text": "12.3 1入力2出力\n\n例 12.3 (1入力2出力の問題例) ある会社は，以下の6つの店舗を運営している．効率的である店舗はどれか．\n\n\n\n店舗\nA\nB\nC\nD\nE\nF\n\n\n\n\n店員数\n1\n1\n1\n1\n1\n1\n\n\n売上高\n1\n2\n3\n4\n4\n6\n\n\n顧客数\n5\n7\n4\n3\n6\n2\n\n\n\n\\(\\text{DMU}_j\\) の店員数を \\(x_{j}\\)，売上高を \\(y_{j}\\)，顧客数を \\(z_{j}\\) とする．それぞれの店舗に対して，次の2つの比率を計算する．\n\\[\n\\frac{y_{j}}{x_{j}},\\quad \\frac{z_{j}}{x_{j}}\n\\]\nこれらの値が大きいほど，効率的であると評価できる．\n\n\nコード\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndata = {\n    \"store\": [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"],\n    \"employee\": [1, 1, 1, 1, 1, 1],\n    \"sale\": [1, 2, 3, 4, 4, 6],\n    \"customer\": [5, 7, 4, 3, 6, 2],\n}\ndf = pd.DataFrame(data)\nplt.figure(figsize=(8, 6))\nplt.scatter(df[\"sale\"], df[\"customer\"])\nfor i in range(len(df)):\n    plt.text(df[\"sale\"][i] + 0.1, df[\"customer\"][i], df[\"store\"][i])\nplt.plot(\n    [0, 2, 4, 6, 6],\n    [7, 7, 6, 2, 0],\n    color=\"red\",\n    linestyle=\"--\",\n    label=\"efficient frontier\",\n)\nplt.xlabel(\"sale/employee\")\nplt.ylabel(\"customer/employee\")\nplt.xlim(0, 7)\nplt.ylim(0, 8)\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n店舗B，E，Fは効率的で，これらの点を結ぶ折れ線が効率的フロンティアとなる．",
    "crumbs": [
      "データ包絡分析",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>入力と出力</span>"
    ]
  },
  {
    "objectID": "dea/intro.html#用語集",
    "href": "dea/intro.html#用語集",
    "title": "12  入力と出力",
    "section": "12.4 用語集",
    "text": "12.4 用語集\n\n\n\nEnglish\nJapanese\n\n\n\n\nData Envelopment Analysis (DEA)\nデータ包絡分析\n\n\nDecision Making Unit (DMU)\n意思決定主体；意思決定単位\n\n\nReference Set\n参照集合\n\n\nEfficient\n効率的\n\n\nEfficient Frontier\n効率的フロンティア",
    "crumbs": [
      "データ包絡分析",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>入力と出力</span>"
    ]
  },
  {
    "objectID": "dea/intro.html#練習問題",
    "href": "dea/intro.html#練習問題",
    "title": "12  入力と出力",
    "section": "12.5 練習問題",
    "text": "12.5 練習問題\n\n練習 12.1 (1入力1出力) 次の表のような入力と出力が与えられたとき，効率的なDMUを求めよ．効率性を \\([0,1]\\) の範囲で評価せよ．\n\n\n\nDMU\nA\nB\nC\nD\nE\n\n\n\n\n入力\n4\n7\n8\n5\n6\n\n\n出力\n2\n7\n9\n4\n5\n\n\n\n\n\n解答 12.1. \n\n\nコード\nimport pandas as pd\n\ndata = {\n    \"DMU\": [\"A\", \"B\", \"C\", \"D\", \"E\"],\n    \"input\": [4, 7, 8, 5, 6],\n    \"output\": [2, 7, 9, 4, 5],\n}\ndf = pd.DataFrame(data)\ndf[\"efficiency\"] = df[\"output\"] / df[\"input\"]\nprint(df)\n\n\n  DMU  input  output  efficiency\n0   A      4       2    0.500000\n1   B      7       7    1.000000\n2   C      8       9    1.125000\n3   D      5       4    0.800000\n4   E      6       5    0.833333\n\n\n\n\n練習 12.2 (2入力1出力) 次の表のような入力と出力が与えられたとき，効率的なDMUを求めよ．\n\n\n\nDMU\nA\nB\nC\nD\nE\n\n\n\n\n入力1\n6\n6\n12\n4\n15\n\n\n入力2\n4\n12\n9\n8\n5\n\n\n出力\n2\n6\n3\n2\n5\n\n\n\n\n\n解答 12.2. 下の図より，DMU B，Dが効率的であることがわかる．\n\n\nコード\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndata = {\n    \"DMU\": [\"A\", \"B\", \"C\", \"D\", \"E\"],\n    \"input1\": [6, 6, 12, 4, 15],\n    \"input2\": [4, 12, 9, 8, 5],\n    \"output\": [2, 6, 3, 2, 5],\n}\ndf = pd.DataFrame(data)\nx = df[\"input1\"] / df[\"output\"]\ny = df[\"input2\"] / df[\"output\"]\nplt.scatter(x, y)\nfor i in range(len(df)):\n    plt.text(x[i] + 0.1, y[i], df[\"DMU\"][i])\n# 効率的フロンティアの描画 B-E\nplt.plot(\n    [1, 1, 3, 6],\n    [6, 2, 1, 1],\n    color=\"red\",\n    linestyle=\"--\",\n    label=\"efficient frontier\",\n)\nplt.xlabel(\"input1/output\")\nplt.ylabel(\"input2/output\")\nplt.xlim(0, 6)\nplt.ylim(0, 6)\nplt.grid()\nplt.show()",
    "crumbs": [
      "データ包絡分析",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>入力と出力</span>"
    ]
  },
  {
    "objectID": "dea/ccr.html",
    "href": "dea/ccr.html",
    "title": "13  CCRモデル",
    "section": "",
    "text": "13.0.1 CCRモデルの定式化\nCCRモデルは，1978年にCharnes, Cooper, and Rhodesによって提案されたもので，DEAの基本的なモデルである．\n\\(n\\) 個のDMUを評価する．各DMUは \\(m\\) 個の入力と \\(s\\) 個の出力を持つとする．\\(\\text{DMU}_j\\) (\\(j=1,2,\\ldots,n\\)) の \\(i\\) 番目の入力を \\(x_{ij}\\)，\\(r\\) 番目の出力を \\(y_{rj}\\) と表す．このとき，入力データと出力データはそれぞれ次のような行列で表される．\n\\[\n\\mathbf{X} =\n\\begin{pmatrix}\nx_{11} & x_{12} & \\cdots & x_{1n} \\\\\nx_{21} & x_{22} & \\cdots & x_{2n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nx_{m1} & x_{m2} & \\cdots & x_{mn}\n\\end{pmatrix}\n\\]\n\\[\n\\mathbf{Y} =\n\\begin{pmatrix}\ny_{11} & y_{12} & \\cdots & y_{1n} \\\\\ny_{21} & y_{22} & \\cdots & y_{2n} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\ny_{s1} & y_{s2} & \\cdots & y_{sn}\n\\end{pmatrix}\n\\]\n入力の重み \\(\\mathbf{v}\\) と出力の重み \\(\\mathbf{u}\\) を \\[\n\\mathbf{v} =\n\\begin{pmatrix}\nv_1 \\\\ v_2 \\\\ \\vdots \\\\ v_m\n\\end{pmatrix},\\quad\n\\mathbf{u} =\n\\begin{pmatrix}\nu_1 \\\\ u_2 \\\\ \\vdots \\\\ u_s\n\\end{pmatrix}\n\\]\nとし，\\(\\text{DMU}_o\\) の効率性 \\(\\theta\\) は\n\\[\n\\theta = \\frac{\\sum_{r=1}^{s} u_r y_{ro}}{\\sum_{i=1}^{m} v_i x_{io}} = \\frac{u_1 y_{1o} + u_2 y_{2o} + \\cdots + u_s y_{so}}{v_1 x_{1o} + v_2 x_{2o} + \\cdots + v_m x_{mo}}\n\\]\nとして計算できる．\nCCRモデルの考え方は，\\(\\text{DMU}_o\\) の効率性を最大化するような重み \\(\\mathbf{u}\\) と \\(\\mathbf{v}\\) を選ぶことである．\\(\\text{DMU}_o\\) は最適な重みを用いたとき，他のDMUとの比較を行う．\nCCRモデルは，\\(\\text{DMU}_o\\) の効率性 \\(\\theta\\) を最大化する重み \\(\\mathbf{u^*}\\) と \\(\\mathbf{v^*}\\) を求める．目的関数は，以下のようになる．\n\\[\n\\text{maximize} \\quad \\theta = \\frac{\\sum_{r=1}^{s} u_r y_{ro}}{\\sum_{i=1}^{m} v_i x_{io}}\n\\]\nそこで，制約条件として，すべてのDMUの効率性が1以下であることを課す．すなわち，すべての \\(j = 1, 2, \\ldots, n\\) について，次の不等式を満たす必要がある．\n\\[\n\\frac{\\sum_{r=1}^{s} u_r y_{rj}}{\\sum_{i=1}^{m} v_i x_{ij}} \\leq 1, \\quad \\forall j = 1, 2, \\ldots, n\n\\]\nまた，重みは非負である必要があるため，\\(\\mathbf{u} \\geq \\mathbf{0}\\)，\\(\\mathbf{v} \\geq \\mathbf{0}\\) とする．\nしたがって，CCRモデルは次の分数計画問題として定式化できる．\n\\[\\begin{align*}\n\\text{maximize} \\quad & \\theta = \\frac{\\sum_{r=1}^{s} u_r y_{ro}}{\\sum_{i=1}^{m} v_i x_{io}} & \\\\\n\\text{subject to} \\quad & \\frac{\\sum_{r=1}^{s} u_r y_{rj}}{\\sum_{i=1}^{m} v_i x_{ij}} \\leq 1, \\quad & \\forall j = 1, \\ldots, n & \\\\\n& u_r \\geq 0, \\quad & \\forall r = 1, \\ldots, s & \\\\\n& v_i \\geq 0, \\quad & \\forall i = 1, \\ldots, m\n\\end{align*}\\]\nこの分数計画問題は，\\(\\text{DMU}_o\\) の効率性 \\(\\theta\\) を最大化する重み \\(\\mathbf{u^*}\\) と \\(\\mathbf{v^*}\\) を求めるものである．制約条件は，すべてのDMUの効率性が1以下であることを保証している．\nこの分数計画問題において，任意の \\(\\alpha &gt; 0\\) に対して，\\((\\mathbf{u}^*, \\mathbf{v}^*)\\) を最適解とすると，\\((\\alpha \\mathbf{u}^*, \\alpha \\mathbf{v}^*)\\) も最適解となる．\nしたがって，この分数計画問題は無限に多くの最適解を持つ．この問題を解決するために，分母を1に固定することで，次の線形計画問題に変換できる．\n\\[\\begin{align*}\n\\text{maximize} \\quad & \\theta = \\sum_{r=1}^{s} u_r y_{ro} & \\\\\n\\text{subject to} \\quad & \\sum_{i=1}^{m} v_i x_{io} = 1 & \\\\\n& \\sum_{r=1}^{s} u_r y_{rj} - \\sum_{i=1}^{m} v_i x_{ij} \\leq 0, \\quad & \\forall j = 1, \\ldots, n & \\\\\n& u_r \\geq 0, \\quad & \\forall r = 1, \\ldots, s & \\\\\n& v_i \\geq 0, \\quad & \\forall i = 1, \\ldots, m\n\\end{align*}\\]\n\\(\\theta^* &lt; 1\\) のとき，少なくとも1つの \\(j \\in \\{1,2,\\ldots,n\\} \\setminus \\{o\\}\\) について，次の式が成り立つ．\n\\[\n\\sum_{r=1}^{s} u_r^* y_{rj} - \\sum_{i=1}^{m} v_i^* x_{ij} = 0\n\\]\nそうでなければ，\\(\\theta\\) を増加させることができる．正式に，\\(\\text{DMU}_o\\) における \\(\\theta^* &lt; 1\\) のとき，次の集合を\\(\\text{DMU}_o\\) の参照集合（reference set）と呼ぶ．\n\\[\n\\mathcal{R}_o = \\{ j \\mid \\sum_{r=1}^{s} u_r^* y_{rj} - \\sum_{i=1}^{m} v_i^* x_{ij} = 0 \\}\n\\]\n参照集合 \\(\\mathcal{R}_o\\) は，\\(\\text{DMU}_o\\) を非効率的にしているDMUの集合である．",
    "crumbs": [
      "データ包絡分析",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>CCRモデル</span>"
    ]
  },
  {
    "objectID": "dea/ccr.html#ccrモデルの例題",
    "href": "dea/ccr.html#ccrモデルの例題",
    "title": "13  CCRモデル",
    "section": "13.1 CCRモデルの例題",
    "text": "13.1 CCRモデルの例題\n\n13.1.1 1入力1出力のCCRモデル\n\n\n\nDMU\nA\nB\nC\nD\nE\nF\n\n\n\n\nInput\n2\n3\n3\n4\n2\n5\n\n\nOutput\n1\n3\n2\n3\n2\n2\n\n\n\n入力に対する重みを \\(v\\)，出力に対する重みを \\(u\\) とする． \\(\\text{DMU}_A\\) の効率性を評価するCCRモデルは次のようになる．\n\\[\\begin{align*}\n\\text{maximize} \\quad & u & \\\\\n\\text{subject to} \\quad & 2v = 1 & \\\\\n& u - 2v \\leq 0 & (A)\\\\\n& 3u - 3v \\leq 0 & (B)\\\\\n& 2u - 3v \\leq 0 & (C)\\\\\n& 3u - 4v \\leq 0 & (D)\\\\\n& 2u - 2v \\leq 0 & (E)\\\\\n& 2u - 5v \\leq 0 & (F)\\\\\n& u \\geq 0 & \\\\\n& v \\geq 0 &\n\\end{align*}\\]\n\\(2v = 1\\) より，\\(v = 0.5\\) であるから，この等式を用いて，この線形計画問題は簡単に解ける．最適値は \\(\\theta^* = 0.5\\)，重みは \\(u^* = 0.5\\)，\\(v^* = 0.5\\) である．\n\\(\\theta^* = 0.5 &lt; 1\\) から，\\(\\text{DMU}_A\\) は非効率的であることがわかる．また，\\(u^*\\) と \\(v^*\\) を代入し，制約条件 (B) と (E) が等号で成り立っているため，\\(\\text{DMU}_A\\) の参照集合は \\(\\mathcal{R}_A = \\{B, E\\}\\) となる．さらに，\n\\[\n\\theta = \\frac{u^* y_A}{v^* x_A} = 0.5\n\\]\nであるから，\\(A\\) の出力 \\(y_A\\) を 2 倍するか，入力 \\(x_A\\) を 0.5 倍すれば，効率的になることがわかる．\n同様にして，すべてのDMUについてCCRモデルを解くと，次の結果が得られる．\nX = np.array([[2, 3, 3, 4, 2, 5]])\nY = np.array([1, 3, 2, 3, 2, 2])\nsolve_all_ccr(X, Y)\nDMU A\n  theta            : 0.5000\n  Output Weights u : [0.5000]\n  Input Weights  v : [0.5000]\n  Reference Set    : [B, E]\n--------------------------------------------------\nDMU B\n  theta            : 1.0000\n  Output Weights u : [0.3333]\n  Input Weights  v : [0.3333]\n  Reference Set    : [B, E]\n--------------------------------------------------\nDMU C\n  theta            : 0.6667\n  Output Weights u : [0.3333]\n  Input Weights  v : [0.3333]\n  Reference Set    : [B, E]\n--------------------------------------------------\nDMU D\n  theta            : 0.7500\n  Output Weights u : [0.2500]\n  Input Weights  v : [0.2500]\n  Reference Set    : [B, E]\n--------------------------------------------------\nDMU E\n  theta            : 1.0000\n  Output Weights u : [0.5000]\n  Input Weights  v : [0.5000]\n  Reference Set    : [B, E]\n--------------------------------------------------\nDMU F\n  theta            : 0.4000\n  Output Weights u : [0.2000]\n  Input Weights  v : [0.2000]\n  Reference Set    : [B, E]\n--------------------------------------------------\n\\(\\{B, E\\}\\) が他のDMUの参照集合となっていることもわかる．\n1入力1出力の分数計画問題において，目的関数は\n\\[\n\\frac{u y_o}{v x_o} = \\frac{u}{v} \\frac{y_o}{x_o}\n\\]\nとなり，\\(y_o/x_o\\) に比例する．したがって，1入力1出力のCCRモデルの最適化問題を解くことは，すべてのDMUについて \\(y_j/x_j\\) を計算し，\\([0,1]\\) に正規化することと同じである．今回の例題では，DMU BとEの \\(\\theta^*=1\\) で最大であるため，\\(u/v = 1\\) となる．\n\n\nコード\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndata = {\n    \"store\": [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"],\n    \"employee\": [2, 3, 3, 4, 2, 5],\n    \"sale\": [1, 3, 2, 3, 2, 2],\n}\ndf = pd.DataFrame(data)\ndf[\"theta\"] = [0.5, 1.0, 0.67, 0.75, 1.0, 0.4]\ndf[\"u\"] = [0.5, 0.33, 0.33, 0.25, 0.5, 0.2]\ndf[\"v\"] = [0.5, 0.33, 0.33, 0.25, 0.5, 0.2]\nplt.figure(figsize=(8, 6))\nplt.scatter(df[\"employee\"], df[\"sale\"])\nfor i in range(len(df)):\n    plt.text(df[\"employee\"][i] + 0.1, df[\"sale\"][i], df[\"store\"][i])\nplt.plot([0, 6], [0, 6], color=\"red\", linestyle=\"--\", label=\"efficient frontier\")\nplt.xlabel(\"Employee\")\nplt.ylabel(\"Sale\")\nplt.xlim(0, 6)\nplt.ylim(0, 6)\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n13.1.2 2入力1出力のCCRモデル\n\n\n\nDMU\nA\nB\nC\nD\nE\nF\n\n\n\n\nInput 1\n4\n7\n8\n4\n2\n10\n\n\nInput 2\n3\n3\n1\n2\n4\n1\n\n\nOutput\n1\n1\n1\n1\n1\n1\n\n\n\n入力1に対する重みを \\(v_1\\)，入力2に対する重みを \\(v_2\\)，出力に対する重みを \\(u\\) とする． \\(\\text{DMU}_A\\) の効率性を評価するCCRモデルは次のようになる．\n\\[\\begin{align*}\n\\text{maximize} \\quad & u & \\\\\n\\text{subject to} \\quad & 4v_1 + 3v_2 = 1 & \\\\\n& u - 4v_1 - 3v_2 \\leq 0 & (A)\\\\\n& u - 7v_1 - 3v_2 \\leq 0 & (B)\\\\\n& u - 8v_1 - 1v_2 \\leq 0 & (C)\\\\\n& u - 4v_1 - 2v_2 \\leq 0 & (D)\\\\\n& u - 2v_1 - 4v_2 \\leq 0 & (E)\\\\\n& u - 10v_1 - 1v_2 \\leq 0 & (F)\\\\\n& u \\geq 0 & \\\\\n& v_1 \\geq 0 & \\\\\n& v_2 \\geq 0 &\n\\end{align*}\\]\nソルバーでこの線形計画問題を解くと，最適値は \\(\\theta^* = 0.8571\\)，重みは \\(u^* = 0.8571\\)，\\(v_1^* = 0.1429\\)，\\(v_2^* = 0.1429\\) である．また，\\(u^*, v_1^*, v_2^*\\) を制約条件に代入し，\\(A\\) の参照集合は \\(\\mathcal{R}_A = \\{D, E\\}\\) となる．\n\n\n\n\n13.1.3 2入力2出力のCCRモデル\n\n\n\nDMU\nA\nB\nC\nD\nE\nF\nG\nH\nI\nJ\nK\nL\n\n\n\n\nInput 1\n20\n19\n25\n27\n22\n55\n33\n31\n30\n50\n53\n38\n\n\nInput 2\n151\n131\n160\n168\n158\n255\n235\n206\n244\n268\n306\n284\n\n\nOutput 1\n100\n150\n160\n180\n94\n230\n220\n152\n190\n250\n260\n250\n\n\nOutput 2\n90\n50\n55\n72\n66\n90\n88\n80\n100\n100\n147\n120\n\n\n\n\\(\\text{DMU}_A\\) の効率性を評価するCCRモデルは次のようになる．\n\\[\\begin{align*}\n\\text{maximize} \\quad & 100 u_1 + 90 u_2 & \\\\\n\\text{subject to} \\quad & 20 v_1 + 151 v_2 = 1 & \\\\\n& 100 u_1 + 90 u_2 - 20 v_1 - 151 v_2 \\leq 0 & \\\\\n& 150 u_1 + 50 u_2 - 19 v_1 - 131 v_2 \\leq 0 & \\\\\n& 160 u_1 + 55 u_2 - 25 v_1 - 160 v_2 \\leq 0 & \\\\\n& 180 u_1 + 72 u_2 - 27 v_1 - 168 v_2 \\leq 0 & \\\\\n& 94 u_1 + 66 u_2 - 22 v_1 - 158 v_2 \\leq 0 & \\\\\n& 230 u_1 + 90 u_2 - 55 v_1 - 255 v_2 \\leq 0 & \\\\\n& 220 u_1 + 88 u_2 - 33 v_1 - 235 v_2 \\leq 0 & \\\\\n& 152 u_1 + 80 u_2 - 31 v_1 - 206 v_2 \\leq 0 & \\\\\n& 190 u_1 + 100 u_2 - 30 v_1 - 244 v_2 \\leq 0 & \\\\\n& 250 u_1 + 100 u_2 - 50 v_1 - 268 v_2 \\leq 0 & \\\\\n& 260 u_1 + 147 u_2 - 53 v_1 - 306 v_2 \\leq 0 & \\\\\n& 250 u_1 + 120 u_2 - 38 v_1 - 284 v_2 \\leq 0 & \\\\\n& u_r \\geq 0, \\quad \\forall r = 1, 2 & \\\\\n& v_i \\geq 0, \\quad \\forall i = 1, 2 &\n\\end{align*}\\]",
    "crumbs": [
      "データ包絡分析",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>CCRモデル</span>"
    ]
  },
  {
    "objectID": "dp/intro.html",
    "href": "dp/intro.html",
    "title": "14  動的計画法",
    "section": "",
    "text": "14.1 最短路問題\n動的計画法（dynamic programming, DP）は Richard E. Bellman によって提案された，多段階決定過程（multi-stage decision process）に対する最適化手法である．\n多段階決定過程は，複数の段階にわたって行われる一連の意思決定を行う問題である．各段階 \\(t\\) において，意思決定者は現在の状態を観測し，意思決定を行う．その意思決定は，将来の状態に影響を与える．目的として，状態に関するある目的関数を最小化（または最大化）することである．動的計画法は，多段階決定過程における最適方策（optimal policy）を求めるための一般的な手法である．\n最適化，制御，オペレーションズ・リサーチなどの分野において，多数の応用例が知られている．\nさらに，現在では，強化学習の基礎理論としても重要な役割を果たしている．\nここでは，動的計画法の基本的な考え方を理解するために，最短路問題（shortest path problem）とナップサック問題（knapsack problem）を取り上げる．\n多段階の有向グラフ \\(G = (V, E)\\) における最短路問題を考える。 各辺 \\((v, u) \\in E\\) に非負の重み \\(w(v, u)\\) が与えられているとする。始点 \\(s \\in V\\) から終点 \\(t \\in V\\) への最短路を求める問題である。\\(s\\) と \\(t\\) 以外の頂点を段階 \\(D = \\{ 1, 2, \\ldots, n \\}\\) に分けることができるとする。結果として，\\(n\\) 回の意思決定を行い，最適解は \\((s, v_1, v_2, \\ldots, v_n, t)\\) の形になる。\n\\(P^* = (s, v_1, v_2, \\ldots, v_n, t)\\) は最短路であれば，任意の \\(1 \\leq k \\leq n\\) に対して，パス \\((v_k, v_{k+1}, \\ldots, v_n, t)\\) も \\(v_k\\) から \\(t\\) への最短路である。これは，もし \\((v_k, v_{k+1}, \\ldots, v_n, t)\\) が最短路でないとすると，より短いパスが存在し，\\(P^*\\) も最短路でなくなるためである。この性質は最適性の原理（Principle of Optimality）と呼ばれる。\n点 \\(v\\) から点 \\(t\\) までの最短路の長さ（またはコスト）を \\(d(v)\\) と定義する。最適性の原理により，点 \\(v \\in V \\setminus \\{ t \\}\\) に対して，\n\\[\nd(v) = \\min_{u \\in \\mathcal{S}(v)} \\{ w(v, u) + d(u) \\}\n\\]\nが成り立つ。ここで，\\(\\mathcal{S}(v) = \\{ u \\mid (v, u) \\in E \\}\\) とする．\n動的計画法による最短路問題の解法を以下に示す。\ndef dp_shortest_path(G):\n    # Initialize distances\n    d = {v: float(\"inf\") for v in G.nodes()}\n    d[\"t\"] = 0  # Distance to target is 0\n\n    # Get layers in topological order\n    layers = list(nx.topological_generations(G))\n\n    # Process layers in reverse order\n    for layer in reversed(layers[:-1]):  # Exclude the last layer (target)\n        for v in layer:\n            d[v] = min(\n                (G[v][u][\"weight\"] + d[u] for u in G.successors(v)),\n            )\n    return d[\"s\"]\n\n\nif __name__ == \"__main__\":\n\n    shortest_path_length_dp = dp_shortest_path(G)\n    print(shortest_path_length_dp)\n\n11\nまず，\\(d(t) = 0\\) とし，第 4 段の点 \\(j\\)，\\(k\\)，\\(l\\)，\\(m\\) について，\\(d(j)\\)，\\(d(k)\\)，\\(d(l)\\)，\\(d(m)\\) を計算する。\n\\[\\begin{align*}\nd(j) &= \\min \\{ w(j, t) + d(t) \\} = \\min \\{ 5 + 0 \\} = 5 \\\\\nd(k) &= \\min \\{ w(k, t) + d(t) \\} = \\min \\{ 1 + 0 \\} = 1 \\\\\nd(l) &= \\min \\{ w(l, t) + d(t) \\} = \\min \\{ 4 + 0 \\} = 4 \\\\\nd(m) &= \\min \\{ w(m, t) + d(t) \\} = \\min \\{ 2 + 0 \\} = 2 \\\\\n\\end{align*}\\]\n次に，第 3 段の点 \\(g\\)，\\(h\\)，\\(i\\) について，\\(d(g)\\)，\\(d(h)\\)，\\(d(i)\\) を計算する。\n\\[\\begin{align*}\nd(g) &= \\min \\{ w(g, j) + d(j), w(g, k) + d(k) \\} = \\min \\{ 4 + 5, 2 + 1 \\} = \\min \\{ 9, 3 \\} = 3 \\\\\nd(h) &= \\min \\{ w(h, k) + d(k), w(h, l) + d(l) \\} = \\min \\{ 3 + 1, 2 + 4 \\} = \\min \\{ 4, 6 \\} = 4 \\\\\nd(i) &= \\min \\{ w(i, l) + d(l), w(i, m) + d(m) \\} = \\min \\{ 4 + 4, 3 + 2 \\} = \\min \\{ 8, 5 \\} = 5 \\\\\n\\end{align*}\\]\n第 2 段の点 \\(d\\)，\\(e\\)，\\(f\\) について，\\(d(d)\\)，\\(d(e)\\)，\\(d(f)\\) を計算する。\n\\[\\begin{align*}\nd(d) &= \\min \\{ w(d, g) + d(g), w(d, h) + d(h) \\} = \\min \\{ 7 + 3, 2 + 4 \\} = \\min \\{ 10, 6 \\} = 6 \\\\\nd(e) &= \\min \\{ w(e, h) + d(h), w(e, i) + d(i) \\} = \\min \\{ 1 + 4, 3 + 5 \\} = \\min \\{ 5, 8 \\} = 5 \\\\\nd(f) &= \\min \\{ w(f, h) + d(h), w(f, i) + d(i) \\} = \\min \\{ 2 + 4, 2 + 5 \\} = \\min \\{ 6, 7 \\} = 6 \\\\\n\\end{align*}\\]\n第 1 段の点 \\(a\\)，\\(b\\)，\\(c\\) について，\\(d(a)\\)，\\(d(b)\\)，\\(d(c)\\) を計算する。\n\\[\\begin{align*}\nd(a) &= \\min \\{ w(a, d) + d(d), w(a, e) + d(e) \\} = \\min \\{ 2 + 6, 5 + 5 \\} = \\min \\{ 8, 10 \\} = 8 \\\\\nd(b) &= \\min \\{ w(b, d) + d(d), w(b, e) + d(e) \\} = \\min \\{ 1 + 6, 3 + 5 \\} = \\min \\{ 7, 8 \\} = 7 \\\\\nd(c) &= \\min \\{ w(c, e) + d(e), w(c, f) + d(f) \\} = \\min \\{ 4 + 5, 1 + 6 \\} = \\min \\{ 9, 7 \\} = 7 \\\\\n\\end{align*}\\]\n最後に，始点 \\(s\\) について，\\(d(s)\\) を計算する。\n\\[\\begin{align*}\nd(s) &= \\min \\{ w(s, a) + d(a), w(s, b) + d(b), w(s, c) + d(c) \\} \\\\\n     &= \\min \\{ 5 + 8, 6 + 7, 4 + 7 \\} \\\\\n     &= \\min \\{ 13, 13, 11 \\} \\\\\n     &= 11\n\\end{align*}\\]\n最短路 \\(P^*\\) は，\\(d(s)\\) の計算過程を逆にたどることで求めることができる。点 \\(v\\) に対して，次の点 \\(u\\) を\n\\[\nu = \\arg\\min_{u' \\in \\mathcal{P}(v)} \\{ w(v, u') + d(u') \\}\n\\]\nと定義する。始点 \\(s\\) から始めて，次の点を順にたどることで，最短路 \\(P^*\\) を構築できる。この問題において，最短路は \\(P^* = (s, c, f, h, k, t)\\) であり，その長さは 11 である。",
    "crumbs": [
      "動的計画法",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>動的計画法</span>"
    ]
  },
  {
    "objectID": "dp/intro.html#最短路問題",
    "href": "dp/intro.html#最短路問題",
    "title": "14  動的計画法",
    "section": "",
    "text": "例 14.1 下のグラフにおいて，\\(d(a)\\)，\\(d(b)\\)，\\(d(c)\\) が与えられたとき，\\(d(s)\\) を計算せよ。\n\n\\(d(a) = 8\\)\n\\(d(b) = 7\\)\n\\(d(c) = 7\\)\n\n\n\nコード\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\nG = nx.DiGraph()\nedges = [\n    (\"s\", \"a\", 5),\n    (\"s\", \"b\", 6),\n    (\"s\", \"c\", 4),\n    (\"a\", \"d\", 2),\n    (\"a\", \"e\", 5),\n    (\"b\", \"d\", 1),\n    (\"b\", \"e\", 3),\n    (\"c\", \"e\", 4),\n    (\"c\", \"f\", 1),\n    (\"d\", \"g\", 7),\n    (\"d\", \"h\", 2),\n    (\"e\", \"h\", 1),\n    (\"e\", \"i\", 3),\n    (\"f\", \"h\", 2),\n    (\"f\", \"i\", 2),\n    (\"g\", \"j\", 4),\n    (\"g\", \"k\", 2),\n    (\"h\", \"k\", 3),\n    (\"h\", \"l\", 2),\n    (\"i\", \"l\", 4),\n    (\"i\", \"m\", 3),\n    (\"j\", \"t\", 5),\n    (\"k\", \"t\", 1),\n    (\"l\", \"t\", 4),\n    (\"m\", \"t\", 2),\n]\nG.add_weighted_edges_from(edges)\n\nfor layer, nodes in enumerate(nx.topological_generations(G)):\n    for node in nodes:\n        G.nodes[node][\"layer\"] = layer\n\npos = {\n    \"s\": (0, 0),\n    \"a\": (1, 1),\n    \"b\": (1, 0),\n    \"c\": (1, -1),\n    \"d\": (2, 1),\n    \"e\": (2, 0),\n    \"f\": (2, -1),\n    \"g\": (3, 1),\n    \"h\": (3, 0),\n    \"i\": (3, -1),\n    \"j\": (4, 1.5),\n    \"k\": (4, 0.5),\n    \"l\": (4, -0.5),\n    \"m\": (4, -1.5),\n    \"t\": (5, 0),\n}\n\nnx.draw(G, pos, with_labels=True, node_size=700, node_color=\"lightblue\", font_size=10)\nedge_labels = nx.get_edge_attributes(G, \"weight\")\nnx.draw_networkx_edge_labels(\n    G, pos, edge_labels=edge_labels, label_pos=0.3, font_size=8, rotate=False\n)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nコード\n# find shortest path from s to t\nsource = \"s\"\ntarget = \"t\"\nshortest_path = nx.shortest_path(G, source=source, target=target, weight=\"weight\")\nshortest_path_length = nx.shortest_path_length(\n    G, source=source, target=target, weight=\"weight\"\n)\nshortest_path, shortest_path_length\n\n\n(['s', 'c', 'f', 'h', 'k', 't'], 11)\n\n\n\\[\\begin{align*}\nd(s) &= \\min \\{ w(s, a) + d(a), w(s, b) + d(b), w(s, c) + d(c) \\} \\\\\n     &= \\min \\{ 5 + 8, 6 + 7, 4 + 7 \\} \\\\\n     &= \\min \\{ 13, 13, 11 \\} \\\\\n     &= 11\n\\end{align*}\\]\n\n\n\nAlgorithm 14.1  \n\nInput: 有向グラフ \\(G = (V, E)\\)，重み関数 \\(w: E \\to \\mathbb{R}_{\\geq 0}\\)，始点 \\(s \\in V\\)，終点 \\(t \\in V\\)\n\nOutput: \\(s\\) から \\(t\\) への最短路の長さ \\(d(s)\\)\n\n\n\\(d(t) \\leftarrow 0\\)\n\\(d(v) \\leftarrow \\infty\\) for all \\(v \\in V \\setminus \\{ t \\}\\)\n\\(k \\leftarrow n-1\\) (段階数)\nwhile \\(k \\geq 0\\) do\n\nfor each \\(v \\in D_k\\) do\n\n\\(d(v) \\leftarrow \\min_{u \\in \\mathcal{P}(v)} \\{ w(v, u) + d(u) \\}\\)\n\n\\(k \\leftarrow k - 1\\)\n\nreturn \\(d(s)\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n例 14.2 動的計画法による最長路問題のアルゴリズムを考え，例題の最長路を求めよ。点 \\(v\\) から点 \\(t\\) までの最長路の長さ \\(d(v)\\) は， \\[\nd(v) = \\max_{u \\in \\mathcal{P}(v)} \\{ w(v, u) + d(u) \\}\n\\] と与えられる。",
    "crumbs": [
      "動的計画法",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>動的計画法</span>"
    ]
  },
  {
    "objectID": "dp/intro.html#ナップサック問題",
    "href": "dp/intro.html#ナップサック問題",
    "title": "14  動的計画法",
    "section": "14.2 0/1 ナップサック問題",
    "text": "14.2 0/1 ナップサック問題\n0/1 ナップサック問題は，有限個の品物からなる集合 \\(I = \\{ 1, 2, \\ldots, n \\}\\) と，ナップサックの容量 \\(W\\) が与えられたとき，以下の最適化問題を解くことである。\n\\[\\begin{align*}\n\\text{maximize} \\quad & \\sum_{i \\in I} v_i x_i \\\\\n\\text{subject to} \\quad & \\sum_{i \\in I} w_i x_i \\leq W \\\\\n& x_i \\in \\{ 0, 1 \\} \\quad \\forall i \\in I\n\\end{align*}\\]\nここで，\\(v_i\\) は品物 \\(i\\) の価値，\\(w_i\\) は品物 \\(i\\) の重量，\\(x_i\\) は品物 \\(i\\) をナップサックに入れるかどうかを示す 0/1 変数である。目的は，ナップサックの容量を超えないように品物を選び，その価値の総和を最大化することである。\n\n例 14.3 ここでは，0/1 ナップサック問題の例題を示す．ナップサックの容量 \\(W = 15\\) のとき，最適解を求めよ。\n\n\n\n品物 \\(i\\)\n重量 \\(w_i\\)\n価値 \\(v_i\\)\n\n\n\n\n1\n12\n4\n\n\n2\n2\n2\n\n\n3\n1\n1\n\n\n4\n1\n2\n\n\n\n\\(\\mathbf{x} = (x_1, x_2, x_3, x_4)\\) とすると，最適解は \\(\\mathbf{x^*} = (1, 1, 0, 1)\\) であり，価値の総和は 8 である。\n\n品物 \\(1, 2, \\ldots, n\\) を取るか取らないかを順に決定していく多段階決定過程として 0/1 ナップサック問題を定式化できる。段階 \\(i\\) において，品物 \\(i\\) を取るか取らないかを決定する。\\(v_i(w)\\) を，品物 \\(i, i+1, \\ldots, n\\) から選んで，利用可能な容量が \\(w\\) のときの最大価値と定義する。すなわち，\\(v_i(w)\\) は，以下の最適化問題の最適値である。\n\\[\\begin{align*}\n\\text{maximize} \\quad & \\sum_{j = i}^{n} v_j x_j \\\\\n\\text{subject to} \\quad & \\sum_{j = i}^{n} w_j x_j \\leq w \\\\\n& x_j \\in \\{ 0, 1 \\} \\quad \\forall j = i, i+1, \\ldots, n\n\\end{align*}\\]\n\\(\\mathbf{x^*} = (x_1, x_2, \\ldots, x_n)\\) は最適解であれば，\\((x_i, x_{i+1}, \\ldots, x_n)\\) は，利用可能な容量が \\(W - \\sum_{j=1}^{i-1} w_j x_j\\) のときの品物 \\(i, i+1, \\ldots, n\\) に対する最適解である。これは，もし \\((x_i, x_{i+1}, \\ldots, x_n)\\) が最適解でないとすると，より価値の高い解が存在し，\\(\\mathbf{x^*}\\) も最適解でなくなるためである。\n以上の性質により，\\(v_i(w)\\) は以下の再帰式で与えられる。\n\\[\nv_i(w) =\n\\begin{cases}\nv_{i+1}(w) & \\text{if } w_i &gt; w \\\\\n\\max \\{ v_{i+1}(w), v_{i+1}(w - w_i) + v_i \\} & \\text{if } w_i \\leq w\n\\end{cases}\n\\]\nまた，\\(n+1\\) 段階目では品物が存在しないため，すべての容量 \\(w\\) に対して \\(v_{n+1}(w) = 0\\) となる。\n\n\n\n\n\n\nヒント\n\n\n\n\\(v_{i+1}(w)\\) は，すべての \\(w = 0, 1, \\ldots, W\\) に対して，品物 \\(i+1, i+2, \\ldots, n\\) から選んで利用可能な容量が \\(w\\) のときの最大価値を表す。これを用いて，\\(v_i(w), \\forall w = 0, 1, \\ldots, W\\) を計算する。最適性の原理により，\\(v_i(w)\\) は部分問題の最適値である。\n品物 \\(i\\) の重量 \\(w_i\\) が利用可能な容量 \\(w\\) を超える場合，品物 \\(i\\) は取れないため，\\(v_i(w) = v_{i+1}(w)\\) となる。\n\\(w_i \\leq w\\) の場合，品物 \\(i\\) を取らない場合と取る場合のうち，価値の高い方を選ぶ．ただし，品物 \\(i\\) を取る場合は，利用可能な容量が \\(w - w_i\\) になり，価値が \\(v_i\\) 増加する．\n\n\n\nAlgorithm 14.2  \n\nInput: 品物の集合 \\(I = \\{ 1, 2, \\ldots, n \\}\\)，品物 \\(i\\) の重量 \\(w_i\\)，品物 \\(i\\) の価値 \\(v_i\\)，ナップサックの容量 \\(W\\)\n\nOutput: 最適値 \\(v_1(W)\\)\n\n\nfor all \\(w = 0, 1, \\ldots, W\\) do\n\n\\(v_{n+1}(w) \\leftarrow 0\\)\n\nfor \\(i = n, n-1, \\ldots, 1\\) do\n\nfor all \\(w = 0, 1, \\ldots, W\\) do\n\nif \\(w_i &gt; w\\) then\n\n\\(v_i(w) \\leftarrow v_{i+1}(w)\\)\n\nelse\n\n\\(v_i(w) \\leftarrow \\max \\{ v_{i+1}(w), v_{i+1}(w - w_i) + v_i \\}\\)\n\n\n\nreturn \\(v_1(W)\\)\n\n\n\ndef dp_knapsack(weights, values, W):\n    n = len(weights)\n    # Initialize value table\n    v = [[0 for _ in range(W + 1)] for _ in range(n + 2)]\n\n    # Fill the table in reverse order\n    for i in range(n, 0, -1):\n        for w in range(W + 1):\n            if weights[i - 1] &gt; w:\n                v[i][w] = v[i + 1][w]\n            else:\n                v[i][w] = max(v[i + 1][w], v[i + 1][w - weights[i - 1]] + values[i - 1])\n    return v[1][W]\n\n\nif __name__ == \"__main__\":\n    weights = [12, 2, 1, 1]\n    values = [4, 2, 1, 2]\n    W = 15\n    optimal_value = dp_knapsack(weights, values, W)\n    print(optimal_value)  # Output: 8\n\n8\n\n\n容量 \\(W = 2\\) のときの計算過程を以下に示す。\n\\(v_5(w) = 0, \\forall w\\) であり，次に \\(i = 4\\) について，\n\\[\\begin{align*}\nv_4(0) &= 0 \\\\\nv_4(1) &= \\max \\{ v_5(1), v_5(0) + 2 \\} = \\max \\{ 0, 0 + 2 \\} = 2 \\\\\nv_4(2) &= \\max \\{ v_5(2), v_5(1) + 2 \\} = \\max \\{ 0, 0 + 2 \\} = 2 \\\\\n\\end{align*}\\]\nが得られる。次に \\(i = 3\\) について，次の結果が得られる。\n\\[\\begin{align*}\nv_3(0) &= 0 \\\\\nv_3(1) &= \\max \\{ v_4(1), v_4(0) + 1 \\} = \\max \\{ 2, 0 + 1 \\} = 2 \\\\\nv_3(2) &= \\max \\{ v_4(2), v_4(1) + 1 \\} = \\max \\{ 2, 2 + 1 \\} = 3 \\\\\n\\end{align*}\\]\n次に \\(i = 2\\) について，次の結果が得られる。 \\[\\begin{align*}\nv_2(0) &= 0 \\\\\nv_2(1) &= v_3(1) = 2 \\\\\nv_2(2) &= \\max \\{ v_3(2), v_3(0) + 2 \\} = \\max \\{ 3, 0 + 2 \\} = 3 \\\\\n\\end{align*}\\]\n最後に \\(i = 1\\) について，次の結果が得られる。 \\[\\begin{align*}\nv_1(0) &= 0 \\\\\nv_1(1) &= v_2(1) = 2 \\\\\nv_1(2) &= v_2(2) = 3 \\\\\n\\end{align*}\\]\nしたがって，最適値は \\(v_1(2) = 3\\) である。最適解は，計算過程を逆にたどることで求めることができ，\\(\\mathbf{x^*} = (0, 0, 1, 1)\\) となる。\n\n\\(v_1(2) = v_2(2)\\) より，品物 1 は取らない。\\(x_1^* = 0\\)。\n\\(v_2(2) = v_3(2)\\) より，品物 2 は取らない。\\(x_2^* = 0\\)。\n\\(v_3(2) = v_4(1) + 1\\) より，品物 3 は取る。\\(x_3^* = 1\\)。利用可能な容量は \\(2 - 1 = 1\\) となる。\n\\(v_4(1) = v_5(0) + 2\\) より，品物 4 は取る。\\(x_4^* = 1\\)。\n\n\n例 14.4 容量 \\(W = 3\\) のときの最適値と最適解を求めよ。",
    "crumbs": [
      "動的計画法",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>動的計画法</span>"
    ]
  },
  {
    "objectID": "dp/intro.html#ベルマン方程式確定的場合",
    "href": "dp/intro.html#ベルマン方程式確定的場合",
    "title": "14  動的計画法",
    "section": "14.3 ベルマン方程式（確定的場合）*",
    "text": "14.3 ベルマン方程式（確定的場合）*\n動的計画法における最適性の原理は，ベルマン方程式（Bellman equation）として知られる再帰方程式により表現される。状態 \\(s\\) におけるの価値関数 \\(v(s)\\) は，以下のように定義される。\n\\[\nv(s) = \\max_{a \\in A(s)} \\{ r(s, a) + \\gamma v(s') \\}\n\\]\nここで，\\(A(s)\\) は状態 \\(s\\) における可能な行動の集合，\\(R(s, a)\\) は状態 \\(s\\) で行動 \\(a\\) を取ったときの報酬，\\(\\gamma\\) は割引率，\\(s'\\) は行動 \\(a\\) を取った後の次の状態である。\n\n\n\n\n\n\n\n\n記号\n最短路問題\n0/1 ナップサック問題\n\n\n\n\n\\(s\\)\n現在の頂点\n現在の品物と利用可能な容量\n\n\n\\(a\\)\n次に移動する頂点\n品物を取るか取らないか\n\n\n\\(A(s)\\)\n現在の頂点から到達可能な頂点の集合\n現在の品物を取るか取らないかの選択肢\n\n\n\\(R(s, a)\\)\n負の辺の重み\n品物の価値\n\n\n\\(s'\\)\n次の頂点\n次の品物と新しい利用可能な容量",
    "crumbs": [
      "動的計画法",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>動的計画法</span>"
    ]
  },
  {
    "objectID": "queuing/intro.html",
    "href": "queuing/intro.html",
    "title": "15  基礎概念",
    "section": "",
    "text": "15.1 待ち行列とは\n客（customer）がシステムに到着（arrival）し，待ち行列（queue）に並び，サービスを受け，最後にシステムを退出（departure）する．図 15.1 は，典型的な待ち行列システムを示している．\n待ち行列システムは待ち行列とサーバから構成される．これ以降は，待ち行列システムを単にシステムと呼ぶことにする．",
    "crumbs": [
      "待ち行列理論",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>基礎概念</span>"
    ]
  },
  {
    "objectID": "queuing/intro.html#待ち行列とは",
    "href": "queuing/intro.html#待ち行列とは",
    "title": "15  基礎概念",
    "section": "",
    "text": "図 15.1: A typical queueing system",
    "crumbs": [
      "待ち行列理論",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>基礎概念</span>"
    ]
  },
  {
    "objectID": "queuing/intro.html#待ち行列モデル",
    "href": "queuing/intro.html#待ち行列モデル",
    "title": "15  基礎概念",
    "section": "15.2 待ち行列モデル",
    "text": "15.2 待ち行列モデル\n一般に，待ち行列モデルは，次の5つの要素で特徴付けられる．\n\n客の到着過程\nサービス時間分布\nサーバ数\nシステム容量\nサービス規律",
    "crumbs": [
      "待ち行列理論",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>基礎概念</span>"
    ]
  },
  {
    "objectID": "queuing/intro.html#ケンドールの記号",
    "href": "queuing/intro.html#ケンドールの記号",
    "title": "15  基礎概念",
    "section": "15.3 ケンドールの記号",
    "text": "15.3 ケンドールの記号\n待ち行列モデルは，ケンドールの記号（Kendall’s notation）により表現する．通常以下の形式で表される．\n\\[\nA/B/X\n\\]\nここで，\\(A\\) は到着間隔分布の種類，\\(B\\) はサービス時間分布の種類，\\(X\\) はサーバ数を表す．また，システム容量は無限大であり，サービス規律は FCFS であると仮定する．\n\\(A\\) と \\(B\\) には以下の記号が用いられる．\n\n\n\n記号\n意味\n\n\n\n\n\\(M\\)\n指数分布\n\n\n\\(D\\)\n決定論的\n\n\n\\(G\\)\n一般分布\n\n\n\\(E_k\\)\n\\(k\\) 次アーラン分布\n\n\n\\(H_k\\)\n\\(k\\) 次超指数分布\n\n\n\n例えば，客の到着間隔が指数分布に従い，サービス時間が一定であり，サーバ数が1台である待ち行列モデルは，\\(M/D/1\\) 待ち行列と表される．この \\(M/D/1\\) 待ち行列モデルのシステム容量は無限大であり，サービス規律は FCFS であると仮定されている．\n\\(G/G/1\\) と \\(G/G/c\\) 待ち行列は，特定の分布を仮定しない待ち行列モデルであるため，得られた結果は多くの待ち行列モデルに適用できる．さらに，\\(G/G/c\\) 待ち行列から得られた結果は，\\(c = 1\\) とすると，\\(G/G/1\\) 待ち行列に適用できる．\n\n\n\n\n\n\nノートなぜ指数分布は \\(M\\) と書くのか\n\n\n\n\nアーラン分布 \\(E_k\\) と間違えないようにするため．\n指数分布のマルコフ性（Markovian property）と無記憶性（memoryless property）に由来する．",
    "crumbs": [
      "待ち行列理論",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>基礎概念</span>"
    ]
  },
  {
    "objectID": "queuing/intro.html#利用率",
    "href": "queuing/intro.html#利用率",
    "title": "15  基礎概念",
    "section": "15.4 利用率",
    "text": "15.4 利用率\n\\(G/G/c\\) 待ち行列モデルを考える．記号のまとめを以下に示す．\n\n\n\n記号\n意味\n\n\n\n\n\\(\\lambda\\)\n平均到着率，単位時間あたりの到着客数の平均\n\n\n\\(L\\)\n系内客数\n\n\n\\(W\\)\n滞在時間\n\n\n\\(L_q\\)\n待ち行列長\n\n\n\\(W_q\\)\n待ち時間\n\n\n\\(S\\)\nサービス時間\n\n\n\\(\\mu\\)\n平均サービス率，単位時間あたりに処理できる客数の平均\n\n\n\\(c\\)\nサーバ数\n\n\n\\(\\rho\\)\n利用率\n\n\n\n時刻 \\(t\\) までに累積到着客数を \\(A(t)\\) とする．時間区間 \\([0,t]\\) における単位時間あたりの到着客数の平均は \\[\n\\bar{A}(t) = \\frac{A(t)}{t}\n\\] で与えられる．以下の極限 \\[\n\\lambda = \\lim_{t \\to \\infty} \\bar{A}(t)\n\\] が存在するとき，\\(\\lambda\\) を平均到着率（average arrival rate）と呼ぶ．平均到着率 \\(\\lambda\\) は，長期的に見たときの単位時間あたりの平均到着客数を表す．\n\\(S\\) をサービス時間を表す確率変数とする．平均サービス時間 は \\(\\mathbb{E}[S]\\) で表される． 単位時間あたりに一つのサーバが処理できる平均客数は \\[\n\\mu = \\frac{1}{\\mathbb{E}[S]}\n\\] で計算する．\\(\\mu\\) を平均サービス率（average service rate）と呼ぶ．\n\n例 15.1 あるゼミでは，学生6人と教員1人が所属している．教員は，1人の学生に対して平均して10分間指導を行う．このとき，平均サービス率と平均サービス時間を求めよ．\n平均サービス時間 \\(\\mathbb{E}[S]\\) は10分である．平均サービス率 \\(\\mu\\) は次のように計算される．\n\\[\n\\mu = \\frac{1}{\\mathbb{E}[S]} = \\frac{1}{10 \\text{ 分}} = \\frac{1}{10/60 \\text{ 時間}} = 6 \\text{ 人/時間}\n\\] すなわち，教員は1時間あたり平均6人の学生に指導を行うことができる．\n\nシステムの利用率 \\(\\rho\\) は，次の式で定義される．\n\\[\n\\rho = \\frac{\\lambda}{c \\mu}\n\\]\nここで，\\(c\\) はサーバ数を表す．利用率 \\(\\rho\\) は，到着率 \\(\\lambda\\) がシステムの処理能力 \\(c \\mu\\) に対してどの程度であるかを示す指標であり，システムの忙しさを表す．\\(G/G/1\\) 待ち行列の場合，\\(c = 1\\) であり，利用率は \\(\\rho = \\lambda / \\mu\\) となる．\n\\(\\rho &gt; 1\\) の場合，\\(\\lambda &gt; c \\mu\\) となり，待ち行列が無限に増加する．\\(\\rho = 1\\) の場合，\\(\\lambda = c \\mu\\) となり，到着率とシステムのサービス能力が等しい．\\(D/D/1\\) 待ち行列のように，客の到着間隔とサービス時間がともに一定である場合を除き，待ち行列は無限に増加する．したがって，システムが安定して運用されるためには，\\(\\rho &lt; 1\\) である必要がある．\n\\(\\lambda\\) と \\(\\mu\\) が与えられたとき，\\(\\rho &lt; 1\\) という条件を用いて，システムが必要なサーバ数 \\(c\\) の最小値を求めることができる．すなわち，\n\\[\n\\rho = \\frac{\\lambda}{c \\mu} &lt; 1\n\\]\nを満たす最小の整数 \\(c\\) を求めればよい．\n\n例 15.2 あるコールセンターでは，オペレーター10人が勤務している．1件の電話対応に平均して10分かかる．1時間あたり30件の電話がかかってくるとする．\n\n社員一人1時間あたりに対応できる電話の平均件数を求めよ．\nこのコールセンターの利用率を求めよ．\n待ち行列が無限に増加しないために必要な最小のオペレーター数を求めよ．\n\n平均サービス時間 \\(\\mathbb{E}[S] = 10 \\text{ 分} = 1/6 \\text{ 時間}\\) である．平均サービス率 \\(\\mu\\) は \\[\n\\mu = \\frac{1}{\\mathbb{E}[S]} = \\frac{1}{1/6} = 6 \\text{ 件/時間}\n\\] となる．すなわち，社員一人は1時間あたり平均6件の電話に対応できることになる．\n平均到着率 \\(\\lambda\\) は30件/時間，平均サービス率 \\(\\mu\\) は6件/時間，サーバ数 \\(c\\) は10である．利用率 \\(\\rho\\) は次のように計算される．\n\\[\n\\rho = \\frac{30}{10 \\times 6} = \\frac{30}{60} = 0.5\n\\]\nよって，このコールセンターの利用率は0.5である．\n安定した運用のためには，\\(\\rho &lt; 1\\) を満たす必要がある．すなわち，\n\\[\nc &gt; \\frac{\\lambda}{\\mu} = 5\n\\]\nしたがって，最小でオーペレーター6人が必要である．\n\n\n\n\n\n\n\n警告利用率\n\n\n\n\\[\n\\rho = \\frac{\\lambda}{c \\mu}\n\\]",
    "crumbs": [
      "待ち行列理論",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>基礎概念</span>"
    ]
  },
  {
    "objectID": "queuing/intro.html#定常状態",
    "href": "queuing/intro.html#定常状態",
    "title": "15  基礎概念",
    "section": "15.5 定常状態",
    "text": "15.5 定常状態\nシステムの使用を開始してから十分時間が経過していなく，システムの状態（システムにいる客数など）が初期状態の影響を受けている場合，システムは過渡状態（transient state）にあるという． 一方で，システムの使用を開始してから，十分時間が経過した後，システムの状態は初期状態の影響を受けなくなる．このとき，システムは定常状態（steady state）にあるという．\n過渡状態よりも定常状態の方が，解析が容易であるため，ここで紹介する待ち行列理論では定常状態におけるシステムの性能評価が主に扱われる．以下では，定常状態における記号を紹介する．\nシステム内にいる客数のことを系内客数と呼ぶ． \\(N(t)\\) を時刻 \\(t\\) における系内客数とする．\\(\\mathbb{P}(N(t) = n)\\) を時刻 \\(t\\) における系内客数が \\(n\\) である確率とする．\\(L\\) を定常状態における系内客数とすると，\\(\\rho &lt; 1\\) のとき，\\(n = 0, 1, 2, \\ldots\\) に対して，\n\\[\n\\pi_n = \\mathbb{P}(L = n) = \\lim_{t \\to \\infty} \\mathbb{P}(N(t) = n)\n\\]\nが存在し，\\(\\pi_n\\) は系内客数 \\(L\\) が \\(n\\) である確率を表す．もう一つの解釈として，\\(\\pi_n\\) は系内客数が \\(n\\) である時間の割合を表すとも言える．\\(\\pi_n\\) は時刻 \\(t\\) に依存しない．\n滞在時間は客がシステムに到着してサービスを受け，システムを退出するまでにかかる時間である． \\(W^{(k)}\\) を客 \\(k\\) の滞在時間とする．\\(W\\) を定常状態における滞在時間とすると， \\(\\rho &lt; 1\\) のとき，\n\\[\nF_W(t) = \\lim_{k \\to \\infty} \\mathbb{P}(W^{(k)} \\leq t)\n\\]\nが存在し，\\(F_W(t)\\) は滞在時間 \\(W\\) が \\(t\\) 以下である確率を表す．",
    "crumbs": [
      "待ち行列理論",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>基礎概念</span>"
    ]
  },
  {
    "objectID": "queuing/intro.html#リトルの法則",
    "href": "queuing/intro.html#リトルの法則",
    "title": "15  基礎概念",
    "section": "15.6 リトルの法則",
    "text": "15.6 リトルの法則\n以上では，定常状態における系内客数と滞在時間の分布を紹介した．待ち行列システムの性能を評価するた際に，もっとも興味がある指標には，平均系内客数，平均滞在時間などがある．\n以下の極限が存在するならば，平均系内客数 \\(\\mathbb{E}[L]\\) と平均滞在時間 \\(\\mathbb{E}[W]\\) はそれぞれ次の式で定義される． \\[\n\\mathbb{E}[L] = \\lim_{T \\to \\infty} \\frac{1}{T} \\int_0^T N(t) dt\n\\]\n\\[\n\\mathbb{E}[W] = \\lim_{n \\to \\infty} \\frac{1}{n} \\sum_{k=1}^n W^{(k)}\n\\]\nすなわち，平均系内客数は，長期的に見たときのシステム内の平均客数を表し，平均滞在時間は，長期的に見たときの客の平均滞在時間を表す．\nリトルの法則（Little’s Law）は，待ち行列理論における基本的な関係式であり，平均系内客数 \\(\\mathbb{E}[L]\\)，平均滞在時間 \\(\\mathbb{E}[W]\\)，平均到着率 \\(\\lambda\\)の関係を示すものである．リトルの法則は\n\\[\n\\mathbb{E}[L] = \\lambda \\mathbb{E}[W]\n\\]\nと表される．すなわち，平均系内客数 \\(\\mathbb{E}[L]\\) は，平均到着率 \\(\\lambda\\) と平均滞在時間 \\(\\mathbb{E}[W]\\) の積に等しい．\nLittle (1961) と Stidham (1974) により，リトルの法則の厳密な証明が与えられている．ここでは，例を用いて，リトルの法則を直感的に理解する．\n\n例 15.3 (大学の在籍学生数) ある大学の経営システム系では，毎年80人の新入生が入学し，卒業までに4年間在籍する．このとき，経営システム系に在籍している学生の平均人数を求めよ．\n平均到着率 \\(\\lambda\\) は80人/年，平均滞在時間 \\(\\mathbb{E}[W]\\) は4年である．リトルの法則により，平均系内客数 \\(\\mathbb{E}[L]\\) は次のように求められる．\n\\[\n\\mathbb{E}[L] = \\lambda \\mathbb{E}[W] = 80 \\times 4 = 320 \\text{ 人}\n\\]\nよって，経営システム系には320人の学生が在籍していることになる．\n\n\n例 15.4 (銀行の平均在店客数) ある銀行では，1時間に平均20人の客が来店し，各客が銀行に滞在する平均時間は12分である．このとき，この銀行には平均何人の客がいるか．\n平均到着率 \\(\\lambda\\) は20人/時間，平均滞在時間 \\(\\mathbb{E}[W] = 12 \\text{ 分} = 12/60 \\text{ 時間}\\) である．リトルの法則から，平均系内客数 \\(\\mathbb{E}[L]\\) は\n\\[\n\\mathbb{E}[L] = \\lambda \\mathbb{E}[W] = 20 \\times \\frac{12}{60} = 4 \\text{ 人}\n\\]\nとなる．すなわち，銀行内には平均して4人の客が滞在する．平均滞在時間 \\(\\mathbb{E}[W]\\) や平均到着率 \\(\\lambda\\) が増加すると，平均系内客数 \\(\\mathbb{E}[L]\\) も増加することがわかる．\n\nこれまでは，システム全体に関するリトルの法則を紹介したが，待ち行列を「システム」として考えた場合にも同様の関係が成り立つ．すなわち，リトルの法則を待ち行列にも適用できる．待ち行列に関するリトルの法則を説明するために，待ち時間と待ち行列長の記号を導入する．\n待ち時間は，客がシステムに到着してからサービスを受けるまでの時間であり，滞在時間は待ち時間とサービス時間の和に等しい．待ち行列長は，システム内にいる客数のうち，サービスを受けていない客数を表す． 待ち行列長を \\(\\mathbb{E}[L_q]\\)，平均待ち時間を \\(\\mathbb{E}[W_q]\\)，平均到着率を \\(\\lambda\\) とすると，\n\\[\n\\mathbb{E}[L_q] = \\lambda \\mathbb{E}[W_q]\n\\]\nが成り立つ．\n\n\n\n\n\n\n警告リトルの法則\n\n\n\n\\[\n\\mathbb{E}[L] = \\lambda \\mathbb{E}[W]\n\\]\n\\[\n\\mathbb{E}[L_q] = \\lambda \\mathbb{E}[W_q]\n\\]",
    "crumbs": [
      "待ち行列理論",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>基礎概念</span>"
    ]
  },
  {
    "objectID": "queuing/intro.html#gg1ggc",
    "href": "queuing/intro.html#gg1ggc",
    "title": "15  基礎概念",
    "section": "15.7 \\(G/G/1\\)，\\(G/G/c\\)",
    "text": "15.7 \\(G/G/1\\)，\\(G/G/c\\)\n\\(G/G/1\\) と \\(G/G/c\\) 待ち行列において，\\(\\mathbb{E}[L]\\)，\\(\\mathbb{E}[W]\\)，\\(\\mathbb{E}[L_q]\\)，\\(\\mathbb{E}[W_q]\\) の関係式を紹介する．\n客がシステムに到着してから退出するまでの平均滞在時間 \\(\\mathbb{E}[W]\\) は，平均待ち時間 \\(\\mathbb{E}[W_q]\\) と平均サービス時間 \\(\\mathbb{E}[S]\\) の和で表される．すなわち，\n\\[\n\\mathbb{E}[W] = \\mathbb{E}[W_q] + \\mathbb{E}[S] = \\mathbb{E}[W_q] + \\frac{1}{\\mu}\n\\]\nである．リトルの法則により，\n\\[\n\\mathbb{E}[L] = \\lambda \\mathbb{E}[W] = \\lambda \\left( \\mathbb{E}[W_q] + \\frac{1}{\\mu} \\right) =\\lambda \\mathbb{E}[W_q] + \\frac{\\lambda}{\\mu} = \\mathbb{E}[L_q] + \\frac{\\lambda}{\\mu}\n\\]\nが成り立つ．\\(\\mathbb{E}[L] = \\mathbb{E}[L_q] + \\lambda /\\mu\\) が成立するから，\\(\\lambda / \\mu\\) はサービスを受けている客数の平均を表していると言える．また，\\(\\lambda / \\mu\\) は稼働中のサーバ数の平均を表しているとも言える．\n\n\n\n\n\n\n警告\\(\\mathbb{E}[L]\\)，\\(\\mathbb{E}[W]\\)，\\(\\mathbb{E}[L_q]\\)，\\(\\mathbb{E}[W_q]\\) の関係\n\n\n\n以上の関係式をまとめると，次のようになる．\n\\[\\begin{align*}\n\\mathbb{E}[L] & = \\lambda \\mathbb{E}[W] \\\\\n\\mathbb{E}[W] & = \\mathbb{E}[W_q] + \\frac{1}{\\mu} \\\\\n\\mathbb{E}[L_q] & = \\lambda \\mathbb{E}[W_q] \\\\\n\\mathbb{E}[L] & = \\mathbb{E}[L_q] + \\frac{\\lambda}{\\mu}\n\\end{align*}\\]\n\n\n\\(\\mathbb{E}[L]\\)，\\(\\mathbb{E}[W]\\)，\\(\\mathbb{E}[L_q]\\)，\\(\\mathbb{E}[W_q]\\) は待ち行列における基本的な評価指標である．\\(\\lambda\\) と \\(\\mu\\) が与えられたとき，4つの指標のうち1つがわかれば，残りの3つを計算できる．",
    "crumbs": [
      "待ち行列理論",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>基礎概念</span>"
    ]
  },
  {
    "objectID": "queuing/intro.html#用語集",
    "href": "queuing/intro.html#用語集",
    "title": "15  基礎概念",
    "section": "15.8 用語集",
    "text": "15.8 用語集\n\n\n\n英語\n日本語\n\n\n\n\nservice facility\nサービス施設\n\n\nserver\nサーバ\n\n\nnumber of servers\nサーバ数\n\n\ninterarrival time\n到着間隔\n\n\nservice time\nサービス時間\n\n\narrival rate\n到着率\n\n\nservice rate\nサービス率\n\n\noffered load",
    "crumbs": [
      "待ち行列理論",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>基礎概念</span>"
    ]
  },
  {
    "objectID": "queuing/intro.html#演習問題",
    "href": "queuing/intro.html#演習問題",
    "title": "15  基礎概念",
    "section": "15.9 演習問題",
    "text": "15.9 演習問題\n\n練習 15.1 (アイスクリーム屋さん) あるアイスクリーム屋さんでは，1名の店員が客の注文を受け付け，アイスクリームを提供している．平均して，1時間に30人の客が来店している．店員は，1時間に60人の客に対応できる．客の平均待ち時間を \\(5\\) 分とする．\n\nこのアイスクリーム屋さんの利用率を求めよ．\n客の平均滞在時間，平均系内客数，平均待ち行列長を求めよ．\n\n\n\n解答 15.1. 平均到着率 \\(\\lambda\\) は30人/時間，平均サービス率 \\(\\mu\\) は60人/時間である．サーバ数 \\(c = 1\\) であるため，利用率は\n\\[\n\\rho = \\frac{30}{1 \\times 60} = 0.5\n\\] となる．\n平均サービス時間 \\(\\mathbb{E}[S] = 1 \\text{ 分}\\)，平均待ち時間 \\(\\mathbb{E}[W_q] = 5 \\text{ 分}\\) であるから，平均滞在時間 \\(\\mathbb{E}[W]\\) は\n\\[\n\\mathbb{E}[W] = \\mathbb{E}[W_q] + \\mathbb{E}[S] = 5 + 1 = 6 \\text{ 分}\n\\] となる．リトルの法則により，平均系内客数 \\(\\mathbb{E}[L]\\) は \\[\n\\mathbb{E}[L] = \\lambda \\mathbb{E}[W] = 30 \\times \\frac{6}{60} = 3 \\text{ 人}\n\\] となる．同様に，平均待ち行列長 \\(\\mathbb{E}[L_q]\\) は \\[\n\\mathbb{E}[L_q] = \\lambda \\mathbb{E}[W_q] = 30 \\times \\frac{5}{60} = 2.5 \\text{ 人}\n\\] となる．\n\n\n\n\n\nLittle, John D C. 1961. 「A proof for the queuing formula: L = λW」. Oper. Res. 9 (3): 383–87.\n\n\nStidham, Shaler, Jr. 1974. 「Technical note—A last word on L = λW」. Oper. Res. 22 (2): 417–21.",
    "crumbs": [
      "待ち行列理論",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>基礎概念</span>"
    ]
  },
  {
    "objectID": "queuing/poisson_process.html",
    "href": "queuing/poisson_process.html",
    "title": "16  ポアソン過程",
    "section": "",
    "text": "16.1 指数分布\n\\(M/M/c\\) と \\(M/M/1\\) 待ち行列は，待ち行列理論において最も基本的なモデルである．これらのモデルでは，到着間隔とサービス時間が指数分布に従う．\n連続型確率変数 \\(X\\) が指数分布（exponential distribution）に従うとき，\\(X\\) の確率密度関数は\n\\[\nf_X(x) = \\begin{cases}\n\\lambda e^{-\\lambda x} & x \\geq 0 \\\\\n0 & x &lt; 0\n\\end{cases}\n\\]\nで与えられる．ここで \\(\\lambda &gt; 0\\) は分布のパラメータである．\n指数分布に従う確率変数 \\(X\\) の平均と分散は \\[\nE[X] = \\frac{1}{\\lambda}, \\quad \\text{Var}(X) = \\frac{1}{\\lambda^2}\n\\] である．\n\\(X\\) の累積分布関数は \\[\nF_X(x) = P(X \\leq x) = \\begin{cases}\n1 - e^{-\\lambda x} & x \\geq 0 \\\\\n0 & x &lt; 0\n\\end{cases}\n\\] である．\n次の図は，パラメータ \\(\\lambda = 0.5, 1.0, 1.5, 2.0\\) の場合における指数分布の確率密度関数を示している．確率密度関数 \\(f_X(x)\\) は \\(x\\) の増加に伴い単調減少する．\nコード\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy.stats import expon\n\nx = np.linspace(0, 8, 100)\nlambda_params = [0.5, 1.0, 1.5, 2.0]\nfor lam in lambda_params:\n    pdf = expon.pdf(x, scale=1 / lam)\n    plt.plot(x, pdf, label=f\"λ={lam}\")\nplt.title(\"Exponential Distribution PDF\")\nplt.xlabel(\"x\")\nplt.ylabel(\"$f_X(x)$\")\nplt.xlim(0, 8)\nplt.ylim(0, 2.5)\nplt.legend()\nplt.grid()\nplt.show()\n指数分布に従う確率変数は，時間を表すことが多い．パラメータ \\(\\lambda\\) は，単位時間あたりの事象の発生回数の平均を表す．",
    "crumbs": [
      "待ち行列理論",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>ポアソン過程</span>"
    ]
  },
  {
    "objectID": "queuing/poisson_process.html#指数分布",
    "href": "queuing/poisson_process.html#指数分布",
    "title": "16  ポアソン過程",
    "section": "",
    "text": "16.1.1 到着間隔とサービス時間\n\\(M/M/1\\) と \\(M/M/c\\) 待ち行列では，到着間隔とサービス時間が指数分布に従う．確率変数 \\(T\\) を到着間隔を表すとする．このとき，\\(P(T \\leq t)\\) は，時間 \\(t\\) 以内に次の客が到着する確率を表す．\\(E(T)\\) は，到着間隔の平均を表す．\\(\\lambda = 1/E(T)\\) は，単位時間あたりの到着する客数の平均を表す．この \\(\\lambda\\) は，前の章で説明した平均到着率である．\n\n例 16.1 ある店舗では，1時間あたり平均12人の客が来店する．到着間隔 \\(T\\) が指数分布に従うと仮定する．次の問いに答えよ．\n\n平均到着間隔 \\(E[T]\\) を求めよ．\n2分以内に次の客が到着する確率を求めよ．\n\n平均到着率は \\(\\lambda = 12\\) 人/時間である．平均到着間隔は\n\\[\nE[T] = 1/\\lambda = 1/12 \\text{ 時間} = 5 \\text{ 分}\n\\] である．\n単位を時間に揃え，\\(P(T \\leq 1/30)\\) を計算する． \\[\nP(T \\leq 1/30) = F_T(1/30) = 1 - e^{-12 \\times (1/30)} \\approx 0.3297\n\\] よって，2分以内に次の客が到着する確率は約0.3297である．\n\n次の図は，例 16.1 で説明した到着間隔のシミュレーション例を示している．平均到着率 \\(\\lambda = 12\\) 人/時間であるとき，15人の到着時間をシミュレーションした．横軸は時間を表し，青い線は各客の到着時間を示している．\n\n\nコード\nfrom scipy.stats import expon\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnp.random.seed(0)\nlambda_param = 12  # 平均到着率（人/時間）\nnum_arrivals = 15  # シミュレーションする到着数\ninter_arrival_times = expon.rvs(scale=1 / lambda_param, size=num_arrivals)\narrival_times = np.cumsum(inter_arrival_times)\nplt.figure(figsize=(10, 2))\nplt.eventplot(arrival_times, orientation=\"horizontal\", colors=\"blue\")\nplt.title(\"Simulated Arrival Times\")\nplt.xlabel(\"Time (hours)\")\nplt.yticks([])\nplt.xlim(0, max(arrival_times) + 0.15)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n例 16.2 あるコールセンターでは，1時間あたり平均6人の客を処理できる．サービス時間 \\(T\\) が指数分布に従うと仮定する．次の問いに答えよ．\n\n平均サービス時間 \\(E[T]\\) を求めよ．\n3分以内にサービスが完了する確率を求めよ．\n\n平均サービス率は \\(\\mu = 6\\) である．平均サービス時間は次のように計算される． \\[\nE[T] = \\frac{1}{\\mu} = \\frac{1}{6} \\text{ 時間} = 10 \\text{ 分}\n\\]\n\\(P(T \\leq 0.05)\\) を計算する． \\[\nP(T \\leq 0.05) = F_T(0.05) = 1 - e^{-6 \\times 0.05} \\approx 0.2592\n\\] よって，3分以内にサービスが完了する確率は約0.2592である．\n\n\n\n16.1.2 無記憶性\n\n定義 16.1 確率変数 \\(T\\) が無記憶性（memoryless）を持つとは，任意の非負実数 \\(s, t\\) に対して \\[\nP(T &gt; s + t \\mid T &gt; s) = P(T &gt; t), \\quad (s, t \\geq 0)\n\\] が成り立つことをいう．\n\n確率変数 \\(T\\)　を到着間隔とする．無記憶性とは，すでに時間 \\(s\\) が経過している場合（\\(T &gt; s\\)），さらに時間 \\(t\\) 経過した後に到着が発生していない確率（\\(T &gt; s + t\\)）が，最初から時間 \\(t\\) 経過した後に到着が発生していない確率と等しいことを意味する．\n\n例 16.3 仮に，バスの到着間隔が指数分布に従うのであれば，「すでに10分待っていたので，そろそろバスが来るだろう」という考え方は成り立たない．\n\n\n定理 16.1 指数分布に従う確率変数は無記憶性を持つ．\n\n\n証明. \\[\\begin{align*}\nP(T &gt; s + t \\mid T &gt; s) & = \\frac{P(T &gt; s + t, T &gt; s)}{P(T &gt; s)} \\\\\n& = \\frac{P(T &gt; s + t)}{P(T &gt; s)} \\\\\n& = \\frac{e^{-\\lambda (s + t)}}{e^{-\\lambda s}} \\\\\n& = e^{-\\lambda t} \\\\\n& = P(T &gt; t)\n\\end{align*}\\]\n\n指数分布が無記憶性を持つ唯一の連続分布である．",
    "crumbs": [
      "待ち行列理論",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>ポアソン過程</span>"
    ]
  },
  {
    "objectID": "queuing/poisson_process.html#ポアソン過程",
    "href": "queuing/poisson_process.html#ポアソン過程",
    "title": "16  ポアソン過程",
    "section": "16.2 ポアソン過程",
    "text": "16.2 ポアソン過程\n確率過程 \\(\\{N(t), t \\geq 0\\}\\) とは，時間 \\(t\\) とともに変化する確率変数 \\(N(t)\\) の集まりである．\n計数過程（counting process）とは，次の条件を満たす確率過程 \\(\\{N(t), t \\geq 0\\}\\) である．\n\n\\(N(t) \\geq 0\\)\n\\(N(t) \\in \\mathbb{Z}\\)\n\\(N(t)\\) は単調増加である\n\n\\(N(t)\\) は，時刻 \\(t\\) までに発生した事象の回数を表す．例として，客の到着数，機械の故障回数などが挙げられる．\n\n定義 16.2 確率過程 \\(\\{N(t), t \\geq 0\\}\\) が独立増分（independent increments）を持つとは，任意の \\(0 \\leq t_1 &lt; t_2 &lt; \\cdots &lt; t_n\\) に対して， \\[\nN(t_2) - N(t_1), N(t_3) - N(t_2), \\ldots, N(t_n) - N(t_{n-1})\n\\] が互いに独立であることをいう．\n\n計数過程では，\\(N(t_i) - N(t_{i-1})\\) は時間区間 \\((t_{i-1}, t_i]\\) に発生した事象の回数を表す．計数過程が独立増分を持つとは，重なりのない時間区間における事象の発生回数が互いに独立であることを意味する．\n\n例 16.4 ある店舗での客の到着数を表す計数過程 \\(\\{N(t), t \\geq 0\\}\\) を考える．この計数過程が独立増分を持つとは，例えば，時間区間 \\((0, 1]\\) に到着した客数と時間区間 \\((3, 6]\\) に到着した客数が独立であることを意味する．\n\n\n定義 16.3 確率過程 \\(\\{N(t), t \\geq 0\\}\\) が定常増分（stationary increments）を持つとは，任意の \\(t &gt; s \\geq 0\\) と \\(h \\geq 0\\) に対して，\\(N(t) - N(s)\\) と \\(N(t + h) - N(s + h)\\) が同一の分布に従うことをいう．\n\n計数過程が定常増分を持つとは，事象の発生回数は時間区間の長さのみに依存し，時間の位置には依存しないことを意味する．\n\n例 16.5 ある店舗での客の到着数を表す計数過程 \\(\\{N(t), t \\geq 0\\}\\) を考える．この計数過程が定常増分を持つとは，例えば，12時から13時の間に到着した客数と、14時から15時の間に到着した客数が同じ分布に従うことを意味する．\n\n\n定義 16.4 以下の性質を満たす計数過程 \\(\\{N(t), t \\geq 0\\}\\) を パラメータ \\(\\lambda &gt; 0\\) のポアソン過程（Poisson process）という．\n\n\\(N(0) = 0\\)\n\\(P(N(t + \\Delta t) - N(t) = 1) = \\lambda \\Delta t + o(\\Delta t)\\)\n\\(P(N(t + \\Delta t) - N(t) \\geq 2) = o(\\Delta t)\\)\n独立増分を持つ\n\nここで，\\(o(\\Delta t)\\) は \\[\n\\lim_{\\Delta t \\to 0} \\frac{o(\\Delta t)}{\\Delta t} = 0\n\\] を満たす関数である．\n\n\\(N(0) = 0\\) は，時刻 \\(0\\) では事象が発生していないことを表す．\n\\(P(N(t + \\Delta t) - N(t) = 1) = \\lambda \\Delta t + o(\\Delta t)\\) は，時間区間 \\([t, t + \\Delta t]\\) に事象が1回発生する確率を表す．\\(\\Delta t\\) が十分小さいとき，事象が1回発生する確率は \\(\\lambda \\Delta t\\) に近似できる．\n\\(P(N(t + \\Delta t) - N(t) \\geq 2) = o(\\Delta t)\\) は，時間区間 \\([t, t + \\Delta t]\\) に事象が2回以上発生する確率を表す．\\(\\Delta t\\) が十分小さいとき，事象が2回以上発生する確率は無視できるほど小さい．\n\n定義 16.5 離散型確率変数 \\(X\\) がポアソン分布（Poisson distribution）に従うとは，次の確率質量関数を持つことをいう． \\[\np_X(k) = P(X = k) = e^{-\\lambda} \\frac{\\lambda^k}{k!}, \\quad k = 0, 1, 2, \\ldots\n\\] ここで，\\(\\lambda &gt; 0\\) は分布のパラメータである．\n\nポアソン分布の平均と分散は \\[\nE[X] = \\lambda, \\quad \\text{Var}(X) = \\lambda\n\\] である．\n次の定理は，ポアソン過程 \\(\\{N(t), t \\geq 0\\}\\) とポアソン分布の関係を示している．\n\n定理 16.2 \\(\\{N(t), t \\geq 0\\}\\) をパラメータ \\(\\lambda &gt; 0\\) のポアソン過程とする．このとき，\\(N(t)\\) は時刻 \\(t\\) までに発生した事象の回数を表し，パラメータ \\(\\lambda t\\) のポアソン分布に従う．すなわち， \\[\nP(N(t) = k) = e^{-\\lambda t} \\frac{(\\lambda t)^k}{k!}, \\quad k = 0, 1, 2, \\ldots.\n\\]\n\n\n証明. 省略する．\n\n\n例 16.6 ある店舗での客の到着数を表すポアソン過程 \\(\\{N(t), t \\geq 0\\}\\) を考える．平均到着率は \\(\\lambda = 5\\) 人/分である．営業時間は10:00から18:00までの8時間である．次の問いに答えよ．\n\n10:00から10:03までの3分間に到着する客数の分布を求めよ．\n11:00から11:03までの3分間に2人の客が到着する確率を求めよ．\n\n開店から3分間の到着数は，\\(N(3)\\) と表される．\\(N(3)\\) はパラメータ \\(\\lambda t\\) のポアソン分布に従う． \\[\nP(N(3) = k) = e^{-5 \\cdot 3} \\frac{(5 \\cdot 3)^k}{k!}, \\quad k = 0, 1, 2, \\ldots\n\\]\n独立増分を持つため，11:00から11:03までの到着数も同じ分布に従う．\n\\[\nP(N(3) = 2) = e^{-5 \\cdot 3} \\frac{(5 \\cdot 3)^2}{2!}\n\\]",
    "crumbs": [
      "待ち行列理論",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>ポアソン過程</span>"
    ]
  },
  {
    "objectID": "queuing/poisson_process.html#ポアソン過程の到着間隔",
    "href": "queuing/poisson_process.html#ポアソン過程の到着間隔",
    "title": "16  ポアソン過程",
    "section": "16.3 ポアソン過程の到着間隔",
    "text": "16.3 ポアソン過程の到着間隔\n\\(Y_k\\) を \\(k\\) 回目の事象が発生するまでの時間とし，\\(T_k\\) は \\((k-1)\\) 回目から \\(k\\) 回目の事象が起こるまでの時間とする．\\(k = 1, 2, \\ldots\\) に対して， \\[\nT_1 = Y_1, \\quad T_k = Y_k - Y_{k-1} \\quad (k = 2, 3, \\ldots)\n\\] と定義する．また， \\[\nY_k = \\sum_{i=1}^k T_i = T_1 + T_2 + \\cdots + T_k\n\\] である．\n\n定理 16.3 \\(\\{N(t), t \\geq 0\\}\\) をパラメータ \\(\\lambda &gt; 0\\) のポアソン過程とする．このとき，\\(k = 1, 2, \\ldots\\) に対して，時間間隔 \\(T_k \\sim \\text{Exp}(\\lambda)\\) に従い，\\(T_1, T_2, \\ldots\\) は互いに独立である．\n\n\n証明. 省略する．\n\n\\(Y_k\\) の期待値と分散は \\[\n\\mathbb{E}[Y_k] = \\mathbb{E}[T_1] + \\mathbb{E}[T_2] + \\cdots + \\mathbb{E}[T_k] = \\frac{k}{\\lambda},\n\\] \\[\n\\text{Var}(Y_k) = \\text{Var}(T_1) + \\text{Var}(T_2) + \\cdots + \\text{Var}(T_k) = \\frac{k}{\\lambda^2}\n\\] である．\n\\(Y_k\\) の確率密度関数は \\[\nf_{Y_k}(y) = \\frac{\\lambda^k y^{k-1} e^{-\\lambda y}}{(k-1)!}, \\quad y \\geq 0\n\\] である．これのとき，\\(Y_k\\) はアーラン分布（Erlang distribution）に従う．\n\n例 16.7 あるコールセンターではの電話の到着はポアソン過程に従うとする．田中さんが電話したとき，\\(11\\) 人の客が すでに待っていた．オペレーターが1人で，平均サービス率は \\(\\mu = 2\\) 人/分であるとする．田中さんがサービスを受け始めるまでの待ち時間の期待値を求めよ．\nサービスを受けている客のサービス時間もパラメータ \\(\\mu\\) の指数分布に従う． \\[\n\\mathbb{E}[Y] = \\frac{12}{\\lambda} = \\frac{12}{2} = 6 \\text{ 分}\n\\]",
    "crumbs": [
      "待ち行列理論",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>ポアソン過程</span>"
    ]
  },
  {
    "objectID": "queuing/birth-death.html",
    "href": "queuing/birth-death.html",
    "title": "17  出生死滅過程",
    "section": "",
    "text": "17.1 定常状態\n出生死滅過程では，時刻 \\(t\\) における生物集団の個体数を \\(X_t\\) で表す．これを状態（state）とも呼ぶ．状態 \\(X_t\\) は状態空間 \\(\\{0, 1, 2, \\ldots\\}\\) 上に値をとる．状態遷移（state transition）は，個体の出生または死滅によって引き起こされる．出生死滅過程では，状態遷移は隣接する状態間でのみ発生する．状態 \\(n\\) から状態 \\(n+1\\) に遷移する確率を \\(\\lambda_n\\)，状態 \\(n \\geq 1\\) から状態 \\(n-1\\) に遷移する確率を \\(\\mu_n\\) と表す．すなわち，\n\\[\n\\lambda_n = P(X_{t+1} = n+1 | X_t = n),\n\\] \\[\n\\mu_n = P(X_{t+1} = n-1 | X_t = n).\n\\]\n出生死滅過程の遷移確率図は以下に示す．\n時刻 \\(t\\) においてに，状態 \\(n\\) に入る回数を \\(E_n(t)\\)，状態 \\(n\\) を出る回数を \\(L_n(t)\\) と表すとき， \\[\n|E_n(t) - L_n(t)| \\leq 1\n\\] が成り立つ．これを \\(t\\) で割ると， \\[\n\\left| \\frac{E_n(t)}{t} - \\frac{L_n(t)}{t} \\right| \\leq \\frac{1}{t}\n\\] となる．\\(t \\to \\infty\\) としたとき，\n\\[\n\\lim_{t \\to \\infty} \\frac{E_n(t)}{t} - \\lim_{t \\to \\infty} \\frac{L_n(t)}{t} = 0\n\\] が得られる．すなわち，\\(t \\to \\infty\\) としたとき，状態 \\(n\\) に入る遷移率と状態 \\(n\\) を出る遷移率は等しい．\nシステムが状態 \\(n\\) に滞在する確率（あるいは，時間比）を \\(\\pi_n\\) と表すとき，\n\\[\\begin{align*}\n\\pi_0 \\lambda_0 & = \\pi_1 \\mu_1 \\\\\n\\pi_1 (\\lambda_1 + \\mu_1) & = \\pi_0 \\lambda_0 + \\pi_2 \\mu_2 \\\\\n\\pi_2 (\\lambda_2 + \\mu_2) & = \\pi_1 \\lambda_1 + \\pi_3 \\mu_3 \\\\\n& \\vdots\n\\end{align*}\\]\nが成り立つ．これらの式は，一般に次のようにまとめられる．\n\\[\\begin{align*}\n\\pi_0 \\lambda_0 & = \\pi_1 \\mu_1 & \\\\\n\\pi_n (\\lambda_n + \\mu_n) & = \\pi_{i-1} \\lambda_{i-1} + \\pi_{i+1} \\mu_{i+1} & (i = 1, 2, \\ldots)\n\\end{align*}\\]\nこれらの方程式を大域平衡方程式（global balance equation）と呼ぶ．\nさらに，\\(\\pi_0 \\lambda_0 = \\pi_1 \\mu_1\\) を \\(\\pi_1 (\\lambda_1 + \\mu_1) = \\pi_0 \\lambda_0 + \\pi_2 \\mu_2\\) に代入して整理すると，\\(\\pi_1 \\lambda_1 = \\pi_2 \\mu_2\\) が得られる．同様にして，他の状態についてもこのような変形を行うと，一般に，\n\\[\n\\pi_n \\lambda_n = \\pi_{n+1} \\mu_{n+1}, \\quad (n = 0, 1, 2, \\ldots)\n\\] が得られる．これらの方程式を局所平衡方程式（local balance equation）と呼ぶ．\n局所平衡方程式より，\\(\\pi_0\\) を用いて，\\(n \\geq 1\\) に対して，\n\\[\n\\pi_n = \\pi_0 \\frac{\\lambda_0 \\lambda_1 \\cdots \\lambda_{n-1}}{\\mu_1 \\mu_2 \\cdots \\mu_n}, \\quad (n = 1, 2, \\ldots)\n\\]\nが得られる．また，\\(\\sum_{n=0}^{\\infty} \\pi_n = 1\\) であるから，\n\\[\n\\pi_0 + \\sum_{n=1}^{\\infty} \\pi_0 \\frac{\\lambda_0 \\lambda_1 \\cdots \\lambda_{n-1}}{\\mu_1 \\mu_2 \\cdots \\mu_n} = 1\n\\] となる．これにより，\\(\\pi_0\\) は次のように与えられる．\n\\[\n\\pi_0 = \\left( 1 + \\sum_{n=1}^{\\infty} \\frac{\\lambda_0 \\lambda_1 \\cdots \\lambda_{n-1}}{\\mu_1 \\mu_2 \\cdots \\mu_n} \\right)^{-1}\n\\]",
    "crumbs": [
      "待ち行列理論",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>出生死滅過程</span>"
    ]
  },
  {
    "objectID": "queuing/birth-death.html#評価指標",
    "href": "queuing/birth-death.html#評価指標",
    "title": "17  出生死滅過程",
    "section": "17.2 評価指標",
    "text": "17.2 評価指標\n出生死滅過程に基づいた待ち行列モデルにおいて，状態はシステム内の客数を表す．\\(\\pi_n\\) は，システム内に \\(n\\) 人の客が存在する確率を表す．平均系内客数 \\(\\mathbb{E}(L)\\)，平均待ち行列長 \\(\\mathbb{E}(L_q)\\) は，それぞれ次のように与えられる．\n\\[\n\\mathbb{E}[L] = \\sum_{n=0}^{\\infty} n \\pi_n, \\quad \\mathbb{E}[L_q] = \\sum_{n=c}^{\\infty} (n - c) \\pi_n.\n\\]\n平均滞在時間 \\(\\mathbb{E}[W]\\)，平均待ち時間 \\(\\mathbb{E}[W_q]\\) は，リトルの法則により，次のように与えられる． \\[\n\\mathbb{E}[W] = \\frac{\\mathbb{E}[L]}{\\bar{\\lambda}}, \\quad \\mathbb{E}[W_q] = \\frac{\\mathbb{E}[L_q]}{\\bar{\\lambda}},\n\\]\nここで，\\(\\bar{\\lambda}\\) は平均到着率であり， \\[\n\\bar{\\lambda} = \\sum_{n=0}^{\\infty} \\lambda_n \\pi_n\n\\] で与えられる．",
    "crumbs": [
      "待ち行列理論",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>出生死滅過程</span>"
    ]
  },
  {
    "objectID": "queuing/birth-death.html#mm1-モデル",
    "href": "queuing/birth-death.html#mm1-モデル",
    "title": "17  出生死滅過程",
    "section": "17.3 \\(M/M/1\\) モデル",
    "text": "17.3 \\(M/M/1\\) モデル\n\\(M/M/1\\) モデルを考える．到着間隔が指数分布に従い，平均到着率が \\(\\lambda\\) である．サービス時間も指数分布に従い，平均サービス率が \\(\\mu\\) である．サーバ数は1である．\n\\(M/M/1\\) モデルを出生死滅過程として表すと，すべての状態において，出生率が \\(\\lambda\\)，死滅率が \\(\\mu\\) となる．すなわち，\\(M/M/1\\) モデルは \\(n \\geq 0\\) に対して，\\(\\lambda_n = \\lambda\\)，\\(\\mu_n = \\mu\\) で表される出生死滅過程である．\n\n17.3.1 \\(M/M/1\\) モデルの定常状態\n\\(M/M/1\\) モデルにおいて，\\(\\rho = \\lambda / \\mu &lt; 1\\) のとき，定常状態が存在する．このとき，\\(\\pi_0\\) は \\[\n\\pi_0 = \\left( 1 + \\sum_{n=1}^{\\infty} \\frac{\\lambda^n}{\\mu^n} \\right)^{-1} = \\left( 1 + \\sum_{n=1}^{\\infty} \\rho^n \\right)^{-1} = \\left( 1 + \\frac{\\rho}{1-\\rho} \\right)^{-1} = 1 - \\rho\n\\]\nで与えられる．\n\n\n\n\n\n\nヒント\n\n\n\n\\(|x| &lt; 1\\) に対して，次の式が成り立つ．\n\\[\n\\sum_{n=0}^{\\infty} x^n = \\frac{1}{1-x} \\quad (|x| &lt; 1)\n\\]\nこれを用いると，\n\\[\n\\sum_{n=1}^{\\infty} x^n = \\sum_{n=0}^{\\infty} x^n - 1 = \\frac{1}{1-x} - 1 = \\frac{x}{1-x} \\quad (|x| &lt; 1)\n\\]\nが得られる．\n\n\n\\(\\pi_0\\) を用いると，任意の \\(n \\geq 0\\) に対して， \\[\n\\pi_n = \\pi_0 \\frac{\\lambda^n}{\\mu^n} = (1 - \\rho) \\rho^n, \\quad (n = 0, 1, 2, \\ldots)\n\\] が得られる．\n結論として，\\(M/M/1\\) モデルにおいて，\\(\\rho = \\lambda / \\mu &lt; 1\\) のとき，\\(\\pi_n\\) は \\[\n\\pi_n = (1 - \\rho) \\rho^n, \\quad (n = 0, 1, 2, \\ldots)\n\\] である．\n\n\n17.3.2 \\(M/M/1\\) モデルの評価指標\n\\(M/M/1\\) モデルにおける平均系内客数 \\(\\mathbb{E}[L]\\) は次のように計算される．\n\\[\\begin{align*}\n\\mathbb{E}[L] & = \\sum_{n=0}^{\\infty} n \\pi_n \\\\\n  & = \\sum_{n=0}^{\\infty} n (1 - \\rho) \\rho^n \\\\\n  & = (1 - \\rho) \\sum_{n=0}^{\\infty} n \\rho^n \\\\\n  & = (1 - \\rho) \\cdot \\frac{\\rho}{(1 - \\rho)^2} \\\\\n  & = \\frac{\\rho}{1 - \\rho} \\\\\n  & = \\frac{\\lambda}{\\mu - \\lambda}\n\\end{align*}\\]\n\n\n\n\n\n\nヒント\n\n\n\n\\(\\sum_{n=0}^{\\infty} n \\rho^n = \\frac{\\rho}{(1 - \\rho)^2}\\) の導出を示す．\n\\[\\begin{align*}\n\\sum_{n=0}^{\\infty} n x^n & = x + 2x^2 + 3x^3 + \\cdots \\\\\n& = x (1 + 2x + 3x^2 + \\cdots) \\\\\n& = x \\sum_{n=1}^{\\infty} n x^{n-1} \\\\\n& = x \\sum_{n=1}^{\\infty} \\frac{d}{dx} x^n \\\\\n& = x \\frac{d}{dx} \\sum_{n=1}^{\\infty} x^n \\\\\n& = x \\frac{d}{dx} \\left(\\frac{x}{1-x}\\right) \\\\\n& = x \\cdot \\frac{1}{(1-x)^2} \\\\\n& = \\frac{x}{(1-x)^2}\n\\end{align*}\\]\n\n\n同様にして，平均待ち行列長 \\(\\mathbb{E}[L_q]\\) は次のように計算される．\n\\[\\begin{align*}\n\\mathbb{E}[L_q] & = \\sum_{n=1}^{\\infty} (n - 1) \\pi_n \\\\\n    & = \\sum_{n=1}^{\\infty} n \\pi_n - \\sum_{n=1}^{\\infty} \\pi_n \\\\\n    & = \\mathbb{E}[L] - (1 - \\pi_0) \\\\\n    & = \\frac{\\rho}{1 - \\rho} - \\rho \\\\\n    & = \\frac{\\rho^2}{1 - \\rho} \\\\\n    & = \\frac{\\lambda^2}{\\mu (\\mu - \\lambda)}\n\\end{align*}\\]\n\n\n\n\n\n\nヒント\n\n\n\nここでは， \\[\n\\sum_{n=1}^{\\infty} n \\pi_n = \\sum_{n=0}^{\\infty} n \\pi_n = \\mathbb{E}[L]\n\\] および， \\[\n\\sum_{n=1}^{\\infty} \\pi_n = 1 - \\pi_0 = 1 - (1 - \\rho) = \\rho\n\\] を用いている．\n\n\n\\(M/M/1\\) モデルにおける平均滞在時間 \\(\\mathbb{E}[W]\\)，平均待ち時間 \\(\\mathbb{E}[W_q]\\) は，リトルの法則により，次のように与えられる． \\[\n\\mathbb{E}[W] = \\frac{\\mathbb{E}[L]}{\\lambda} = \\frac{1}{\\mu - \\lambda}, \\quad \\mathbb{E}[W_q] = \\frac{\\mathbb{E}[L_q]}{\\lambda} = \\frac{\\lambda}{\\mu (\\mu - \\lambda)}\n\\]\n\n\n\n\n\n\nノート\\(M/M/1\\) モデル\n\n\n\n\\(M/M/1\\) モデルにおいて，\\(\\rho = \\lambda / \\mu &lt; 1\\) のとき，\\(\\mathbb{E}[L]\\)，\\(\\mathbb{E}[L_q]\\)，\\(\\mathbb{E}[W]\\)，\\(\\mathbb{E}[W_q]\\) はそれぞれ次のように与えられる． \\[\n\\mathbb{E}[L] = \\frac{\\rho}{1 - \\rho} = \\frac{\\lambda}{\\mu - \\lambda},\n\\] \\[\n\\mathbb{E}[L_q] = \\frac{\\rho^2}{1 - \\rho} = \\frac{\\lambda^2}{\\mu (\\mu - \\lambda)},\n\\] \\[\n\\mathbb{E}[W] = \\frac{1}{\\mu - \\lambda},\n\\] \\[\n\\mathbb{E}[W_q] = \\frac{\\lambda}{\\mu (\\mu - \\lambda)}.\n\\]\n\n\n下図は，\\(M/M/1\\) モデルにおける利用率 \\(\\rho\\) と平均系内客数 \\(\\mathbb{E}[L]\\) の関係を示している．\n\n\nコード\n# rho vs L plot for M/M/1 model\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nrho = np.linspace(0.01, 0.99, 100)\nL = rho / (1 - rho)\nplt.plot(rho, L)\nplt.ylim(0, 50)\nplt.xlim(0, 1.1)\nplt.xlabel(\"Utilization ρ\")\nplt.ylabel(\"Average number of customers in system L\")\nplt.title(\"M/M/1 Model: Utilization vs Average Number of Customers in System\")\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n17.3.3 待ち時間分布\n客の滞在時間 \\(W\\) と待ち時間 \\(W_q\\) の確率分布を分析する．ここで，サービス規律は FCFS （First-Come, First-Served）と仮定する．\n\\(T_1, T_2, \\ldots, T_n\\) を，サービス時間を表す確率変数とする．ある客が到着したときに，システム内に \\(n\\) 人の客が存在するとする．このとき，この客の待ち時間は \\[\nY_n = T_1 + T_2 + \\cdots + T_n\n\\] であり，滞在時間は \\[\nY_{n+1} = T_1 + T_2 + \\cdots + T_n + T_{n+1}\n\\] である．",
    "crumbs": [
      "待ち行列理論",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>出生死滅過程</span>"
    ]
  },
  {
    "objectID": "queuing/birth-death.html#文献案内",
    "href": "queuing/birth-death.html#文献案内",
    "title": "17  出生死滅過程",
    "section": "17.4 文献案内",
    "text": "17.4 文献案内\nBertsekas と Tsitsiklis (2008) の「Introduction to Probability」では，確率過程とマルコフ連鎖を含めた確率論の基礎が解説されている．\nもっと詳しく待ち行列理論を学びたい場合は，Shortle ほか (2018) の「Fundamentals of Queueing Theory」が参考になる．\n\n\n\n\nBertsekas, Dimitri, と John N Tsitsiklis. 2008. Introduction to probability. Athena Scientific.\n\n\nShortle, John F, James M Thompson, Donald Gross, と Carl M Harris. 2018. Fundamentals of queueing theory. Wiley Series in Probability and Statistics. Nashville, TN: John Wiley & Sons.",
    "crumbs": [
      "待ち行列理論",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>出生死滅過程</span>"
    ]
  },
  {
    "objectID": "ip/branch-and-bound.html",
    "href": "ip/branch-and-bound.html",
    "title": "20  General Branch-and-Bound",
    "section": "",
    "text": "20.1 ILP Problem\nThe branch-and-bound method is a general algorithm for solving combinatorial optimization problems by intelligently enumerating all the feasible points.\nThe branch refers to the process of partitioning the solution space. The bound refers to lower bounds that are used to construct a proof of optimality.\nOne of the important applications of branch-and-bound is the ILP (Integer Linear Programming) problem.",
    "crumbs": [
      "整数計画法",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>General Branch-and-Bound</span>"
    ]
  },
  {
    "objectID": "ip/branch-and-bound.html#general-branch-and-bound-algorithm",
    "href": "ip/branch-and-bound.html#general-branch-and-bound-algorithm",
    "title": "20  General Branch-and-Bound",
    "section": "20.2 General Branch-and-Bound Algorithm",
    "text": "20.2 General Branch-and-Bound Algorithm\n```qlkyesigrndcjxd General Branch-and-Bound :label: bb-algorithm\n\nInitialize current best node \\(v^*\\)\nUB \\(\\leftarrow \\infty\\)\nCreate a queue \\(Q\\)\n\\(Q.\\text{put}(root)\\)\nWhile \\(Q\\) is not empty:\n\n\\(k \\leftarrow\\) \\(Q.\\text{get}()\\)\ngenerate children of node \\(k\\), child \\(i \\in \\mathcal{S}(k)\\)\ngenerate lower bounds \\(LB_i\\) for each child \\(i\\)\nFor each \\(i \\in \\mathcal{S}(k)\\):\n\nIf \\(LB_i \\geq\\) UB, kill child \\(i\\)\nElse if child \\(i\\) is a leaf node:\n\nUB \\(\\leftarrow\\) value of child \\(i\\)\n\\(v^* \\leftarrow i\\)\n\nElse:\n\n\\(Q.\\text{put}(i)\\) ```\n\n\n\n\n'''\nBranch and Bound algorithm for the shortest path problem\n\nWe branch from a node with the lowest lower bound using a priority queue.\n'''\n\nfrom queue import PriorityQueue\nimport networkx as nx\n\n# shortest path problem\nclass ShortestPathProblem:\n    def __init__(self, graph):\n        self.graph = graph\n    \n    def branch(self, node):\n        children = []\n        weights = []\n        # Generate children of the node\n        for child in self.graph.successors(node):\n            children.append(child)\n            weights.append(self.graph[node][child]['weight'])\n\n        return children, weights\n\n# Node class in the branch and bound algorithm\nclass Node:\n    def __init__(self, node_idx, lower_bound):\n        self.node_idx = node_idx\n        self.lower_bound = lower_bound\n        self.solution = []\n\n    def update_solution(self, parent_solution):\n        self.solution = parent_solution.copy()\n        self.solution.append(self.node_idx)\n\n    def __lt__(self, other):\n        return self.lower_bound &lt; other.lower_bound\n\ndef branch_and_bound(problem):\n    \n    U = float('inf')\n    current_best_solution = None\n    current_best_value = None\n\n    priority_queue = PriorityQueue(maxsize=0)\n\n    # Initialize the priority queue with the root node\n    root_node = Node(0, 0)\n    root_node.solution.append(0)\n    priority_queue.put((0, root_node))\n\n    while not priority_queue.empty():\n\n        _, node = priority_queue.get()\n\n        # generate children of the node\n        children, weights = problem.branch(node.node_idx)\n\n        for child, weight in zip(children, weights):\n            z = node.lower_bound + weight\n\n            if z &gt;= U:\n                continue\n            elif child == 10:\n                U = z\n                current_best_value = z\n                current_best_solution = node.solution.copy()\n            else:\n                new_node = Node(child, z)\n                new_node.update_solution(node.solution)\n                priority_queue.put((z, new_node))\n\n    return current_best_value, current_best_solution\n\n\nif __name__ == '__main__':\n\n    '''\n    Define the shortest-path problem.\n    Example from the book:\n    Papadimitriou, Christos H., and Kenneth Steiglitz. 1998. Combinatorial Optimization: Algorithms and Complexity. Courier Corporation.    \n    '''\n    G = nx.DiGraph()\n\n    # Add nodes\n    G.add_nodes_from(range(0, 11))\n\n    # Add edges\n    G.add_edge(0, 1, weight=2)\n    G.add_edge(0, 2, weight=3)\n    G.add_edge(0, 3, weight=4)\n    G.add_edge(1, 4, weight=7)\n    G.add_edge(1, 5, weight=2)\n    G.add_edge(1, 2, weight=3)\n    G.add_edge(2, 5, weight=9)\n    G.add_edge(2, 6, weight=2)\n    G.add_edge(3, 6, weight=2)\n    G.add_edge(4, 7, weight=1)\n    G.add_edge(4, 8, weight=2)\n    G.add_edge(5, 8, weight=3)\n    G.add_edge(5, 6, weight=1)\n    G.add_edge(6, 8, weight=5)\n    G.add_edge(6, 9, weight=1)\n    G.add_edge(7, 10, weight=4)\n    G.add_edge(8, 10, weight=4)\n    G.add_edge(9, 10, weight=2)\n    G.add_edge(9, 8, weight=2)\n\n    spp = ShortestPathProblem(G)\n\n\n    value, solution = branch_and_bound(spp)\n    print('Shortest path value:', value)\n    print('Shortest path:', solution)",
    "crumbs": [
      "整数計画法",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>General Branch-and-Bound</span>"
    ]
  },
  {
    "objectID": "career/intro.html",
    "href": "career/intro.html",
    "title": "21  キャリア",
    "section": "",
    "text": "21.1 リンク",
    "crumbs": [
      "OR キャリア",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>キャリア</span>"
    ]
  },
  {
    "objectID": "career/intro.html#リンク",
    "href": "career/intro.html#リンク",
    "title": "21  キャリア",
    "section": "",
    "text": "Informs\n\nConsider a Career in Operations Research and Analytics!\n\n日本オペレーションズ・リサーチ学会\n\nOR キャリアセッション\n企業事例交流会\nOR 実施事例\n\n日本経営工学会\n\n産学連携研究交流会\n\nキヤノン\n\n日本オペレーションズ・リサーチ（OR）学会レポート活動の舞台裏を大公開！",
    "crumbs": [
      "OR キャリア",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>キャリア</span>"
    ]
  },
  {
    "objectID": "career/intro.html#関連学会",
    "href": "career/intro.html#関連学会",
    "title": "21  キャリア",
    "section": "21.2 関連学会",
    "text": "21.2 関連学会\n\n日本オペレーションズ・リサーチ学会\n日本経営工学会",
    "crumbs": [
      "OR キャリア",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>キャリア</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "参考文献",
    "section": "",
    "text": "Arrow, Kenneth J, Theodore Harris, and Jacob Marschak. 1951.\n“Optimal Inventory Policy.” Econometrica 19 (3):\n250.\n\n\nBertsekas, Dimitri, and John N Tsitsiklis. 2008. Introduction to\nProbability. Athena Scientific.\n\n\nBrunelli, Matteo. 2015. Introduction to the Analytic Hierarchy\nProcess. 2015th ed. SpringerBriefs in Operations Research. Cham:\nSpringer International Publishing.\n\n\nCamm, Jeffrey, James Cochran, Michael Fry, Jeffrey Ohlmann, David\nAnderson, Dennis Sweeney, and Thomas Williams. 2022. An Introduction\nto Management Science: Quantitative Approaches to Decision Making.\n16th ed. Florence, AL: South-Western College Publishing.\n\n\nCrawford, Gordon, and Cindy Williams. 1985. “A Note on the\nAnalysis of Subjective Judgment Matrices.” Journal of\nMathematical Psychology, Some thoughts about the mathematics of the\nanalytic hierarchy process, 29 (4): 387–405.\n\n\nEiselt, H A, and Carl-Louis Sandblom. 2022. Operations Research: A\nModel-Based Approach. Cham: Springer International Publishing.\n\n\nHarris, Ford W. 1990. “How Many Parts to Make at Once.”\nOper. Res. 38 (6): 947–50.\n\n\nHillier, Frederick, and Gerald Lieberman. 2025. ISE\nIntroduction to Operations Research. 11th ed. Columbus, OH:\nMcGraw-Hill Education.\n\n\nHuber, Jakob, Sebastian Müller, Moritz Fleischmann, and Heiner\nStuckenschmidt. 2019. “A Data-Driven Newsvendor Problem: From Data\nto Decision.” Eur. J. Oper. Res. 278 (3): 904–15.\n\n\nLittle, John D C. 1961. “A Proof for the Queuing Formula:\nL = λw.” Oper. Res. 9 (3): 383–87.\n\n\nPleguezuelo, Rafael Herrerı́as, José Garcı́a Pérez, and Salvador Cruz\nRambaud. 2003. “A Note on the Reasonableness of PERT\nHypotheses.” Oper. Res. Lett. 31 (1): 60–62.\n\n\nQin, Yan, Ruoxuan Wang, Asoo J Vakharia, Yuwen Chen, and Michelle M H\nSeref. 2011. “The Newsvendor Problem: Review and Directions for\nFuture Research.” Eur. J. Oper. Res. 213 (2): 361–74.\n\n\nSaaty, Thomas L. 1977. “A Scaling Method for Priorities in\nHierarchical Structures.” J. Math. Psychol. 15 (3):\n234–81.\n\n\nScarf, Herbert. 1959. “The Optimality of (S, s)\nPolicies in the Dynamic Inventory Problem.”\n\n\nShortle, John F, James M Thompson, Donald Gross, and Carl M Harris.\n2018. Fundamentals of Queueing Theory. Wiley Series in\nProbability and Statistics. Nashville, TN: John Wiley & Sons.\n\n\nSnyder, Lawrence V, and Zuo-Jun Max Shen. 2019. Fundamentals of\nSupply Chain Theory. 2nd ed. Nashville, TN: John Wiley & Sons.\n\n\nStidham, Shaler, Jr. 1974. “Technical Note—a Last Word on\nl = λw.” Oper. Res. 22 (2): 417–21.",
    "crumbs": [
      "参考文献"
    ]
  },
  {
    "objectID": "appendices/calculus.html",
    "href": "appendices/calculus.html",
    "title": "付録 A — 微分積分",
    "section": "",
    "text": "A.1 極値（Extremum）\n1変数関数 \\(f(x)\\) が点 \\(x = a\\) で極値をとるとき、\n\\[\nf'(a) = 0\n\\] が成り立つ。 \\(f''(a) &gt; 0\\) のとき、\\(f(a)\\) は極小値をとる。 \\(f''(a) &lt; 0\\) のとき、\\(f(a)\\) は極大値をとる。",
    "crumbs": [
      "付録",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>微分積分</span>"
    ]
  },
  {
    "objectID": "appendices/calculus.html#凸関数convex-function",
    "href": "appendices/calculus.html#凸関数convex-function",
    "title": "付録 A — 微分積分",
    "section": "A.2 凸関数（Convex Function）",
    "text": "A.2 凸関数（Convex Function）\n1 変数 2 階微分可能な関数 \\(f(x)\\) が凸関数であることの必要十分条件は、すべての \\(x\\) について\n\\[\nf''(x) \\geq 0\n\\]\nが成り立つことである。\n凸関数 \\(f(x)\\) の極小値は、最小値である。",
    "crumbs": [
      "付録",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>微分積分</span>"
    ]
  },
  {
    "objectID": "appendices/probability.html",
    "href": "appendices/probability.html",
    "title": "付録 B — 確率",
    "section": "",
    "text": "B.1 確率変数\n離散型確率変数 \\(X\\) が特定の値 \\(x\\) をとる確率を\n\\[\nP(X = x) = p_X(x)\n\\]\nと表すとき、\\(p_X(x)\\) を \\(X\\) の確率質量関数 (PMF) という。\n連続型確率変数 \\(X\\) がある区間 \\([a, b]\\) にある値をとる確率を\n\\[\nP(a \\leq X \\leq b) = \\int_a^b f_X(x) dx\n\\]\nと表す。\\(f_X(x)\\) を \\(X\\) の確率密度関数 (PDF) という。\n確率変数 \\(X\\) の累積分布関数 (CDF) を\n\\[\nF_X(x) = P(X \\leq x) = \\begin{cases}\n\\sum_{k \\leq x} p_X(k) & \\text{if } X \\text{ is discrete} \\\\\n\\int_{-\\infty}^x f_X(t) dt & \\text{if } X \\text{ is continuous}\n\\end{cases}\n\\]\nと表す。確率密度関数 \\(f_X(x)\\) は累積分布関数 \\(F_X(x)\\) の微分である。\n\\[\nf_X(x) = \\frac{d}{dx} F_X(x)\n\\]",
    "crumbs": [
      "付録",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>確率</span>"
    ]
  },
  {
    "objectID": "appendices/probability.html#確率分布",
    "href": "appendices/probability.html#確率分布",
    "title": "付録 B — 確率",
    "section": "B.2 確率分布",
    "text": "B.2 確率分布\n\nB.2.1 正規分布\n連続型確率変数 \\(X\\) は正規分布（normal distribution）に従うとき、\\(X \\sim N(\\mu, \\sigma^2)\\) と表す。ここで \\(\\mu\\) は平均、\\(\\sigma^2\\) は分散である。\\(X\\) の確率密度関数は\n\\[\nf_X(x) = \\frac{1}{\\sqrt{2\\pi} \\sigma} e^{-\\frac{(x - \\mu)^2}{2\\sigma^2}}\n\\]\nと表す。平均は \\(E[X] = \\mu\\)、分散は \\(\\text{Var}(X) = \\sigma^2\\) である。\n\\(X\\) が \\(N(\\mu, \\sigma^2)\\) に従うとき、\\(Y = aX + b\\) は、\\(N(a\\mu + b, a^2\\sigma^2)\\) に従う。特に、\\(Z = \\frac{X - \\mu}{\\sigma}\\) は標準正規分布（standard normal distribution）に従う。すなわち、\\(Z \\sim N(0, 1)\\) である。\n連続型確率変数 \\(Y\\) が標準正規分布に従うとき、\\(Y\\) の累積分布関数は\n\\[\n\\Phi(y) = P(Y \\leq y) = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^y e^{-\\frac{t^2}{2}} dt\n\\]\nと表す。標準正規分布表から、\\(y\\) の値に対する \\(\\Phi(y)\\) を調べることができる。\nPython では、以下のように \\(\\Phi(y)\\) を計算できる。\nfrom scipy.stats import norm\ndef phi(y):\n    return norm.cdf(y)\n\nphi(0)  # 0.5\nまた、\\(\\Phi(y)=0.95\\) のときの \\(y\\) の値を求めるには、以下のようにする。\nfrom scipy.stats import norm\ndef phi_inverse(p):\n    return norm.ppf(p)\n\nphi_inverse(0.95)  # 約1.64485\n正規分布は再生性（reproductive property）を持つ。すなわち、\\(X_1, X_2, \\ldots, X_n\\) が独立に \\(N(\\mu_i, \\sigma_i^2)\\) に従うとき、\\(Y = \\sum_{i=1}^n a_i X_i\\) は \\(N\\left(\\sum_{i=1}^n a_i \\mu_i, \\sum_{i=1}^n a_i^2 \\sigma_i^2\\right)\\) に従う。",
    "crumbs": [
      "付録",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>確率</span>"
    ]
  },
  {
    "objectID": "appendices/standard_normal_table.html",
    "href": "appendices/standard_normal_table.html",
    "title": "付録 C — 標準正規分布表",
    "section": "",
    "text": "下表は、標準正規分布 \\(N(0, 1)\\) の累積分布関数\n\\[\n\\phi(z) = P(Z \\leq z) = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{z} e^{-\\frac{t^2}{2}} dt\n\\]\nの値を示すものである。\n\n例 C.1 \\(z = 1.23\\) のとき、\\(\\phi(1.23)\\) の値を求めよ。\n表の行から \\(1.2\\)、列から \\(+0.03\\) を選ぶ。交差する値は \\(0.89065\\) である。したがって、\\(\\phi(1.23) = 0.89065\\) である。\n\n\n例 C.2 \\(\\phi(z) = 0.89065\\) のとき、\\(z\\) の値を求めよ。\n表の中から \\(0.89065\\) を探す。行から \\(1.2\\)、列から \\(+0.03\\) を選ぶ。したがって、\\(z = 1.23\\) である。\n\n\n例 C.3 \\(X \\sim N(100, 15^2)\\) のとき、\\(P(X \\leq 120)\\) の値を求めよ。\n\\[\\begin{align}\nP(X \\leq 120) &= \\phi\\left(\\frac{120 - 100}{15}\\right) \\\\\n&= \\phi\\left(\\frac{20}{15}\\right) \\\\\n&\\approx \\phi(1.33) \\\\\n\\end{align}\\]\n\n表から \\(\\phi(1.33) \\approx 0.90824\\) である。\n\n例 C.4 \\(X \\sim N(100, 15^2)\\) のとき、\\(P(X \\leq x) = 0.9\\) のとき、\\(x\\)の値を求めよ。\n\\[\\begin{align}\nP(X \\leq x) &= 0.9 \\\\\n\\phi\\left(\\frac{x - 100}{15}\\right) &= 0.9 \\\\\n\\frac{x - 100}{15} &\\approx 1.28 \\\\\nx - 100 &\\approx 19.2 \\\\\nx &\\approx 119.2 \\\\\n\\end{align}\\]\nしたがって、\\(x \\approx 119.2\\) である。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nz\n−0.00\n−0.01\n−0.02\n−0.03\n−0.04\n−0.05\n−0.06\n−0.07\n−0.08\n−0.09\n\n\n\n\n-3.9\n0.00005\n0.00005\n0.00004\n0.00004\n0.00004\n0.00004\n0.00004\n0.00004\n0.00003\n0.00003\n\n\n-3.8\n0.00007\n0.00007\n0.00007\n0.00006\n0.00006\n0.00006\n0.00006\n0.00005\n0.00005\n0.00005\n\n\n-3.7\n0.00011\n0.00010\n0.00010\n0.00010\n0.00009\n0.00009\n0.00008\n0.00008\n0.00008\n0.00008\n\n\n-3.6\n0.00016\n0.00015\n0.00015\n0.00014\n0.00014\n0.00013\n0.00013\n0.00012\n0.00012\n0.00011\n\n\n-3.5\n0.00023\n0.00022\n0.00022\n0.00021\n0.00020\n0.00019\n0.00019\n0.00018\n0.00017\n0.00017\n\n\n-3.4\n0.00034\n0.00032\n0.00031\n0.00030\n0.00029\n0.00028\n0.00027\n0.00026\n0.00025\n0.00024\n\n\n-3.3\n0.00048\n0.00047\n0.00045\n0.00043\n0.00042\n0.00040\n0.00039\n0.00038\n0.00036\n0.00035\n\n\n-3.2\n0.00069\n0.00066\n0.00064\n0.00062\n0.00060\n0.00058\n0.00056\n0.00054\n0.00052\n0.00050\n\n\n-3.1\n0.00097\n0.00094\n0.00090\n0.00087\n0.00084\n0.00082\n0.00079\n0.00076\n0.00074\n0.00071\n\n\n-3.0\n0.00135\n0.00131\n0.00126\n0.00122\n0.00118\n0.00114\n0.00111\n0.00107\n0.00104\n0.00100\n\n\n-2.9\n0.00187\n0.00181\n0.00175\n0.00169\n0.00164\n0.00159\n0.00154\n0.00149\n0.00144\n0.00139\n\n\n-2.8\n0.00256\n0.00248\n0.00240\n0.00233\n0.00226\n0.00219\n0.00212\n0.00205\n0.00199\n0.00193\n\n\n-2.7\n0.00347\n0.00336\n0.00326\n0.00317\n0.00307\n0.00298\n0.00289\n0.00280\n0.00272\n0.00264\n\n\n-2.6\n0.00466\n0.00453\n0.00440\n0.00427\n0.00415\n0.00402\n0.00391\n0.00379\n0.00368\n0.00357\n\n\n-2.5\n0.00621\n0.00604\n0.00587\n0.00570\n0.00554\n0.00539\n0.00523\n0.00508\n0.00494\n0.00480\n\n\n-2.4\n0.00820\n0.00798\n0.00776\n0.00755\n0.00734\n0.00714\n0.00695\n0.00676\n0.00657\n0.00639\n\n\n-2.3\n0.01072\n0.01044\n0.01017\n0.00990\n0.00964\n0.00939\n0.00914\n0.00889\n0.00866\n0.00842\n\n\n-2.2\n0.01390\n0.01355\n0.01321\n0.01287\n0.01255\n0.01222\n0.01191\n0.01160\n0.01130\n0.01101\n\n\n-2.1\n0.01786\n0.01743\n0.01700\n0.01659\n0.01618\n0.01578\n0.01539\n0.01500\n0.01463\n0.01426\n\n\n-2.0\n0.02275\n0.02222\n0.02169\n0.02118\n0.02068\n0.02018\n0.01970\n0.01923\n0.01876\n0.01831\n\n\n-1.9\n0.02872\n0.02807\n0.02743\n0.02680\n0.02619\n0.02559\n0.02500\n0.02442\n0.02385\n0.02330\n\n\n-1.8\n0.03593\n0.03515\n0.03438\n0.03362\n0.03288\n0.03216\n0.03144\n0.03074\n0.03005\n0.02938\n\n\n-1.7\n0.04457\n0.04363\n0.04272\n0.04182\n0.04093\n0.04006\n0.03920\n0.03836\n0.03754\n0.03673\n\n\n-1.6\n0.05480\n0.05370\n0.05262\n0.05155\n0.05050\n0.04947\n0.04846\n0.04746\n0.04648\n0.04551\n\n\n-1.5\n0.06681\n0.06552\n0.06426\n0.06301\n0.06178\n0.06057\n0.05938\n0.05821\n0.05705\n0.05592\n\n\n-1.4\n0.08076\n0.07927\n0.07780\n0.07636\n0.07493\n0.07353\n0.07215\n0.07078\n0.06944\n0.06811\n\n\n-1.3\n0.09680\n0.09510\n0.09342\n0.09176\n0.09012\n0.08851\n0.08692\n0.08534\n0.08379\n0.08226\n\n\n-1.2\n0.11507\n0.11314\n0.11123\n0.10935\n0.10749\n0.10565\n0.10383\n0.10204\n0.10027\n0.09853\n\n\n-1.1\n0.13567\n0.13350\n0.13136\n0.12924\n0.12714\n0.12507\n0.12302\n0.12100\n0.11900\n0.11702\n\n\n-1.0\n0.15866\n0.15625\n0.15386\n0.15151\n0.14917\n0.14686\n0.14457\n0.14231\n0.14007\n0.13786\n\n\n-0.9\n0.18406\n0.18141\n0.17879\n0.17619\n0.17361\n0.17106\n0.16853\n0.16602\n0.16354\n0.16109\n\n\n-0.8\n0.21186\n0.20897\n0.20611\n0.20327\n0.20045\n0.19766\n0.19489\n0.19215\n0.18943\n0.18673\n\n\n-0.7\n0.24196\n0.23885\n0.23576\n0.23270\n0.22965\n0.22663\n0.22363\n0.22065\n0.21770\n0.21476\n\n\n-0.6\n0.27425\n0.27093\n0.26763\n0.26435\n0.26109\n0.25785\n0.25463\n0.25143\n0.24825\n0.24510\n\n\n-0.5\n0.30854\n0.30503\n0.30153\n0.29806\n0.29460\n0.29116\n0.28774\n0.28434\n0.28096\n0.27760\n\n\n-0.4\n0.34458\n0.34090\n0.33724\n0.33360\n0.32997\n0.32636\n0.32276\n0.31918\n0.31561\n0.31207\n\n\n-0.3\n0.38209\n0.37828\n0.37448\n0.37070\n0.36693\n0.36317\n0.35942\n0.35569\n0.35197\n0.34827\n\n\n-0.2\n0.42074\n0.41683\n0.41294\n0.40905\n0.40517\n0.40129\n0.39743\n0.39358\n0.38974\n0.38591\n\n\n-0.1\n0.46017\n0.45620\n0.45224\n0.44828\n0.44433\n0.44038\n0.43644\n0.43251\n0.42858\n0.42465\n\n\n-0.0\n0.50000\n0.49601\n0.49202\n0.48803\n0.48405\n0.48006\n0.47608\n0.47210\n0.46812\n0.46414\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nz\n+0.00\n+0.01\n+0.02\n+0.03\n+0.04\n+0.05\n+0.06\n+0.07\n+0.08\n+0.09\n\n\n\n\n0.0\n0.50000\n0.50399\n0.50798\n0.51197\n0.51595\n0.51994\n0.52392\n0.52790\n0.53188\n0.53586\n\n\n0.1\n0.53983\n0.54380\n0.54776\n0.55172\n0.55567\n0.55962\n0.56360\n0.56749\n0.57142\n0.57535\n\n\n0.2\n0.57926\n0.58317\n0.58706\n0.59095\n0.59483\n0.59871\n0.60257\n0.60642\n0.61026\n0.61409\n\n\n0.3\n0.61791\n0.62172\n0.62552\n0.62930\n0.63307\n0.63683\n0.64058\n0.64431\n0.64803\n0.65173\n\n\n0.4\n0.65542\n0.65910\n0.66276\n0.66640\n0.67003\n0.67364\n0.67724\n0.68082\n0.68439\n0.68793\n\n\n0.5\n0.69146\n0.69497\n0.69847\n0.70194\n0.70540\n0.70884\n0.71226\n0.71566\n0.71904\n0.72240\n\n\n0.6\n0.72575\n0.72907\n0.73237\n0.73565\n0.73891\n0.74215\n0.74537\n0.74857\n0.75175\n0.75490\n\n\n0.7\n0.75804\n0.76115\n0.76424\n0.76730\n0.77035\n0.77337\n0.77637\n0.77935\n0.78230\n0.78524\n\n\n0.8\n0.78814\n0.79103\n0.79389\n0.79673\n0.79955\n0.80234\n0.80511\n0.80785\n0.81057\n0.81327\n\n\n0.9\n0.81594\n0.81859\n0.82121\n0.82381\n0.82639\n0.82894\n0.83147\n0.83398\n0.83646\n0.83891\n\n\n1.0\n0.84134\n0.84375\n0.84614\n0.84849\n0.85083\n0.85314\n0.85543\n0.85769\n0.85993\n0.86214\n\n\n1.1\n0.86433\n0.86650\n0.86864\n0.87076\n0.87286\n0.87493\n0.87698\n0.87900\n0.88100\n0.88298\n\n\n1.2\n0.88493\n0.88686\n0.88877\n0.89065\n0.89251\n0.89435\n0.89617\n0.89796\n0.89973\n0.90147\n\n\n1.3\n0.90320\n0.90490\n0.90658\n0.90824\n0.90988\n0.91149\n0.91308\n0.91466\n0.91621\n0.91774\n\n\n1.4\n0.91924\n0.92073\n0.92220\n0.92364\n0.92507\n0.92647\n0.92785\n0.92922\n0.93056\n0.93189\n\n\n1.5\n0.93319\n0.93448\n0.93574\n0.93699\n0.93822\n0.93943\n0.94062\n0.94179\n0.94295\n0.94408\n\n\n1.6\n0.94520\n0.94630\n0.94738\n0.94845\n0.94950\n0.95053\n0.95154\n0.95254\n0.95352\n0.95449\n\n\n1.7\n0.95543\n0.95637\n0.95728\n0.95818\n0.95907\n0.95994\n0.96080\n0.96164\n0.96246\n0.96327\n\n\n1.8\n0.96407\n0.96485\n0.96562\n0.96638\n0.96712\n0.96784\n0.96856\n0.96926\n0.96995\n0.97062\n\n\n1.9\n0.97128\n0.97193\n0.97257\n0.97320\n0.97381\n0.97441\n0.97500\n0.97558\n0.97615\n0.97670\n\n\n2.0\n0.97725\n0.97778\n0.97831\n0.97882\n0.97932\n0.97982\n0.98030\n0.98077\n0.98124\n0.98169\n\n\n2.1\n0.98214\n0.98257\n0.98300\n0.98341\n0.98382\n0.98422\n0.98461\n0.98500\n0.98537\n0.98574\n\n\n2.2\n0.98610\n0.98645\n0.98679\n0.98713\n0.98745\n0.98778\n0.98809\n0.98840\n0.98870\n0.98899\n\n\n2.3\n0.98928\n0.98956\n0.98983\n0.99010\n0.99036\n0.99061\n0.99086\n0.99111\n0.99134\n0.99158\n\n\n2.4\n0.99180\n0.99202\n0.99224\n0.99245\n0.99266\n0.99286\n0.99305\n0.99324\n0.99343\n0.99361\n\n\n2.5\n0.99379\n0.99396\n0.99413\n0.99430\n0.99446\n0.99461\n0.99477\n0.99492\n0.99506\n0.99520\n\n\n2.6\n0.99534\n0.99547\n0.99560\n0.99573\n0.99585\n0.99598\n0.99609\n0.99621\n0.99632\n0.99643\n\n\n2.7\n0.99653\n0.99664\n0.99674\n0.99683\n0.99693\n0.99702\n0.99711\n0.99720\n0.99728\n0.99736\n\n\n2.8\n0.99744\n0.99752\n0.99760\n0.99767\n0.99774\n0.99781\n0.99788\n0.99795\n0.99801\n0.99807\n\n\n2.9\n0.99813\n0.99819\n0.99825\n0.99831\n0.99836\n0.99841\n0.99846\n0.99851\n0.99856\n0.99861\n\n\n3.0\n0.99865\n0.99869\n0.99874\n0.99878\n0.99882\n0.99886\n0.99889\n0.99893\n0.99896\n0.99900\n\n\n3.1\n0.99903\n0.99906\n0.99910\n0.99913\n0.99916\n0.99918\n0.99921\n0.99924\n0.99926\n0.99929\n\n\n3.2\n0.99931\n0.99934\n0.99936\n0.99938\n0.99940\n0.99942\n0.99944\n0.99946\n0.99948\n0.99950\n\n\n3.3\n0.99952\n0.99953\n0.99955\n0.99957\n0.99958\n0.99960\n0.99961\n0.99962\n0.99964\n0.99965\n\n\n3.4\n0.99966\n0.99968\n0.99969\n0.99970\n0.99971\n0.99972\n0.99973\n0.99974\n0.99975\n0.99976\n\n\n3.5\n0.99977\n0.99978\n0.99978\n0.99979\n0.99980\n0.99981\n0.99981\n0.99982\n0.99983\n0.99983\n\n\n3.6\n0.99984\n0.99985\n0.99985\n0.99986\n0.99986\n0.99987\n0.99987\n0.99988\n0.99988\n0.99989\n\n\n3.7\n0.99989\n0.99990\n0.99990\n0.99990\n0.99991\n0.99991\n0.99992\n0.99992\n0.99992\n0.99992\n\n\n3.8\n0.99993\n0.99993\n0.99993\n0.99994\n0.99994\n0.99994\n0.99994\n0.99995\n0.99995\n0.99995\n\n\n3.9\n0.99995\n0.99995\n0.99996\n0.99996\n0.99996\n0.99996\n0.99996\n0.99996\n0.99997\n0.99997",
    "crumbs": [
      "付録",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>標準正規分布表</span>"
    ]
  },
  {
    "objectID": "appendices/linear_algebra.html",
    "href": "appendices/linear_algebra.html",
    "title": "付録 D — 線形代数",
    "section": "",
    "text": "D.1 固有値と固有ベクトル\n\\(n \\times n\\) 行列 \\(\\mathbf{A}\\) に対し，ベクトル \\(\\mathbf{x} \\neq \\mathbf{0}\\) とスカラー \\(\\lambda\\) が存在して， \\[\n\\mathbf{A} \\mathbf{x} = \\lambda \\mathbf{x}\n\\] が成り立つとき，\\(\\mathbf{x}\\) を \\(\\mathbf{A}\\) の固有ベクトル (eigenvector)，\\(\\lambda\\) を \\(\\mathbf{A}\\) の固有値 (eigenvalue) と呼ぶ．\n\\(\\mathbf{A} \\mathbf{x} = \\lambda \\mathbf{x}\\) は単位行列 \\(\\mathbf{I}\\) を用いて \\((\\mathbf{A} - \\lambda \\mathbf{I}) \\mathbf{x} = \\mathbf{0}\\) と書ける．このとき，\\(\\mathbf{x} \\neq \\mathbf{0}\\) であるため，\\(\\det(\\mathbf{A} - \\lambda \\mathbf{I}) = 0\\) が成り立つ．",
    "crumbs": [
      "付録",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>線形代数</span>"
    ]
  },
  {
    "objectID": "appendices/linear_algebra.html#固有値と固有ベクトル",
    "href": "appendices/linear_algebra.html#固有値と固有ベクトル",
    "title": "付録 D — 線形代数",
    "section": "",
    "text": "例 D.1 次のような \\(\\mathbf{A}, \\mathbf{x}, \\lambda\\) を考える． \\[\n\\mathbf{A} = \\begin{bmatrix}\n1 & 2 \\\\\n1/2 & 1 \\\\\n\\end{bmatrix}, \\quad\n\\mathbf{x} = \\begin{bmatrix}\n2 \\\\\n1 \\\\\n\\end{bmatrix}, \\quad\n\\lambda = 2\n\\]\nこのとき，\n\\[\n\\begin{bmatrix}\n1 & 2 \\\\\n1/2 & 1 \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n2 \\\\\n1 \\\\\n\\end{bmatrix}\n= \\begin{bmatrix}\n4 \\\\\n2 \\\\\n\\end{bmatrix}\n= 2 \\begin{bmatrix}\n2 \\\\\n1 \\\\\n\\end{bmatrix}\n\\]\nが成り立つため，\\(\\mathbf{x}\\) は \\(\\mathbf{A}\\) の固有ベクトル，\\(\\lambda\\) は \\(\\mathbf{A}\\) の固有値である．\n\n\n\n例 D.2 次のような行列 \\(\\mathbf{A}\\) を考える． \\[\n\\mathbf{A} = \\begin{bmatrix}\n1 & 2 \\\\\n1/2 & 1 \\\\\n\\end{bmatrix}\n\\]\nこのとき，\\(\\det(\\mathbf{A} - \\lambda \\mathbf{I})\\) は以下のようになる．\n\\[\\begin{align*}\n\\det(\\mathbf{A} - \\lambda \\mathbf{I}) &= \\det\\begin{bmatrix}\n1 - \\lambda & 2 \\\\\n1/2 & 1 - \\lambda \\\\\n\\end{bmatrix} \\\\\n&= (1 - \\lambda)^2 - 1 \\\\\n&= \\lambda^2 - 2\\lambda \\\\\n&= \\lambda(\\lambda - 2)\n\\end{align*}\\]\n\\(\\lambda(\\lambda - 2) = 0\\) より，\\(\\lambda = 0, 2\\) が得られる．",
    "crumbs": [
      "付録",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>線形代数</span>"
    ]
  }
]